import{d as Y,c as z,at as St,au as st,s as nt,a0 as kt,a1 as ht,u as w,f as N,h as I,_ as ft,G as mt,w as L,l as V,j as O,n as zt,H as bt,y as D,t as gt,z as X,av as it,i as k,aw as Ft,r as P,a5 as Mt,C as Ct,U as B,V as ot,ao as Tt,k as C,ax as rt,ay as W,q as Vt,az as ct,Q as Lt,aA as Ot,T as Et,F as At,v as Dt,A as $t,aB as jt}from"#entry";import{g as Nt,a as Rt}from"./CJ6W8aET.js";import{u as Pt,b as Bt}from"./DBMCc4Rq.js";const Wt={class:"badge-text"},Ut=Y({__name:"Badge",props:{img:{},text:{},link:{},round:{type:Boolean},square:{type:Boolean}},setup(i){const t=i,e=z(()=>{if(t.img)return t.img;const o=St(t.link);return o?Nt(o):t.link&&st(t.link)?Rt(nt(t.link)):""}),s=z(()=>e.value?!t.square:t.round),n=z(()=>t.link?st(t.link)?nt(t.link):decodeURIComponent(t.link):"");return(o,c)=>{const r=zt,a=ft,u=kt("tip");return ht((I(),N(a,{class:mt(["badge",{round:w(s)}]),to:i.link},{default:L(()=>[w(e)?(I(),N(r,{key:0,class:"badge-icon",src:w(e),alt:w(e)},null,8,["src","alt"])):V("",!0),O("span",Wt,[bt(o.$slots,"default",{},()=>[D(gt(i.text),1)],!0)])]),_:3},8,["class","to"])),[[u,w(n)]])}}}),Jt=Object.assign(X(Ut,[["__scopeId","data-v-acc9b659"]]),{__name:"Badge"}),qt={class:"title text-creative"},Qt=["innerHTML"],Ht=["innerHTML"],Kt=Y({__name:"SearchItem",props:{title:{},content:{},titles:{},level:{},id:{},terms:{},queryTerms:{},score:{},match:{}},setup(i){const t=i,e=z(()=>[...t.titles??[],t.title].join(" > ")),s=z(()=>t.queryTerms?.[0]??""),n=z(()=>it(e.value,s.value)),o=z(()=>it(t.content??"",s.value));return(c,r)=>{const a=Jt,u=ft;return I(),N(u,{to:i.id,class:"search-item"},{default:L(()=>[O("div",qt,[k(a,{round:"",class:mt({primary:i.level===1})},{default:L(()=>[D(gt(i.level===1?"文章":`H${i.level}`),1)]),_:1},8,["class"]),O("span",{innerHTML:w(n)},null,8,Qt)]),O("p",{class:"content",innerHTML:w(o)},null,8,Ht)]),_:1},8,["to"])}}}),Gt=Object.assign(X(Kt,[["__scopeId","data-v-f82f2088"]]),{__name:"ZSearchItem"}),Zt="ENTRIES",_t="KEYS",pt="VALUES",v="";class U{constructor(t,e){const s=t._tree,n=Array.from(s.keys());this.set=t,this._type=e,this._path=n.length>0?[{node:s,keys:n}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:e}=T(this._path);if(T(e)===v)return{done:!1,value:this.result()};const s=t.get(T(e));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=T(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>T(t)).filter(t=>t!==v).join("")}value(){return T(this._path).node.get(v)}result(){switch(this._type){case pt:return this.value();case _t:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const T=i=>i[i.length-1],Yt=(i,t,e)=>{const s=new Map;if(t===void 0)return s;const n=t.length+1,o=n+e,c=new Uint8Array(o*n).fill(e+1);for(let r=0;r<n;++r)c[r]=r;for(let r=1;r<o;++r)c[r*n]=r;return wt(i,t,e,s,c,1,n,""),s},wt=(i,t,e,s,n,o,c,r)=>{const a=o*c;t:for(const u of i.keys())if(u===v){const d=n[a-1];d<=e&&s.set(r,[i.get(u),d])}else{let d=o;for(let f=0;f<u.length;++f,++d){const h=u[f],g=c*d,p=g-c;let _=n[g];const m=Math.max(0,d-e-1),l=Math.min(c-1,d+e);for(let y=m;y<l;++y){const A=h!==t[y],b=n[p+y]+ +A,x=n[p+y+1]+1,S=n[g+y]+1,M=n[g+y+1]=Math.min(b,x,S);M<_&&(_=M)}if(_>e)continue t}wt(i.get(u),t,e,s,n,d,c,r+u)}};class F{constructor(t=new Map,e=""){this._size=void 0,this._tree=t,this._prefix=e}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[e,s]=R(this._tree,t.slice(this._prefix.length));if(e===void 0){const[n,o]=tt(s);for(const c of n.keys())if(c!==v&&c.startsWith(o)){const r=new Map;return r.set(c.slice(o.length),n.get(c)),new F(r,t)}}return new F(e,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,Xt(this._tree,t)}entries(){return new U(this,Zt)}forEach(t){for(const[e,s]of this)t(e,s,this)}fuzzyGet(t,e){return Yt(this._tree,t,e)}get(t){const e=K(this._tree,t);return e!==void 0?e.get(v):void 0}has(t){const e=K(this._tree,t);return e!==void 0&&e.has(v)}keys(){return new U(this,_t)}set(t,e){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,J(this._tree,t).set(v,e),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=J(this._tree,t);return s.set(v,e(s.get(v))),this}fetch(t,e){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=J(this._tree,t);let n=s.get(v);return n===void 0&&s.set(v,n=e()),n}values(){return new U(this,pt)}[Symbol.iterator](){return this.entries()}static from(t){const e=new F;for(const[s,n]of t)e.set(s,n);return e}static fromObject(t){return F.from(Object.entries(t))}}const R=(i,t,e=[])=>{if(t.length===0||i==null)return[i,e];for(const s of i.keys())if(s!==v&&t.startsWith(s))return e.push([i,s]),R(i.get(s),t.slice(s.length),e);return e.push([i,t]),R(void 0,"",e)},K=(i,t)=>{if(t.length===0||i==null)return i;for(const e of i.keys())if(e!==v&&t.startsWith(e))return K(i.get(e),t.slice(e.length))},J=(i,t)=>{const e=t.length;t:for(let s=0;i&&s<e;){for(const o of i.keys())if(o!==v&&t[s]===o[0]){const c=Math.min(e-s,o.length);let r=1;for(;r<c&&t[s+r]===o[r];)++r;const a=i.get(o);if(r===o.length)i=a;else{const u=new Map;u.set(o.slice(r),a),i.set(t.slice(s,s+r),u),i.delete(o),i=u}s+=r;continue t}const n=new Map;return i.set(t.slice(s),n),n}return i},Xt=(i,t)=>{const[e,s]=R(i,t);if(e!==void 0){if(e.delete(v),e.size===0)vt(s);else if(e.size===1){const[n,o]=e.entries().next().value;yt(s,n,o)}}},vt=i=>{if(i.length===0)return;const[t,e]=tt(i);if(t.delete(e),t.size===0)vt(i.slice(0,-1));else if(t.size===1){const[s,n]=t.entries().next().value;s!==v&&yt(i.slice(0,-1),s,n)}},yt=(i,t,e)=>{if(i.length===0)return;const[s,n]=tt(i);s.set(n+t,e),s.delete(n)},tt=i=>i[i.length-1],et="or",xt="and",te="and_not";class E{constructor(t){if(t?.fields==null)throw new Error('MiniSearch: option "fields" must be provided');const e=t.autoVacuum==null||t.autoVacuum===!0?H:t.autoVacuum;this._options={...Q,...t,autoVacuum:e,searchOptions:{...at,...t.searchOptions||{}},autoSuggestOptions:{...oe,...t.autoSuggestOptions||{}}},this._index=new F,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=Z,this.addFields(this._options.fields)}add(t){const{extractField:e,stringifyField:s,tokenize:n,processTerm:o,fields:c,idField:r}=this._options,a=e(t,r);if(a==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);if(this._idToShortId.has(a))throw new Error(`MiniSearch: duplicate ID ${a}`);const u=this.addDocumentId(a);this.saveStoredFields(u,t);for(const d of c){const f=e(t,d);if(f==null)continue;const h=n(s(f,d),d),g=this._fieldIds[d],p=new Set(h).size;this.addFieldLength(u,g,this._documentCount-1,p);for(const _ of h){const m=o(_,d);if(Array.isArray(m))for(const l of m)this.addTerm(g,u,l);else m&&this.addTerm(g,u,m)}}}addAll(t){for(const e of t)this.add(e)}addAllAsync(t,e={}){const{chunkSize:s=10}=e,n={chunk:[],promise:Promise.resolve()},{chunk:o,promise:c}=t.reduce(({chunk:r,promise:a},u,d)=>(r.push(u),(d+1)%s===0?{chunk:[],promise:a.then(()=>new Promise(f=>setTimeout(f,0))).then(()=>this.addAll(r))}:{chunk:r,promise:a}),n);return c.then(()=>this.addAll(o))}remove(t){const{tokenize:e,processTerm:s,extractField:n,stringifyField:o,fields:c,idField:r}=this._options,a=n(t,r);if(a==null)throw new Error(`MiniSearch: document does not have ID field "${r}"`);const u=this._idToShortId.get(a);if(u==null)throw new Error(`MiniSearch: cannot remove document with ID ${a}: it is not in the index`);for(const d of c){const f=n(t,d);if(f==null)continue;const h=e(o(f,d),d),g=this._fieldIds[d],p=new Set(h).size;this.removeFieldLength(u,g,this._documentCount,p);for(const _ of h){const m=s(_,d);if(Array.isArray(m))for(const l of m)this.removeTerm(g,u,l);else m&&this.removeTerm(g,u,m)}}this._storedFields.delete(u),this._documentIds.delete(u),this._idToShortId.delete(a),this._fieldLength.delete(u),this._documentCount-=1}removeAll(t){if(t)for(const e of t)this.remove(e);else{if(arguments.length>0)throw new Error("Expected documents to be present. Omit the argument to remove all documents.");this._index=new F,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldLength=new Map,this._avgFieldLength=[],this._storedFields=new Map,this._nextId=0}}discard(t){const e=this._idToShortId.get(t);if(e==null)throw new Error(`MiniSearch: cannot discard document with ID ${t}: it is not in the index`);this._idToShortId.delete(t),this._documentIds.delete(e),this._storedFields.delete(e),(this._fieldLength.get(e)||[]).forEach((s,n)=>{this.removeFieldLength(e,n,this._documentCount,s)}),this._fieldLength.delete(e),this._documentCount-=1,this._dirtCount+=1,this.maybeAutoVacuum()}maybeAutoVacuum(){if(this._options.autoVacuum===!1)return;const{minDirtFactor:t,minDirtCount:e,batchSize:s,batchWait:n}=this._options.autoVacuum;this.conditionalVacuum({batchSize:s,batchWait:n},{minDirtCount:e,minDirtFactor:t})}discardAll(t){const e=this._options.autoVacuum;try{this._options.autoVacuum=!1;for(const s of t)this.discard(s)}finally{this._options.autoVacuum=e}this.maybeAutoVacuum()}replace(t){const{idField:e,extractField:s}=this._options,n=s(t,e);this.discard(n),this.add(t)}vacuum(t={}){return this.conditionalVacuum(t)}conditionalVacuum(t,e){return this._currentVacuum?(this._enqueuedVacuumConditions=this._enqueuedVacuumConditions&&e,this._enqueuedVacuum!=null?this._enqueuedVacuum:(this._enqueuedVacuum=this._currentVacuum.then(()=>{const s=this._enqueuedVacuumConditions;return this._enqueuedVacuumConditions=Z,this.performVacuuming(t,s)}),this._enqueuedVacuum)):this.vacuumConditionsMet(e)===!1?Promise.resolve():(this._currentVacuum=this.performVacuuming(t),this._currentVacuum)}async performVacuuming(t,e){const s=this._dirtCount;if(this.vacuumConditionsMet(e)){const n=t.batchSize||G.batchSize,o=t.batchWait||G.batchWait;let c=1;for(const[r,a]of this._index){for(const[u,d]of a)for(const[f]of d)this._documentIds.has(f)||(d.size<=1?a.delete(u):d.delete(f));this._index.get(r).size===0&&this._index.delete(r),c%n===0&&await new Promise(u=>setTimeout(u,o)),c+=1}this._dirtCount-=s}await null,this._currentVacuum=this._enqueuedVacuum,this._enqueuedVacuum=null}vacuumConditionsMet(t){if(t==null)return!0;let{minDirtCount:e,minDirtFactor:s}=t;return e=e||H.minDirtCount,s=s||H.minDirtFactor,this.dirtCount>=e&&this.dirtFactor>=s}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}has(t){return this._idToShortId.has(t)}getStoredFields(t){const e=this._idToShortId.get(t);if(e!=null)return this._storedFields.get(e)}search(t,e={}){const{searchOptions:s}=this._options,n={...s,...e},o=this.executeQuery(t,e),c=[];for(const[r,{score:a,terms:u,match:d}]of o){const f=u.length||1,h={id:this._documentIds.get(r),score:a*f,terms:Object.keys(d),queryTerms:u,match:d};Object.assign(h,this._storedFields.get(r)),(n.filter==null||n.filter(h))&&c.push(h)}return t===E.wildcard&&n.boostDocument==null||c.sort(dt),c}autoSuggest(t,e={}){e={...this._options.autoSuggestOptions,...e};const s=new Map;for(const{score:o,terms:c}of this.search(t,e)){const r=c.join(" "),a=s.get(r);a!=null?(a.score+=o,a.count+=1):s.set(r,{score:o,terms:c,count:1})}const n=[];for(const[o,{score:c,terms:r,count:a}]of s)n.push({suggestion:o,terms:r,score:c/a});return n.sort(dt),n}get documentCount(){return this._documentCount}get termCount(){return this._index.size}static loadJSON(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJS(JSON.parse(t),e)}static async loadJSONAsync(t,e){if(e==null)throw new Error("MiniSearch: loadJSON should be given the same options used when serializing the index");return this.loadJSAsync(JSON.parse(t),e)}static getDefault(t){if(Q.hasOwnProperty(t))return q(Q,t);throw new Error(`MiniSearch: unknown option "${t}"`)}static loadJS(t,e){const{index:s,documentIds:n,fieldLength:o,storedFields:c,serializationVersion:r}=t,a=this.instantiateMiniSearch(t,e);a._documentIds=$(n),a._fieldLength=$(o),a._storedFields=$(c);for(const[u,d]of a._documentIds)a._idToShortId.set(d,u);for(const[u,d]of s){const f=new Map;for(const h of Object.keys(d)){let g=d[h];r===1&&(g=g.ds),f.set(parseInt(h,10),$(g))}a._index.set(u,f)}return a}static async loadJSAsync(t,e){const{index:s,documentIds:n,fieldLength:o,storedFields:c,serializationVersion:r}=t,a=this.instantiateMiniSearch(t,e);a._documentIds=await j(n),a._fieldLength=await j(o),a._storedFields=await j(c);for(const[d,f]of a._documentIds)a._idToShortId.set(f,d);let u=0;for(const[d,f]of s){const h=new Map;for(const g of Object.keys(f)){let p=f[g];r===1&&(p=p.ds),h.set(parseInt(g,10),await j(p))}++u%1e3===0&&await It(0),a._index.set(d,h)}return a}static instantiateMiniSearch(t,e){const{documentCount:s,nextId:n,fieldIds:o,averageFieldLength:c,dirtCount:r,serializationVersion:a}=t;if(a!==1&&a!==2)throw new Error("MiniSearch: cannot deserialize an index created with an incompatible version");const u=new E(e);return u._documentCount=s,u._nextId=n,u._idToShortId=new Map,u._fieldIds=o,u._avgFieldLength=c,u._dirtCount=r||0,u._index=new F,u}executeQuery(t,e={}){if(t===E.wildcard)return this.executeWildcardQuery(e);if(typeof t!="string"){const h={...e,...t,queries:void 0},g=t.queries.map(p=>this.executeQuery(p,h));return this.combineResults(g,h.combineWith)}const{tokenize:s,processTerm:n,searchOptions:o}=this._options,c={tokenize:s,processTerm:n,...o,...e},{tokenize:r,processTerm:a}=c,f=r(t).flatMap(h=>a(h)).filter(h=>!!h).map(ie(c)).map(h=>this.executeQuerySpec(h,c));return this.combineResults(f,c.combineWith)}executeQuerySpec(t,e){const s={...this._options.searchOptions,...e},n=(s.fields||this._options.fields).reduce((_,m)=>({..._,[m]:q(s.boost,m)||1}),{}),{boostDocument:o,weights:c,maxFuzzy:r,bm25:a}=s,{fuzzy:u,prefix:d}={...at.weights,...c},f=this._index.get(t.term),h=this.termResults(t.term,t.term,1,t.termBoost,f,n,o,a);let g,p;if(t.prefix&&(g=this._index.atPrefix(t.term)),t.fuzzy){const _=t.fuzzy===!0?.2:t.fuzzy,m=_<1?Math.min(r,Math.round(t.term.length*_)):_;m&&(p=this._index.fuzzyGet(t.term,m))}if(g)for(const[_,m]of g){const l=_.length-t.term.length;if(!l)continue;p?.delete(_);const y=d*_.length/(_.length+.3*l);this.termResults(t.term,_,y,t.termBoost,m,n,o,a,h)}if(p)for(const _ of p.keys()){const[m,l]=p.get(_);if(!l)continue;const y=u*_.length/(_.length+l);this.termResults(t.term,_,y,t.termBoost,m,n,o,a,h)}return h}executeWildcardQuery(t){const e=new Map,s={...this._options.searchOptions,...t};for(const[n,o]of this._documentIds){const c=s.boostDocument?s.boostDocument(o,"",this._storedFields.get(n)):1;e.set(n,{score:c,terms:[],match:{}})}return e}combineResults(t,e=et){if(t.length===0)return new Map;const s=e.toLowerCase(),n=ee[s];if(!n)throw new Error(`Invalid combination operator: ${e}`);return t.reduce(n)||new Map}toJSON(){const t=[];for(const[e,s]of this._index){const n={};for(const[o,c]of s)n[o]=Object.fromEntries(c);t.push([e,n])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,serializationVersion:2}}termResults(t,e,s,n,o,c,r,a,u=new Map){if(o==null)return u;for(const d of Object.keys(c)){const f=c[d],h=this._fieldIds[d],g=o.get(h);if(g==null)continue;let p=g.size;const _=this._avgFieldLength[h];for(const m of g.keys()){if(!this._documentIds.has(m)){this.removeTerm(h,m,e),p-=1;continue}const l=r?r(this._documentIds.get(m),e,this._storedFields.get(m)):1;if(!l)continue;const y=g.get(m),A=this._fieldLength.get(m)[h],b=ne(y,p,this._documentCount,A,_,a),x=s*n*f*l*b,S=u.get(m);if(S){S.score+=x,re(S.terms,t);const M=q(S.match,e);M?M.push(d):S.match[e]=[d]}else u.set(m,{score:x,terms:[t],match:{[e]:[d]}})}}return u}addTerm(t,e,s){const n=this._index.fetch(s,lt);let o=n.get(t);if(o==null)o=new Map,o.set(e,1),n.set(t,o);else{const c=o.get(e);o.set(e,(c||0)+1)}}removeTerm(t,e,s){if(!this._index.has(s)){this.warnDocumentChanged(e,t,s);return}const n=this._index.fetch(s,lt),o=n.get(t);o==null||o.get(e)==null?this.warnDocumentChanged(e,t,s):o.get(e)<=1?o.size<=1?n.delete(t):o.delete(e):o.set(e,o.get(e)-1),this._index.get(s).size===0&&this._index.delete(s)}warnDocumentChanged(t,e,s){for(const n of Object.keys(this._fieldIds))if(this._fieldIds[n]===e){this._options.logger("warn",`MiniSearch: document with ID ${this._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${n}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}}addDocumentId(t){const e=this._nextId;return this._idToShortId.set(t,e),this._documentIds.set(e,t),this._documentCount+=1,this._nextId+=1,e}addFields(t){for(let e=0;e<t.length;e++)this._fieldIds[t[e]]=e}addFieldLength(t,e,s,n){let o=this._fieldLength.get(t);o==null&&this._fieldLength.set(t,o=[]),o[e]=n;const r=(this._avgFieldLength[e]||0)*s+n;this._avgFieldLength[e]=r/(s+1)}removeFieldLength(t,e,s,n){if(s===1){this._avgFieldLength[e]=0;return}const o=this._avgFieldLength[e]*s-n;this._avgFieldLength[e]=o/(s-1)}saveStoredFields(t,e){const{storeFields:s,extractField:n}=this._options;if(s==null||s.length===0)return;let o=this._storedFields.get(t);o==null&&this._storedFields.set(t,o={});for(const c of s){const r=n(e,c);r!==void 0&&(o[c]=r)}}}E.wildcard=Symbol("*");const q=(i,t)=>Object.prototype.hasOwnProperty.call(i,t)?i[t]:void 0,ee={[et]:(i,t)=>{for(const e of t.keys()){const s=i.get(e);if(s==null)i.set(e,t.get(e));else{const{score:n,terms:o,match:c}=t.get(e);s.score=s.score+n,s.match=Object.assign(s.match,c),ut(s.terms,o)}}return i},[xt]:(i,t)=>{const e=new Map;for(const s of t.keys()){const n=i.get(s);if(n==null)continue;const{score:o,terms:c,match:r}=t.get(s);ut(n.terms,c),e.set(s,{score:n.score+o,terms:n.terms,match:Object.assign(n.match,r)})}return e},[te]:(i,t)=>{for(const e of t.keys())i.delete(e);return i}},se={k:1.2,b:.7,d:.5},ne=(i,t,e,s,n,o)=>{const{k:c,b:r,d:a}=o;return Math.log(1+(e-t+.5)/(t+.5))*(a+i*(c+1)/(i+c*(1-r+r*s/n)))},ie=i=>(t,e,s)=>{const n=typeof i.fuzzy=="function"?i.fuzzy(t,e,s):i.fuzzy||!1,o=typeof i.prefix=="function"?i.prefix(t,e,s):i.prefix===!0,c=typeof i.boostTerm=="function"?i.boostTerm(t,e,s):1;return{term:t,fuzzy:n,prefix:o,termBoost:c}},Q={idField:"id",extractField:(i,t)=>i[t],stringifyField:(i,t)=>i.toString(),tokenize:i=>i.split(ce),processTerm:i=>i.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(i,t)=>{typeof console?.[i]=="function"&&console[i](t)},autoVacuum:!0},at={combineWith:et,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:se},oe={combineWith:xt,prefix:(i,t,e)=>t===e.length-1},G={batchSize:1e3,batchWait:10},Z={minDirtFactor:.1,minDirtCount:20},H={...G,...Z},re=(i,t)=>{i.includes(t)||i.push(t)},ut=(i,t)=>{for(const e of t)i.includes(e)||i.push(e)},dt=({score:i},{score:t})=>t-i,lt=()=>new Map,$=i=>{const t=new Map;for(const e of Object.keys(i))t.set(parseInt(e,10),i[e]);return t},j=async i=>{const t=new Map;let e=0;for(const s of Object.keys(i))t.set(parseInt(s,10),i[s]),++e%1e3===0&&await It(0);return t},It=i=>new Promise(t=>setTimeout(t,i)),ce=/[\n\r\p{Z}\p{P}]+/u,ae={class:"z-search"},ue={key:0,id:"z-search"},de={key:0,class:"no-result"},le={key:1,ref:"list-result",class:"scrollcheck-y search-result"},he=Y({__name:"Search",props:{show:{type:Boolean}},setup(i){const t=i,{data:e,status:s}=Pt("search",()=>Bt("content",{ignoredTags:["pre"]})),n=new E({fields:["title","content"],storeFields:["title","titles","content","level"],searchOptions:{prefix:!0,fuzzy:.2}}),o=Ft(),c=P(),{word:r}=Mt(o),a=z(()=>(e.value,n.search(r.value))),u=P(!1),d=Ct("list-result"),f=P(0),h=z(()=>d.value?.children[f.value]);B(()=>t.show,g),B(s,m=>{m==="success"&&e.value&&n.addAll(e.value)}),B(r,()=>{f.value=0}),ot("mousemove",()=>u.value=!1),ot("keydown",()=>u.value=!0);async function g(){await Tt(),c.value?.focus()}function p(m,l=!1){g(),!(m<0||m>=a.value?.length)&&(f.value=m,l&&(u.value=!0),h.value&&u.value&&h.value.scrollIntoView({block:"nearest"}))}function _(){h.value?.click()}return(m,l)=>{const y=Vt,A=Gt,b=jt;return I(),C("div",ae,[k(rt,null,{default:L(()=>[i.show?(I(),C("div",{key:0,id:"z-search-bgmask",onClick:l[0]||(l[0]=x=>w(o).toggle())})):V("",!0)]),_:1}),k(rt,{name:"float-in"},{default:L(()=>[i.show?(I(),C("div",ue,[O("form",{class:"input",onSubmit:l[4]||(l[4]=W(()=>{},["prevent"]))},[k(y,{name:w(s)==="pending"?"line-md:loading-alt-loop":"ph:magnifying-glass-bold"},null,8,["name"]),ht(O("input",{ref_key:"searchInput",ref:c,"onUpdate:modelValue":l[1]||(l[1]=x=>Lt(r)?r.value=x:null),type:"search",incremental:"",class:"search-input",placeholder:"键入开始搜索",onKeydown:[l[2]||(l[2]=ct(W(()=>{},["prevent"]),["up"])),l[3]||(l[3]=ct(W(()=>{},["prevent"]),["down"]))]},null,544),[[Ot,w(r)]])],32),k(Et,{name:"expand"},{default:L(()=>[w(r)&&w(s)==="success"&&!w(a)?.length?(I(),C("div",de," 无结果 ")):V("",!0),w(r)&&w(a)?.length?(I(),C("ol",le,[(I(!0),C(At,null,Dt(w(a),(x,S)=>(I(),N(A,$t({key:x.id},{ref_for:!0},x,{class:{active:w(f)===S},onClick:l[5]||(l[5]=M=>w(o).toggle()),onMousemove:M=>p(S)}),null,16,["class","onMousemove"]))),128))],512)):V("",!0),w(r)&&w(a)?.length?(I(),C("div",{key:2,class:"tip",onClick:l[9]||(l[9]=x=>w(c)?.focus())},[k(b,{code:"ArrowUp",prevent:"",onPress:l[6]||(l[6]=x=>p(w(f)-1,!0))}),k(b,{code:"ArrowDown",prevent:"",onPress:l[7]||(l[7]=x=>p(w(f)+1,!0))}),l[10]||(l[10]=D(" 切换  ",-1)),k(b,{code:"Enter",icon:"",onPress:_}),l[11]||(l[11]=D(" 选择  ",-1)),k(b,{code:"Escape",icon:!1,onPress:l[8]||(l[8]=x=>w(o).toggle())}),l[12]||(l[12]=D(" 关闭 ",-1))])):V("",!0)]),_:1})])):V("",!0)]),_:1})])}}}),_e=Object.assign(X(he,[["__scopeId","data-v-d42e252e"]]),{__name:"PopoverSearch"});export{_e as default};
