<!DOCTYPE html><html  lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="importmap">{"imports":{"#entry":"/_nuxt/DrtDzEft.js"}}</script><title>力扣Hot100 | 字节追风者</title><link rel="preconnect" href="https://twikoo.zhilu.cyou/"><link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.9/katex.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://rsms.me/inter/inter.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://fonts.googleapis.cn/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&family=Noto+Serif+SC:wght@200..900&display=swap" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://cdn-font.hyperos.mi.com/font/css?family=MiSans:100,200,300,400,450,500,600,650,700,900:Chinese_Simplify,Latin&display=swap" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="/_nuxt/entry.CbLaJWFq.css" crossorigin><link rel="stylesheet" href="/_nuxt/_...BJDcHRWl.css" crossorigin><link rel="stylesheet" href="/_nuxt/Comment.DHhhws_e.css" crossorigin><link rel="stylesheet" href="/_nuxt/ProseA.BTfGpl4j.css" crossorigin><link rel="stylesheet" href="/_nuxt/Toc.Bo4Cbq2k.css" crossorigin><link rel="stylesheet" href="/_nuxt/ZWidget.B1kbKjic.css" crossorigin><link rel="stylesheet" href="/_nuxt/ProseCode.a2_W97gt.css" crossorigin><link rel="stylesheet" href="/_nuxt/ProseTable.DQgQdj7r.css" crossorigin><link rel="stylesheet" href="/_nuxt/Pic.BzJZ6rrE.css" crossorigin><style>:where(.i-ph\:align-right-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cg fill='black'%3E%3Cpath d='M184 64v40a8 8 0 0 1-8 8H80a8 8 0 0 1-8-8V64a8 8 0 0 1 8-8h96a8 8 0 0 1 8 8m-8 80H40a8 8 0 0 0-8 8v40a8 8 0 0 0 8 8h136a8 8 0 0 0 8-8v-40a8 8 0 0 0-8-8' opacity='.2'/%3E%3Cpath d='M224 40v176a8 8 0 0 1-16 0V40a8 8 0 0 1 16 0m-32 24v40a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16V64a16 16 0 0 1 16-16h96a16 16 0 0 1 16 16m-16 0H80v40h96Zm16 88v40a16 16 0 0 1-16 16H40a16 16 0 0 1-16-16v-40a16 16 0 0 1 16-16h136a16 16 0 0 1 16 16m-16 0H40v40h136Z'/%3E%3C/g%3E%3C/svg%3E")}:where(.i-ph\:archive-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M224 44H32a20 20 0 0 0-20 20v24a20 20 0 0 0 16 19.6V192a20 20 0 0 0 20 20h160a20 20 0 0 0 20-20v-84.4A20 20 0 0 0 244 88V64a20 20 0 0 0-20-20M36 68h184v16H36Zm16 120v-80h152v80Zm112-52a12 12 0 0 1-12 12h-48a12 12 0 0 1 0-24h48a12 12 0 0 1 12 12'/%3E%3C/svg%3E")}:where(.i-ph\:arrow-circle-up-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M128 20a108 108 0 1 0 108 108A108.12 108.12 0 0 0 128 20m0 192a84 84 0 1 1 84-84a84.09 84.09 0 0 1-84 84m40.49-100.49a12 12 0 0 1-17 17L140 117v51a12 12 0 0 1-24 0v-51l-11.51 11.52a12 12 0 0 1-17-17l32-32a12 12 0 0 1 17 0Z'/%3E%3C/svg%3E")}:where(.i-ph\:arrow-u-down-left-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M236 112a68.07 68.07 0 0 1-68 68H61l27.52 27.51a12 12 0 0 1-17 17l-48-48a12 12 0 0 1 0-17l48-48a12 12 0 1 1 17 17L61 156h107a44 44 0 0 0 0-88H80a12 12 0 0 1 0-24h88a68.07 68.07 0 0 1 68 68'/%3E%3C/svg%3E")}:where(.i-ph\:calendar-dots-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M208 28h-20v-4a12 12 0 0 0-24 0v4H92v-4a12 12 0 0 0-24 0v4H48a20 20 0 0 0-20 20v160a20 20 0 0 0 20 20h160a20 20 0 0 0 20-20V48a20 20 0 0 0-20-20M68 52a12 12 0 0 0 24 0h72a12 12 0 0 0 24 0h16v24H52V52ZM52 204V100h152v104Zm92-76a16 16 0 1 1-16-16a16 16 0 0 1 16 16m48 0a16 16 0 1 1-16-16a16 16 0 0 1 16 16m-96 48a16 16 0 1 1-16-16a16 16 0 0 1 16 16m48 0a16 16 0 1 1-16-16a16 16 0 0 1 16 16m48 0a16 16 0 1 1-16-16a16 16 0 0 1 16 16'/%3E%3C/svg%3E")}:where(.i-ph\:caret-double-up-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M216.49 191.51a12 12 0 0 1-17 17L128 137l-71.51 71.49a12 12 0 0 1-17-17l80-80a12 12 0 0 1 17 0Zm-160-63L128 57l71.51 71.52a12 12 0 0 0 17-17l-80-80a12 12 0 0 0-17 0l-80 80a12 12 0 0 0 17 17Z'/%3E%3C/svg%3E")}:where(.i-ph\:certificate-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M128 140a12 12 0 0 1-12 12H72a12 12 0 0 1 0-24h44a12 12 0 0 1 12 12m-12-52H72a12 12 0 0 0 0 24h44a12 12 0 0 0 0-24m120 79.14V228a12 12 0 0 1-17.95 10.42L196 225.82l-22 12.6A12 12 0 0 1 156 228v-24H40a20 20 0 0 1-20-20V56a20 20 0 0 1 20-20h176a20 20 0 0 1 20 20v32.86a55.87 55.87 0 0 1 0 78.28M196 160a32 32 0 1 0-32-32a32 32 0 0 0 32 32m-40 20v-12.86a56 56 0 0 1 56-92.8V60H44v120Zm56 27.32v-25.66a55.87 55.87 0 0 1-32 0v25.66l10.05-5.74a12 12 0 0 1 11.9 0Z'/%3E%3C/svg%3E")}:where(.i-ph\:chat-circle-text-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M172 108a12 12 0 0 1-12 12H96a12 12 0 0 1 0-24h64a12 12 0 0 1 12 12m-12 28H96a12 12 0 0 0 0 24h64a12 12 0 0 0 0-24m76-8a108 108 0 0 1-157.23 96.15L46.34 235A20 20 0 0 1 21 209.66l10.81-32.43A108 108 0 1 1 236 128m-24 0a84 84 0 1 0-156.73 42.06a12 12 0 0 1 1 9.81l-9.93 29.79l29.79-9.93a12.1 12.1 0 0 1 3.8-.62a12 12 0 0 1 6 1.62A84 84 0 0 0 212 128'/%3E%3C/svg%3E")}:where(.i-ph\:code-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M71.68 97.22L34.74 128l36.94 30.78a12 12 0 1 1-15.36 18.44l-48-40a12 12 0 0 1 0-18.44l48-40a12 12 0 0 1 15.36 18.44m176 21.56l-48-40a12 12 0 1 0-15.36 18.44L221.26 128l-36.94 30.78a12 12 0 1 0 15.36 18.44l48-40a12 12 0 0 0 0-18.44M164.1 28.72a12 12 0 0 0-15.38 7.18l-64 176a12 12 0 0 0 7.18 15.37a11.8 11.8 0 0 0 4.1.73a12 12 0 0 0 11.28-7.9l64-176a12 12 0 0 0-7.18-15.38'/%3E%3C/svg%3E")}:where(.i-ph\:envelope-simple-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M224 44H32a12 12 0 0 0-12 12v136a20 20 0 0 0 20 20h176a20 20 0 0 0 20-20V56a12 12 0 0 0-12-12m-30.85 24L128 127.72L62.85 68ZM44 188V83.28l75.89 69.57a12 12 0 0 0 16.22 0L212 83.28V188Z'/%3E%3C/svg%3E")}:where(.i-ph\:files-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='m220.49 59.51l-40-40A12 12 0 0 0 172 16H92a20 20 0 0 0-20 20v20H56a20 20 0 0 0-20 20v140a20 20 0 0 0 20 20h108a20 20 0 0 0 20-20v-20h20a20 20 0 0 0 20-20V68a12 12 0 0 0-3.51-8.49M160 212H60V80h67l33 33Zm40-40h-16v-64a12 12 0 0 0-3.51-8.49l-40-40A12 12 0 0 0 132 56H96V40h71l33 33Zm-56-28a12 12 0 0 1-12 12H88a12 12 0 0 1 0-24h44a12 12 0 0 1 12 12m0 40a12 12 0 0 1-12 12H88a12 12 0 0 1 0-24h44a12 12 0 0 1 12 12'/%3E%3C/svg%3E")}:where(.i-ph\:github-logo-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M212.62 75.17A63.7 63.7 0 0 0 206.39 26A12 12 0 0 0 196 20a63.71 63.71 0 0 0-50 24h-20a63.71 63.71 0 0 0-50-24a12 12 0 0 0-10.39 6a63.7 63.7 0 0 0-6.23 49.17A61.5 61.5 0 0 0 52 104v8a60.1 60.1 0 0 0 45.76 58.28A43.66 43.66 0 0 0 92 192v4H76a20 20 0 0 1-20-20a44.05 44.05 0 0 0-44-44a12 12 0 0 0 0 24a20 20 0 0 1 20 20a44.05 44.05 0 0 0 44 44h16v12a12 12 0 0 0 24 0v-40a20 20 0 0 1 40 0v40a12 12 0 0 0 24 0v-40a43.66 43.66 0 0 0-5.76-21.72A60.1 60.1 0 0 0 220 112v-8a61.5 61.5 0 0 0-7.38-28.83M196 112a36 36 0 0 1-36 36h-48a36 36 0 0 1-36-36v-8a37.87 37.87 0 0 1 6.13-20.12a11.65 11.65 0 0 0 1.58-11.49a39.9 39.9 0 0 1-.4-27.72a39.87 39.87 0 0 1 26.41 17.8a12 12 0 0 0 10.1 5.53h32.35a12 12 0 0 0 10.11-5.53a39.84 39.84 0 0 1 26.41-17.8a39.9 39.9 0 0 1-.4 27.72a12 12 0 0 0 1.61 11.53A37.85 37.85 0 0 1 196 104Z'/%3E%3C/svg%3E")}:where(.i-ph\:highlighter-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M252.49 107.51a12 12 0 0 0-17 0L192 151l-79-79l43.52-43.51a12 12 0 0 0-17-17L93.17 57.86a20 20 0 0 0-4.72 20.72L69.17 97.86a20 20 0 0 0 0 28.28L71 128l-55.49 55.51a12 12 0 0 0 4.7 19.87l72 24A11.8 11.8 0 0 0 96 228a12 12 0 0 0 8.49-3.52L136 193l1.86 1.86a20 20 0 0 0 28.28 0l19.27-19.27a20.3 20.3 0 0 0 6.59 1.13a19.86 19.86 0 0 0 14.14-5.86l46.35-46.34a12 12 0 0 0 0-17.01M92.76 202.27l-46.55-15.51L88 145l31 31ZM152 175l-55.51-55.48L89 112l15-15l63 63Z'/%3E%3C/svg%3E")}:where(.i-ph\:house-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='m222.14 105.85l-80-80a20 20 0 0 0-28.28 0l-80 80A19.86 19.86 0 0 0 28 120v96a12 12 0 0 0 12 12h64a12 12 0 0 0 12-12v-52h24v52a12 12 0 0 0 12 12h64a12 12 0 0 0 12-12v-96a19.86 19.86 0 0 0-5.86-14.15M204 204h-40v-52a12 12 0 0 0-12-12h-48a12 12 0 0 0-12 12v52H52v-82.35l76-76l76 76Z'/%3E%3C/svg%3E")}:where(.i-ph\:link-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M117.18 188.74a12 12 0 0 1 0 17l-5.12 5.12A58.26 58.26 0 0 1 70.6 228a58.62 58.62 0 0 1-41.46-100.08l34.75-34.75a58.64 58.64 0 0 1 98.56 28.11a12 12 0 1 1-23.37 5.44a34.65 34.65 0 0 0-58.22-16.58l-34.75 34.75A34.62 34.62 0 0 0 70.57 204a34.4 34.4 0 0 0 24.49-10.14l5.11-5.12a12 12 0 0 1 17.01 0M226.83 45.17a58.65 58.65 0 0 0-82.93 0l-5.11 5.11a12 12 0 0 0 17 17l5.12-5.12a34.63 34.63 0 1 1 49 49l-34.81 34.7A34.4 34.4 0 0 1 150.61 156a34.63 34.63 0 0 1-33.69-26.72a12 12 0 0 0-23.38 5.44A58.64 58.64 0 0 0 150.56 180h.05a58.28 58.28 0 0 0 41.47-17.17l34.75-34.75a58.62 58.62 0 0 0 0-82.91'/%3E%3C/svg%3E")}:where(.i-ph\:magnifying-glass-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M232.49 215.51L185 168a92.12 92.12 0 1 0-17 17l47.53 47.54a12 12 0 0 0 17-17ZM44 112a68 68 0 1 1 68 68a68.07 68.07 0 0 1-68-68'/%3E%3C/svg%3E")}:where(.i-ph\:monitor-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M208 36H48a28 28 0 0 0-28 28v112a28 28 0 0 0 28 28h160a28 28 0 0 0 28-28V64a28 28 0 0 0-28-28m4 140a4 4 0 0 1-4 4H48a4 4 0 0 1-4-4V64a4 4 0 0 1 4-4h160a4 4 0 0 1 4 4Zm-40 52a12 12 0 0 1-12 12H96a12 12 0 0 1 0-24h64a12 12 0 0 1 12 12'/%3E%3C/svg%3E")}:where(.i-ph\:moon-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M236.37 139.4a12 12 0 0 0-12-3A84.07 84.07 0 0 1 119.6 31.59a12 12 0 0 0-15-15a108.86 108.86 0 0 0-54.91 38.48A108 108 0 0 0 136 228a107.1 107.1 0 0 0 64.93-21.69a108.86 108.86 0 0 0 38.44-54.94a12 12 0 0 0-3-11.97m-49.88 47.74A84 84 0 0 1 68.86 69.51a84.9 84.9 0 0 1 23.41-21.22Q92 52.13 92 56a108.12 108.12 0 0 0 108 108q3.87 0 7.71-.27a84.8 84.8 0 0 1-21.22 23.41'/%3E%3C/svg%3E")}:where(.i-ph\:paragraph-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M208 36H96a68 68 0 0 0 0 136h36v36a12 12 0 0 0 24 0V60h16v148a12 12 0 0 0 24 0V60h12a12 12 0 0 0 0-24m-76 112H96a44 44 0 0 1 0-88h36Z'/%3E%3C/svg%3E")}:where(.i-ph\:rss-simple-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M228 192a12 12 0 0 1-24 0c0-77.2-62.8-140-140-140a12 12 0 0 1 0-24c90.43 0 164 73.57 164 164M64 100a12 12 0 0 0 0 24a68.07 68.07 0 0 1 68 68a12 12 0 0 0 24 0a92.1 92.1 0 0 0-92-92m4 72a16 16 0 1 0 16 16a16 16 0 0 0-16-16'/%3E%3C/svg%3E")}:where(.i-ph\:share-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='m232.49 112.49l-48 48a12 12 0 0 1-17-17L195 116h-30a84 84 0 0 0-81.36 63a12 12 0 1 1-23.24-6A107.94 107.94 0 0 1 165 92h30l-27.49-27.52a12 12 0 0 1 17-17l48 48a12 12 0 0 1-.02 17.01M192 204H44V88a12 12 0 0 0-24 0v128a12 12 0 0 0 12 12h160a12 12 0 0 0 0-24'/%3E%3C/svg%3E")}:where(.i-ph\:sidebar-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cg fill='black'%3E%3Cpath d='M88 48v160H40a8 8 0 0 1-8-8V56a8 8 0 0 1 8-8Z' opacity='.2'/%3E%3Cpath d='M216 40H40a16 16 0 0 0-16 16v144a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a16 16 0 0 0-16-16M40 152h16a8 8 0 0 0 0-16H40v-16h16a8 8 0 0 0 0-16H40V88h16a8 8 0 0 0 0-16H40V56h40v144H40Zm176 48H96V56h120z'/%3E%3C/g%3E%3C/svg%3E")}:where(.i-ph\:subway-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M228 96v112a12 12 0 0 1-24 0V96a52.06 52.06 0 0 0-52-52h-48a52.06 52.06 0 0 0-52 52v112a12 12 0 0 1-24 0V96a76.08 76.08 0 0 1 76-76h48a76.08 76.08 0 0 1 76 76m-40 0v72a28 28 0 0 1-18.89 26.47l2 5.07a12 12 0 0 1-6.68 15.6a11.9 11.9 0 0 1-4.43.86a12 12 0 0 1-11.14-7.54l-5-12.46h-31.74l-5 12.46A12 12 0 0 1 96 216a11.9 11.9 0 0 1-4.46-.86a12 12 0 0 1-6.68-15.6l2-5.07A28 28 0 0 1 68 168V96a28 28 0 0 1 28-28h64a28 28 0 0 1 28 28m-96 0v36h72V96a4 4 0 0 0-4-4H96a4 4 0 0 0-4 4m72 72v-12h-24v16h20a4 4 0 0 0 4-4m-48 4v-16H92v12a4 4 0 0 0 4 4Z'/%3E%3C/svg%3E")}:where(.i-ph\:sun-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M116 36V20a12 12 0 0 1 24 0v16a12 12 0 0 1-24 0m80 92a68 68 0 1 1-68-68a68.07 68.07 0 0 1 68 68m-24 0a44 44 0 1 0-44 44a44.05 44.05 0 0 0 44-44M51.51 68.49a12 12 0 1 0 17-17l-12-12a12 12 0 0 0-17 17Zm0 119l-12 12a12 12 0 0 0 17 17l12-12a12 12 0 1 0-17-17M196 72a12 12 0 0 0 8.49-3.51l12-12a12 12 0 0 0-17-17l-12 12A12 12 0 0 0 196 72m8.49 115.51a12 12 0 0 0-17 17l12 12a12 12 0 0 0 17-17ZM48 128a12 12 0 0 0-12-12H20a12 12 0 0 0 0 24h16a12 12 0 0 0 12-12m80 80a12 12 0 0 0-12 12v16a12 12 0 0 0 24 0v-16a12 12 0 0 0-12-12m108-92h-16a12 12 0 0 0 0 24h16a12 12 0 0 0 0-24'/%3E%3C/svg%3E")}:where(.i-ph\:swatches-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M242.79 149.32L223.7 97.11a20 20 0 0 0-25.58-11.91l-61.31 22.22l10.89-62.24A20 20 0 0 0 131.55 22l-54.68-9.69a19.94 19.94 0 0 0-23.11 16.24l-25 143.13a48 48 0 0 0 38.64 55.58a51 51 0 0 0 8.7.74H224a20 20 0 0 0 20-20v-51.81a21.7 21.7 0 0 0-1.21-6.87M99 184.18a23.84 23.84 0 0 1-9.86 15.56a23.28 23.28 0 0 1-17.56 3.89a24 24 0 0 1-19.23-27.82L76.71 36.66L123.37 45zm23.64 4.13l9.39-53.64l70.49-25.54l16.3 44.59l-96.23 34.87c.03-.09.06-.18.07-.28ZM220 204h-69.48L220 178.82ZM89.22 174.07l-1.4 8A12 12 0 0 1 76 192a12.4 12.4 0 0 1-2.08-.18a12 12 0 0 1-9.75-13.89l1.4-8a12 12 0 0 1 23.64 4.14Z'/%3E%3C/svg%3E")}:where(.i-ri\:creative-commons-line){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='M9 8c1.104 0 2.105.448 2.829 1.173l-1.414 1.413a2 2 0 1 0 0 2.828l1.413 1.414A4.001 4.001 0 0 1 5 12c0-2.208 1.792-4 4-4m9.829 1.173A4.001 4.001 0 0 0 12 12a4.001 4.001 0 0 0 6.828 2.828l-1.414-1.414a2 2 0 1 1 0-2.828zM2 12C2 6.477 6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12m10-8a8 8 0 1 0 0 16a8 8 0 0 0 0-16'/%3E%3C/svg%3E")}:where(.i-ri\:qq-line){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='m17.536 12.514l-.696-1.796c0-.021.01-.375.01-.558C16.85 7.088 15.447 4 12 4s-4.848 3.088-4.848 6.16c0 .183.009.537.01.557l-.696 1.797c-.19.515-.38 1.05-.517 1.51c-.657 2.189-.444 3.095-.282 3.115c.348.043 1.354-1.648 1.354-1.648c0 .98.487 2.258 1.542 3.18c-.394.127-.878.32-1.188.557c-.28.214-.245.431-.194.52c.22.385 3.79.245 4.82.125c1.03.12 4.599.26 4.82-.126c.05-.088.085-.305-.194-.519c-.311-.237-.795-.43-1.19-.556c1.055-.923 1.542-2.202 1.542-3.181c0 0 1.007 1.691 1.355 1.648c.162-.02.378-.928-.283-3.116a27 27 0 0 0-.516-1.509m1.021 8.227c-.373.652-.833.892-1.438 1.057a5 5 0 0 1-.794.138c-.44.045-.986.065-1.613.064a33 33 0 0 1-2.71-.116c-.692.065-1.785.114-2.71.116a16 16 0 0 1-1.614-.064a5 5 0 0 1-.793-.138c-.605-.164-1.065-.405-1.44-1.059a2.27 2.27 0 0 1-.239-1.652c-.592-.132-1.001-.482-1.279-.911a2.4 2.4 0 0 1-.309-.71a4 4 0 0 1-.116-1.106c.013-.785.187-1.762.532-2.912c.14-.466.327-1.008.567-1.655l.554-1.43l-.002-.203C5.153 5.605 7.589 2 12 2c4.413 0 6.848 3.605 6.848 8.16l-.001.203l.553 1.43l.01.026c.225.606.413 1.153.556 1.626c.348 1.15.522 2.128.535 2.916q.012.61-.118 1.108c-.066.246-.161.48-.31.708c-.276.427-.684.776-1.277.91c.13.554.055 1.14-.24 1.654'/%3E%3C/svg%3E")}:where(.i-simple-icons\:nuxtdotjs){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='M13.464 19.83h8.922c.283 0 .562-.073.807-.21a1.6 1.6 0 0 0 .591-.574a1.53 1.53 0 0 0 .216-.783a1.53 1.53 0 0 0-.217-.782L17.792 7.414a1.6 1.6 0 0 0-.591-.573a1.65 1.65 0 0 0-.807-.21c-.283 0-.562.073-.807.21a1.6 1.6 0 0 0-.59.573L13.463 9.99L10.47 4.953a1.6 1.6 0 0 0-.591-.573a1.65 1.65 0 0 0-.807-.21c-.284 0-.562.073-.807.21a1.6 1.6 0 0 0-.591.573L.216 17.481a1.53 1.53 0 0 0-.217.782c0 .275.074.545.216.783a1.6 1.6 0 0 0 .59.574c.246.137.525.21.808.21h5.6c2.22 0 3.856-.946 4.982-2.79l2.733-4.593l1.464-2.457l4.395 7.382h-5.859Zm-6.341-2.46l-3.908-.002l5.858-9.842l2.923 4.921l-1.957 3.29c-.748 1.196-1.597 1.632-2.916 1.632'/%3E%3C/svg%3E")}:where(.i-solar\:rewind-back-bold-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' fill-rule='evenodd' d='M22 6.426v11.148c0 1.847-1.6 3.015-2.903 2.118L13 15.232V8.768l6.097-4.46C20.399 3.411 22 4.58 22 6.426' clip-rule='evenodd' opacity='.5'/%3E%3Cpath fill='black' d='M13 7.123v9.754c0 1.616-1.467 2.638-2.661 1.853L2.92 13.853c-1.228-.807-1.228-2.899 0-3.706l7.42-4.877c1.193-.785 2.66.237 2.66 1.853'/%3E%3C/svg%3E")}:where(.i-solar\:rewind-forward-bold-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' fill-rule='evenodd' d='M2 6.426v11.148c0 1.847 1.6 3.015 2.903 2.118L11 15.232V8.768l-6.097-4.46C3.601 3.411 2 4.58 2 6.426' clip-rule='evenodd' opacity='.5'/%3E%3Cpath fill='black' d='M11 7.123v9.754c0 1.616 1.467 2.638 2.661 1.853l7.418-4.877c1.228-.807 1.228-2.899 0-3.706L13.66 5.27C12.467 4.485 11 5.507 11 7.123'/%3E%3C/svg%3E")}</style><link rel="preload" as="fetch" crossorigin="anonymous" href="/2025/lkhot100/_payload.json?42d9e1ea-82ef-4f58-a871-8d05a7412659"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DrtDzEft.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/jQdhZTEH.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DR1pY-pW.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CynKuEBQ.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DBMCc4Rq.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/B2CO-M2s.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/rJCbAzvX.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DxRn-wyQ.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/BpBpkyY5.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CNBUYbyu.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CogeDm5j.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DT9x559x.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/Bn-26gc8.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DEhIqN2q.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DRuWKRet.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/SLTiFf2K.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/OyYXSbqT.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/C1KxpfgX.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ujVNAKx7.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/U9u3eSb9.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/Bhk59Wr3.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ChrFluuA.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DN8SQizn.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/S8rEwdrW.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DzbFwEpR.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DN4vxSUC.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CJ6W8aET.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/B1kM-2Tz.js"><link rel="preload" as="fetch" fetchpriority="low" crossorigin="anonymous" href="/_nuxt/builds/meta/42d9e1ea-82ef-4f58-a871-8d05a7412659.json"><script src="https://lib.baomitu.com/twikoo/1.6.44/twikoo.min.js" defer></script><link rel="prefetch" as="style" crossorigin href="/_nuxt/Search.CGXRp4r1.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DvGUrK-K.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/DlGroup.DNv-X34Y.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Cmuwgckb.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/C2lTr802.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DMif9sG2.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/BlogTech.BKG_gLiK.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DD6A8v_H.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Chg9i9KU.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/GithubCard.DxCGmoqz.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/B0XRyzrU.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/CIF3D_B3.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/deGonkTA.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Jep7L2Wt.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DVMEJ2y_.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DHHWsMLB.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/Lightbox.CBHK7Kjn.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/CGDxQWC2.js"><link rel="icon" href="https://7.isyangs.cn/20250805/c77df6ed888acf748d49f457f1eb9d72.jpg"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="author" content="轻语, yzy11235@qq.com"><meta name="generator" content="QingYu-blog" data-github-repo="https://github.com/yingzya/yingzya.github.io" data-version="1.4.0"><meta name="mobile-web-app-capable" content="yes"><meta property="og:type" content="article"><script>((e,t)=>{let n=e.map(atob),r=atob(t),i=document.querySelector(`link[rel="canonical"]`);n.some(e=>location.hostname.endsWith(e))&&(i&&(i.href=i.href.replace(location.host,r)),location.host=r)})([`ZGdqbHguY29t`,`ZGd2aHF0LmNvbQ==`,`aGNtc2xhLmNvbQ==`,`d21sb3AuY29t`,`eXN3anhzLmNvbQ==`],`aHR0cHM6Ly9ibG9nLnlhbmd6eS50b3Av`);</script><meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><meta name="description" content="​​力扣Hot100​​热门算法题库的题解，涵盖了​哈希、双指针、滑动窗口、子串、普通数组、矩阵、链表、回溯、贪心算法、动态规划​​等核心算法与数据结构。"><script type="module" src="/_nuxt/DrtDzEft.js" crossorigin></script><meta name="twitter:card" content="summary_large_image"><meta property="og:title" data-infer="" content="力扣Hot100 | 字节追风者"><meta property="og:description" data-infer="" content="​​力扣Hot100​​热门算法题库的题解，涵盖了​哈希、双指针、滑动窗口、子串、普通数组、矩阵、链表、回溯、贪心算法、动态规划​​等核心算法与数据结构。"><link rel="canonical" href="https://blog.yangzy.top/2025/lkhot100"><meta property="og:url" content="https://blog.yangzy.top/2025/lkhot100"><meta property="og:locale" content="zh_CN"><meta property="og:site_name" content="字节追风者"><script id="unhead:payload" type="application/json">{"templateParams":{"separator":"|"},"titleTemplate":"%s %separator 字节追风者"}</script><script>"use strict";(()=>{const t=window,e=document.documentElement,c=["dark","light"],n=getStorageValue("localStorage","nuxt-color-mode")||"system";let i=n==="system"?u():n;const r=e.getAttribute("data-color-mode-forced");r&&(i=r),l(i),t["__NUXT_COLOR_MODE__"]={preference:n,value:i,getColorScheme:u,addColorScheme:l,removeColorScheme:d};function l(o){const s=""+o+"",a="";e.classList?e.classList.add(s):e.className+=" "+s,a&&e.setAttribute("data-"+a,o)}function d(o){const s=""+o+"",a="";e.classList?e.classList.remove(s):e.className=e.className.replace(new RegExp(s,"g"),""),a&&e.removeAttribute("data-"+a)}function f(o){return t.matchMedia("(prefers-color-scheme"+o+")")}function u(){if(t.matchMedia&&f("").media!=="not all"){for(const o of c)if(f(":"+o).matches)return o}return"light"}})();function getStorageValue(t,e){switch(t){case"localStorage":return window.localStorage.getItem(e);case"sessionStorage":return window.sessionStorage.getItem(e);case"cookie":return getCookie(e);default:return null}}function getCookie(t){const c=("; "+window.document.cookie).split("; "+t+"=");if(c.length===2)return c.pop()?.split(";").shift()}</script></head><body><div id="z-root"><!--[--><div class="nuxt-loading-indicator" style="position:fixed;top:0;right:0;left:0;pointer-events:none;width:auto;height:3px;opacity:0;background:repeating-linear-gradient(to right,#00dc82 0%,#34cdfe 50%,#0047e1 100%);background-size:0% auto;transform:scaleX(0%);transform-origin:left;transition:transform 0.1s, height 0.4s, opacity 0.4s;z-index:999999;"></div><a href="#main-content" class="skip-link gradient-card active" data-v-8fdfd33d> 跳转到主要内容 / Skip to content </a><!--[--><!----><aside id="z-sidebar" class="" data-v-781ebb1d><a href="/" class="zhilu-header sidebar-header" data-v-781ebb1d data-v-d727d25c><!--[--><div class="emoji-tail" data-v-d727d25c><!--[--><span class="split-char" style="--delay:-3s;" data-v-d727d25c>🔥</span><span class="split-char" style="--delay:-2.4s;" data-v-d727d25c>💨</span><span class="split-char" style="--delay:-1.8s;" data-v-d727d25c>🌟</span><span class="split-char" style="--delay:-1.2000000000000002s;" data-v-d727d25c>⚡</span><span class="split-char" style="--delay:-0.6000000000000001s;" data-v-d727d25c>🚀</span><!--]--></div><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" alt="字节追风者" data-nuxt-img srcset="https://7.isyangs.cn/20250730/c65a56b5206f765b8a30203c71be985e.jpg 1x, https://7.isyangs.cn/20250730/c65a56b5206f765b8a30203c71be985e.jpg 2x" class="zhilu-logo circle" src="https://7.isyangs.cn/20250730/c65a56b5206f765b8a30203c71be985e.jpg" data-v-d727d25c><div class="zhilu-text" data-v-d727d25c><div class="header-title" data-v-d727d25c><!--[--><span class="split-char" style="--delay:0.1s;" data-v-d727d25c>字</span><span class="split-char" style="--delay:0.2s;" data-v-d727d25c>节</span><span class="split-char" style="--delay:0.30000000000000004s;" data-v-d727d25c>追</span><span class="split-char" style="--delay:0.4s;" data-v-d727d25c>风</span><span class="split-char" style="--delay:0.5s;" data-v-d727d25c>者</span><!--]--></div><div class="header-subtitle" data-v-d727d25c>博客爱好者</div></div><!--]--></a><nav class="sidebar-nav scrollcheck-y" data-v-781ebb1d><div class="search-btn sidebar-nav-item gradient-card" data-v-781ebb1d><span class="iconify i-ph:magnifying-glass-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>搜索</span><span class="keycut" data-v-781ebb1d data-v-6a540ef3></span></div><!--[--><!--[--><!----><menu data-v-781ebb1d><!--[--><li data-v-781ebb1d><a href="/" class="sidebar-nav-item" data-v-781ebb1d><!--[--><span class="iconify i-ph:files-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>文章</span><!----><!--]--></a></li><li data-v-781ebb1d><a href="/link" class="sidebar-nav-item" data-v-781ebb1d><!--[--><span class="iconify i-ph:link-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>友链</span><!----><!--]--></a></li><li data-v-781ebb1d><a href="/archive" class="sidebar-nav-item" data-v-781ebb1d><!--[--><span class="iconify i-ph:archive-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>归档</span><!----><!--]--></a></li><!--]--></menu><!--]--><!--]--></nav><footer class="sidebar-footer" data-v-781ebb1d><div class="theme-toggle" data-v-781ebb1d data-v-e7a12ec1><!--[--><button aria-label="浅色模式" class="" data-v-e7a12ec1><span class="iconify i-ph:sun-bold" aria-hidden="true" style="" data-v-e7a12ec1></span></button><button aria-label="跟随系统" class="active" data-v-e7a12ec1><span class="iconify i-ph:monitor-bold" aria-hidden="true" style="" data-v-e7a12ec1></span></button><button aria-label="深色模式" class="" data-v-e7a12ec1><span class="iconify i-ph:moon-bold" aria-hidden="true" style="" data-v-e7a12ec1></span></button><!--]--></div><menu data-v-781ebb1d data-v-915035bb><!--[--><a href="https://yangzy.top/" rel="noopener noreferrer" target="_blank" aria-label="个人主页" data-v-915035bb><!--[--><span class="iconify i-ph:house-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="https://jq.qq.com/?_wv=1027&amp;k=lQfNSeEd" rel="noopener noreferrer" target="_blank" aria-label="交流群: 169994096" data-v-915035bb><!--[--><span class="iconify i-ri:qq-line" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="https://github.com/yingzya" rel="noopener noreferrer" target="_blank" aria-label="GitHub: yingzya" data-v-915035bb><!--[--><span class="iconify i-ph:github-logo-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="/atom.xml" rel="noopener noreferrer" target="_blank" aria-label="Atom订阅" data-v-915035bb><!--[--><span class="iconify i-ph:rss-simple-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="https://www.travellings.cn/go-by-clouds.html" rel="noopener noreferrer" target="_blank" aria-label="开往" data-v-915035bb><!--[--><span class="iconify i-ph:subway-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><!--]--></menu></footer></aside><!--]--><div id="content"><main id="main-content"><!--[--><div class="post-header" data-v-d1ca4385><!----><div class="post-nav" data-v-d1ca4385><div class="operations" data-v-d1ca4385><button class="button" data-v-d1ca4385 data-v-32e6a543><div class="button-main" data-v-32e6a543><span class="iconify i-ph:share-bold" aria-hidden="true" style="" data-v-32e6a543></span><!--[--> 文字分享 <!--]--></div><!----></button></div><div class="post-info" data-v-d1ca4385><time datetime="2025-08-22T10:15:04.000Z" data-v-d1ca4385><span class="iconify i-ph:calendar-dots-bold" aria-hidden="true" style="" data-v-d1ca4385></span> 8月22日</time><!----><span data-v-d1ca4385><span class="iconify i-ph:code-bold" aria-hidden="true" style="" data-v-d1ca4385></span> 算法</span><span data-v-d1ca4385><span class="iconify i-ph:paragraph-bold" aria-hidden="true" style="" data-v-d1ca4385></span> 7025 字 </span></div></div><h1 class="text-tech post-title" data-v-d1ca4385>力扣Hot100</h1></div><div class="md-excerpt gradient-card" data-v-186a6ec2><span class="iconify i-ph:highlighter-bold" aria-hidden="true" style="" data-v-186a6ec2></span></div><article class="article md-tech"><h2 id="哈希"><a href="#哈希"><!--[-->哈希<!--]--></a></h2><h3 id="两数之和"><a href="#两数之和"><!--[--><a href="https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->两数之和<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->有点困扰可能就是数据的返回形式，在 C++11 之后，C++支持列表初始化(list initialization)，也叫 <strong><!--[-->统一初始化<!--]--></strong>。<!--]--></p><p><!--[-->C++ 会自动根据函数的返回类型（这里是 <code data-v-cdb8f38f><!--[-->vector&lt;int&gt;<!--]--></code>）把 <code data-v-cdb8f38f><!--[-->{i, j}<!--]--></code> 当作构造这个 <code data-v-cdb8f38f><!--[-->vector<!--]--></code> 的初始化列表。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        for(int i = 0; i &lt; nums.size();i++)
        {
            for(int j = i + 1; j &lt; nums.size();j++)
            {
                if(nums[i] + nums[j] == target)
                return {i,j};
            }
        }
        return {};
    }
};
</pre><!----></figure><h3 id="字母异位词分组"><a href="#字母异位词分组"><!--[--><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->字母异位词分组<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->思路就是将<strong><!--[-->排序后的字符串<!--]--></strong>作为<strong><!--[-->分类依据<!--]--></strong>，因为异位词的话，排序得到的结果是<strong><!--[-->一样<!--]--></strong>的。<!--]--></p><p><!--[-->通过创建unordered_map，即<strong><!--[-->键值对（key-value)<!--]--></strong> 的集合。<!--]--></p><p><!--[--><strong><!--[--><code data-v-cdb8f38f><!--[-->map<!--]--></code> = 有序(按key自动从小到大排序) + 红黑树<!--]--></strong>，<strong><!--[--><code data-v-cdb8f38f><!--[-->unordered_map<!--]--></code> = 无序 + 哈希表 + 快<!--]--></strong><!--]--></p><p><!--[--><strong><!--[-->key 唯一<!--]--></strong>，每个 key 对应一个 value。<!--]--></p><p><!--[--><strong><!--[-->查找、插入、删除<!--]--></strong>的平均时间复杂度都是 <strong><!--[-->O(1)<!--]--></strong>。<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->unordered_map&lt;string, vector&lt;string&gt;&gt; mp<!--]--></code> 具体含义:<!--]--></p><ul><!--[--><li><!--[--><code data-v-cdb8f38f><!--[-->mp<!--]--></code> 是一个哈希表。<!--]--></li><li><!--[--><strong><!--[-->key 类型<!--]--></strong>是 <code data-v-cdb8f38f><!--[-->string<!--]--></code>，也就是说你可以通过字符串去查找。<!--]--></li><li><!--[--><strong><!--[-->value 类型<!--]--></strong>是 <code data-v-cdb8f38f><!--[-->vector&lt;string&gt;<!--]--></code>，也就是 key 对应的是一个字符串数组<!--]--></li><!--]--></ul><p><!--[-->然后就是<code data-v-cdb8f38f><!--[-->emplace_back<!--]--></code>，它是<code data-v-cdb8f38f><!--[-->vector<!--]--></code>、<code data-v-cdb8f38f><!--[-->deque<!--]--></code>、<code data-v-cdb8f38f><!--[-->list<!--]--></code>等容器的方法，用来在<strong><!--[-->容器末尾直接构造元素<!--]--></strong><!--]--></p><p><!--[-->它和<code data-v-cdb8f38f><!--[-->push_back()<!--]--></code>的区别在于:<!--]--></p><p><!--[--><strong><!--[--><code data-v-cdb8f38f><!--[-->push_back<!--]--></code><!--]--></strong>：把一个已存在的对象 <strong><!--[-->拷贝或移动<!--]--></strong> 到容器末尾<!--]--></p><p><!--[--><strong><!--[--><code data-v-cdb8f38f><!--[-->emplace_back<!--]--></code><!--]--></strong>：<strong><!--[-->直接构造<!--]--></strong>对象在容器末尾，无需临时对象<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {
        unordered_map&lt;string,vector&lt;string&gt;&gt; mp;    
        for(auto i : strs)
        {
            string key = i;
            sort(key.begin(),key.end());
            mp[key].emplace_back(i);
        }
        vector&lt;vector&lt;string&gt;&gt; ans;
        for(auto it = mp.begin(); it != mp.end();it++)
        {
            ans.emplace_back(it-&gt;second);
        }
        return ans;
    }
};
</pre><!----></figure><h3 id="最长连续序列set"><a href="#最长连续序列set"><!--[--><a href="https://leetcode.cn/problems/longest-consecutive-sequence/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->最长连续序列(set)<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->很容易想到这道题就是排序，但是题目要求是时间复杂度为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>的时间复杂度。<!--]--></p><p><!--[-->用到了set结构。set是自动排序(自动升序)。但是用到了一个<strong><!--[-->count<!--]--></strong>函数来模拟排序，因此用<code data-v-cdb8f38f><!--[-->unordered_set<!--]--></code>，其不会自动排序，但是查找更快。<!--]--></p><p><!--[--><strong><!--[--><code data-v-cdb8f38f><!--[-->set<!--]--></code><!--]--></strong>：有序、<strong><!--[-->不重复<!--]--></strong>，适合需要排序的场景。<!--]--></p><p><!--[--><strong><!--[--><code data-v-cdb8f38f><!--[-->unordered_set<!--]--></code><!--]--></strong>：无序、<strong><!--[-->不重复<!--]--></strong>，查找速度更快，适合只关心存在性而不关心顺序的场景。<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->set<!--]--></code>的<strong><!--[-->常用函数<!--]--></strong>如下:<!--]--></p><div class="md-table" data-v-c54062c4><div class="operations" data-v-c54062c4><button class="button" data-v-c54062c4 data-v-32e6a543><div class="button-main" data-v-32e6a543><!----><!--[--><span class="iconify i-ph:arrow-u-down-left-bold" aria-hidden="true" style="" data-v-c54062c4></span><span class="tooltip" data-v-c54062c4>自动换行</span><!--]--></div><!----></button></div><table class="scroll scrollcheck-x" data-v-c54062c4><!--[--><thead><!--[--><tr><!--[--><th><!--[-->函数<!--]--></th><th><!--[-->作用<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->insert(x)<!--]--></code><!--]--></td><td><!--[-->插入元素<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->erase(x)<!--]--></code><!--]--></td><td><!--[-->删除元素（值/迭代器）<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->find(x)<!--]--></code><!--]--></td><td><!--[-->查找元素，返回迭代器<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->count(x)<!--]--></code><!--]--></td><td><!--[-->判断元素是否存在（返回 0 或 1）<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->begin() / end()<!--]--></code><!--]--></td><td><!--[-->迭代器遍历（升序）<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->rbegin() / rend()<!--]--></code><!--]--></td><td><!--[-->迭代器遍历（降序）<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->size()<!--]--></code><!--]--></td><td><!--[-->集合大小<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->empty()<!--]--></code><!--]--></td><td><!--[-->是否为空<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->clear()<!--]--></code><!--]--></td><td><!--[-->清空集合<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->lower_bound(x)<!--]--></code><!--]--></td><td><!--[-->返回 ≥ x 的第一个迭代器<!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->upper_bound(x)<!--]--></code><!--]--></td><td><!--[-->返回 &gt; x 的第一个迭代器<!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table></div><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int longestConsecutive(vector&lt;int&gt;&amp; nums) {
        unordered_set&lt;int&gt; sets;
        for(auto i : nums) sets.insert(i);

        int ans = 0;
        for(auto i : sets)
        {
            if(!sets.count(i-1))//是连续序列的起点
            {
                int curNum = i;
                int curAns = 1;
                while(sets.count(curNum + 1))//查找后面的元素
                {
                    curNum ++;
                    curAns ++;
                }
                ans = max(ans,curAns);
            }
        }
        return ans;
    }
};
</pre><!----></figure><h2 id="双指针"><a href="#双指针"><!--[-->双指针<!--]--></a></h2><h3 id="移动零"><a href="#移动零"><!--[--><a href="https://leetcode.cn/problems/move-zeroes/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->移动零<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->题目要求，必须在<strong><!--[-->不复制数组<!--]--></strong>的情况下原地对数组进行操作<!--]--></p><p><!--[-->思路是这样，<strong><!--[-->右指针<!--]--></strong>每次<strong><!--[-->不是0<!--]--></strong>就和左指针所指元素交换，每次交换后两指针++，不然只有右指针++<!--]--></p><p><!--[-->因为要把0一到数组的最后，因此要移动的数应该是右指针不为0<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int left = 0,right = 0;
        int n = nums.size();
        while(right &lt; n)
        {
            if(nums[right] )
            {
                swap(nums[left],nums[right]);
                left++;
            }
            right++;
        }
    }
};
</pre><!----></figure><h3 id="盛最多水的容器"><a href="#盛最多水的容器"><!--[--><a href="https://leetcode.cn/problems/container-with-most-water/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->盛最多水的容器<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>[1, 8, 6, 2, 5, 4, 8, 3, 7]
 ^                       ^
</pre><!----></figure><p><!--[-->在初始时，左右指针分别指向数组的左右两端，它们可以容纳的水量为 min(1,7)∗8=8。<!--]--></p><p><!--[-->此时我们需要移动一个指针。移动哪一个呢？直觉告诉我们，应该移动对应数字较小的那个指针（即此时的左指针）。这是因为，由于容纳的水量是由两个指针指向的数字中<strong><!--[-->较小值<!--]--></strong>∗<strong><!--[-->指针之间的距离<!--]--></strong><!--]--></p><p><!--[-->如果我们移动数字较大的那个指针，那么前者「两个指针指向的数字中较小值」不会增加，后者「指针之间的距离」会减小，那么这个乘积会减小。因此，我们移动数字较大的那个指针是不合理的。因此，我们移动数字<strong><!--[-->较小<!--]--></strong>的那个指针。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int maxArea(vector&lt;int&gt;&amp; height) {
        int l = 0,r = height.size() - 1;
        int ans = 0;
        while(l &lt; r){
            int area = min(height[l],height[r]) * (r - l);
            ans = max(ans,area);
            if(height[l] &lt; height[r]) l++;
            else r--;
        }
        return ans;
    }
};
</pre><!----></figure><h3 id="三数之和"><a href="#三数之和"><!--[--><a href="https://leetcode.cn/problems/3sum/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->三数之和<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->我们枚举的三元组<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b,c) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span> 满足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>≤</mo><mi>b</mi><mo>≤</mo><mi>c</mi></mrow><annotation encoding="application/x-tex">a≤b≤c</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord mathnormal">b</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">c</span></span></span></span>，保证了只有<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(a,b,c) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>  这个顺序会被枚举到，而 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo separator="true">,</mo><mi>c</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(b,a,c)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">c</span><span class="mclose">)</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>c</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(c,b,a)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">a</span><span class="mclose">)</span></span></span></span> 等等这些不会，这样就减少了重复。<!--]--></p><p><!--[-->先对数组进行排序，方便去重，并使用双指针。固定一个数 <code data-v-cdb8f38f><!--[-->nums[i]<!--]--></code>，问题就变成：
<strong><!--[-->在 <code data-v-cdb8f38f><!--[-->i<!--]--></code> 后面的数组里，找两个数 <code data-v-cdb8f38f><!--[-->nums[j]<!--]--></code> 和 <code data-v-cdb8f38f><!--[-->nums[k]<!--]--></code>，使得 <code data-v-cdb8f38f><!--[-->nums[j] + nums[k] = -nums[i]<!--]--></code>。<!--]--></strong>
注意去重，避免结果重复<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; ans;

        //枚举a
        for(int i = 0; i &lt; n; i ++)
        {
            //不是第一个可选元素时才跳过，因为第一个可能构成合法组合
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue;
            int k = n - 1;
            int target = -nums[i];
            //枚举b
            for(int j = i + 1; j &lt; n;j++){
                if(j &gt; i + 1 &amp;&amp; nums[j] == nums[j-1]) continue;
                while(j &lt; k &amp;&amp; nums[j] + nums[k] &gt; target) k--;

                if(j == k) break;//指针相遇，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b&lt;c 的 c 了，可以退出循环
                if(nums[j] + nums[k] == target)
                    ans.push_back({nums[i],nums[j],nums[k]});
            }
        }
        return ans;
    }
};
</pre><!----></figure><h3 id="接雨水"><a href="#接雨水"><!--[--><a href="https://leetcode.cn/problems/trapping-rain-water/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->接雨水<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->这道题用<strong><!--[-->动态规划<!--]--></strong>做比较好理解<!--]--></p><p><!--[-->创建两个长度为 n 的数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">leftMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">rightMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>。对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0≤i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftMax[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 及其左边的位置中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span> 的最大高度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightMax[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示下标 i 及其右边的位置中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">height </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>的最大高度。<!--]--></p><p><!--[-->显然，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">leftMax[0]=height[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">rightMax[n−1]=height[n−1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>。两个数组的其余元素的计算如下：<!--]--></p><p><!--[-->当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1≤i≤n−1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">leftMax[i]=max(leftMax[i−1],height[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span>；<!--]--></p><p><!--[-->当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">0≤i≤n−2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">rightMax[i]=max(rightMax[i+1],height[i])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span></span></span></span>。<!--]--></p><p><!--[-->因此可以正向遍历数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">height</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span> 得到数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">leftMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> 的每个元素值，反向遍历数组 height 得到数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">rightMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> 的每个元素值。<!--]--></p><p><!--[-->在得到数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">leftMax </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">rightMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span> 的每个元素值之后，对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0≤i&lt;n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7804em;vertical-align:-0.136em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6986em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span>，下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>处能接的雨水量等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo><mo>−</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">min(leftMax[i],rightMax[i])−height[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">])</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">e</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>。遍历每个下标位置即可得到能接的雨水总量。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int n = height.size();
        if(n == 0) return 0;

        vector&lt;int&gt; leftMax(n);
        //leftMax[i]表示下标i及其左边的位置中，height的最大高度
        leftMax[0] = height[0];
        for(int i = 1; i &lt; n; i ++) leftMax[i] = max(leftMax[i-1],height[i]);

        vector&lt;int&gt; rightMax(n);
        rightMax[n-1] = height[n-1];
        for(int i = n - 2; i &gt;= 0; i --) rightMax[i] = max(rightMax[i+1],height[i]);

        int ans = 0;
        for(int i = 0; i &lt; n; i ++)
            ans += min(leftMax[i],rightMax[i]) - height[i];

        return ans;
    }
};
</pre><!----></figure><p><!--[--><strong><!--[-->双指针<!--]--></strong>的做法<!--]--></p><p><!--[-->注意到下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 处能接的雨水量由 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{leftMax}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{rightMax}[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 中的最小值决定。由于数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext></mrow><annotation encoding="application/x-tex">\textit{leftMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span></span></span></span> 是从左往右计算，数组 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext></mrow><annotation encoding="application/x-tex">\textit{rightMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span></span></span></span> 是从右往左计算，因此可以使用双指针和两个变量代替两个数组。<!--]--></p><p><!--[-->维护两个指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">left</mtext></mrow><annotation encoding="application/x-tex">\textit{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">left</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">right</mtext></mrow><annotation encoding="application/x-tex">\textit{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">right</span></span></span></span></span>，以及两个变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext></mrow><annotation encoding="application/x-tex">\textit{leftMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext></mrow><annotation encoding="application/x-tex">\textit{rightMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span></span></span></span>，初始时 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">left</mtext><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\textit{left} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">left</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">right</mtext><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\textit{right} = n - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">right</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\textit{leftMax} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\textit{rightMax} = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">left</mtext></mrow><annotation encoding="application/x-tex">\textit{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">left</span></span></span></span></span> 只会向右移动，指针 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">right</mtext></mrow><annotation encoding="application/x-tex">\textit{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">right</span></span></span></span></span> 只会向左移动，在移动指针的过程中维护两个变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext></mrow><annotation encoding="application/x-tex">\textit{leftMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext></mrow><annotation encoding="application/x-tex">\textit{rightMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span></span></span></span> 的值。<!--]--></p><p><!--[-->当两个指针没有相遇时，进行如下操作：<!--]--></p><ul><!--[--><li><!--[-->使用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">left</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{height}[\textit{left}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">left</span></span><span class="mclose">]</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">right</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{height}[\textit{right}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">right</span></span><span class="mclose">]</span></span></span></span> 的值更新 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext></mrow><annotation encoding="application/x-tex">\textit{leftMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext></mrow><annotation encoding="application/x-tex">\textit{rightMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span></span></span></span> 的值；<!--]--></li><li><!--[-->如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">left</mtext><mo stretchy="false">]</mo><mo>&lt;</mo><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">right</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{height}[\textit{left}] &lt; \textit{height}[\textit{right}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">left</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">right</span></span><span class="mclose">]</span></span></span></span>，则必有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext><mo>&lt;</mo><mtext mathvariant="italic">rightMax</mtext></mrow><annotation encoding="application/x-tex">\textit{leftMax} &lt; \textit{rightMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.0391em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span></span></span></span>，下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">left</mtext></mrow><annotation encoding="application/x-tex">\textit{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">left</span></span></span></span></span> 处能接的雨水量等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext><mo>−</mo><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">left</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{leftMax} - \textit{height}[\textit{left}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">left</span></span><span class="mclose">]</span></span></span></span>，将下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">left</mtext></mrow><annotation encoding="application/x-tex">\textit{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">left</span></span></span></span></span> 处能接的雨水量加到能接的雨水总量，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">left</mtext></mrow><annotation encoding="application/x-tex">\textit{left}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord textit">left</span></span></span></span></span> 加 1（即向右移动一位）；<!--]--></li><li><!--[-->如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">left</mtext><mo stretchy="false">]</mo><mo>≥</mo><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">right</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{height}[\textit{left}] \geq \textit{height}[\textit{right}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">left</span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">right</span></span><span class="mclose">]</span></span></span></span>，则必有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">leftMax</mtext><mo>≥</mo><mtext mathvariant="italic">rightMax</mtext></mrow><annotation encoding="application/x-tex">\textit{leftMax} \geq \textit{rightMax}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8304em;vertical-align:-0.136em;"></span><span class="mord text"><span class="mord textit">leftMax</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span></span></span></span>，下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">right</mtext></mrow><annotation encoding="application/x-tex">\textit{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">right</span></span></span></span></span> 处能接的雨水量等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">rightMax</mtext><mo>−</mo><mtext mathvariant="italic">height</mtext><mo stretchy="false">[</mo><mtext mathvariant="italic">right</mtext><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">\textit{rightMax} - \textit{height}[\textit{right}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">rightMax</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textit">height</span></span><span class="mopen">[</span><span class="mord text"><span class="mord textit">right</span></span><span class="mclose">]</span></span></span></span>，将下标 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">right</mtext></mrow><annotation encoding="application/x-tex">\textit{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">right</span></span></span></span></span> 处能接的雨水量加到能接的雨水总量，然后将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="italic">right</mtext></mrow><annotation encoding="application/x-tex">\textit{right}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord textit">right</span></span></span></span></span> 减 1（即向左移动一位）。<!--]--></li><!--]--></ul><p><!--[-->当两个指针相遇时，即可得到能接的雨水总量<!--]--></p><p><!--[-->就是每次判断在<strong><!--[-->两个<!--]--></strong>柱子中，<strong><!--[-->选择哪个柱子<!--]--></strong>接水。思路还是和动态规划一样，每次选择柱子两侧最大值的<strong><!--[-->最低点<!--]--></strong>来算。正如第一种情况的话，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mtext>、</mtext><mi>j</mi></mrow><annotation encoding="application/x-tex">i、j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">i</span><span class="mord cjk_fallback">、</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>两个柱子的话，因为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">left</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">t</span></span></span></span>比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">right</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span></span></span></span>小了，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">rightMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>一定会比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">leftMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>大，又因为左边柱子的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">leftMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>一定会比右边柱子的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">rightMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>大，所以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">min</span></span></span></span>的值就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mi>M</mi><mi>a</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">leftMax</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.10903em;">tM</span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span></span></span></span>，这里<strong><!--[-->省略<!--]--></strong>掉了只是。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int trap(vector&lt;int&gt;&amp; height) {
        int ans = 0;
        int left = 0,right = height.size() - 1;
        int leftMax = 0,rightMax = 0;
        while(left &lt; right){
            //leftMax表示下标left及其左边的位置中，height的最大高度
            leftMax=  max(leftMax,height[left]);
            //rightMax表示下标right及其右边的位置中，height的最大高度
            rightMax = max(rightMax,height[right]);

            if(height[left] &lt; height[right]){
                //leftMax &lt; rightMax 
                ans += leftMax - height[left];
                left++;
            }
            else
            {
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
};
</pre><!----></figure><h2 id="滑动窗口"><a href="#滑动窗口"><!--[-->滑动窗口<!--]--></a></h2><h3 id="无重复字符的最长子串"><a href="#无重复字符的最长子串"><!--[--><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->无重复字符的最长子串<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set&lt;char&gt; occ;//哈希集合，记录当前窗口有哪些字符
        int n = s.size();
        //右指针初始为-1
        int rk = -1,ans = 0;
        //枚举左指针的位置
        for(int i = 0; i &lt; n;i++)
        {
            if(i != 0) occ.erase(s[i-1]);
            while(rk + 1 &lt; n &amp;&amp; !occ.count(s[rk+1])){
                //不断移动右指针
                occ.insert(s[rk+1]);
                rk++;
            }
            ans = max(ans,rk - i + 1);//每次计算不重复的长度
        }
        return ans;
    }
};
</pre><!----></figure><h3 id="找到字符串中所有字母异位词"><a href="#找到字符串中所有字母异位词"><!--[--><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->找到字符串中所有字母异位词<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;int&gt; findAnagrams(string s, string p) {
        int slen = s.size(),plen = p.size();

        if(slen &lt; plen) return vector&lt;int&gt;();

        vector&lt;int&gt; ans;
        vector&lt;int&gt; sCount(26);
        vector&lt;int&gt; pCount(26);

        //先初始化前plen个字符的频次
        for(int i = 0; i &lt; plen;i++)
        {
          sCount[s[i]-&#039;a&#039;]++;
          pCount[p[i]-&#039;a&#039;]++;
        }
        //s与p完全相同
        if(sCount == pCount) ans.emplace_back(0);

        for(int i = 0; i &lt; slen - plen;i++)
        {
            sCount[s[i]-&#039;a&#039;]--;//移出窗口左端
            sCount[s[i+plen]-&#039;a&#039;]++;//窗口右端进入
            if(sCount == pCount) ans.emplace_back(i+1);
        }
        return ans;
    }
};
</pre><!----></figure><h2 id="子串"><a href="#子串"><!--[-->子串<!--]--></a></h2><h3 id="和为-k-的子数组map"><a href="#和为-k-的子数组map"><!--[--><a href="https://leetcode.cn/problems/subarray-sum-equals-k/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->和为 K 的子数组(map)<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->为什么先放<strong><!--[-->mp<span>0</span> = 1<!--]--></strong>？表示“在任何数之前”有一个“前缀和为 0” 的情况。这样如果一开始累计到的前缀和本身就等于 k（即 pre == k），那么 pre - k == 0，就能正确计数到这个从 0 开始的子数组。<!--]--></p><p><!--[--><strong><!--[-->类比<!--]--></strong>:你在走路（遍历数组），手里累加步数（前缀和 pre）。你想知道有没有一段路程长度为 k。只要你当前的总步数 pre 与过去某次的总步数 old 之差是 k，即 old = pre - k，就说明那段之间的路长是 k。于是你每走一步就问：之前有多少次总步数等于 pre - k？有几次就有几个合法子数组。<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->unordered_map&lt;K, V&gt;<!--]--></code>：键值对容器，<strong><!--[-->键<!--]--></strong>是 <code data-v-cdb8f38f><!--[-->K<!--]--></code> 类型，<strong><!--[-->值<!--]--></strong>是 <code data-v-cdb8f38f><!--[-->V<!--]--></code> 类型<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->mp.find(key)<!--]--></code>：在 <code data-v-cdb8f38f><!--[-->unordered_map<!--]--></code> 里查找是否存在键为 <code data-v-cdb8f38f><!--[-->key<!--]--></code> 的元素。<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->如果存在<!--]--></strong>：返回指向该元素的迭代器（不是值）<!--]--></li><li><!--[--><strong><!--[-->如果不存在<!--]--></strong>：返回 <code data-v-cdb8f38f><!--[-->mp.end()<!--]--></code>（尾后迭代器）<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->key<!--]--></code><strong><!--[-->唯一<!--]--></strong><!--]--></li><!--]--></ul><p><!--[--><code data-v-cdb8f38f><!--[-->map<!--]--></code>与<code data-v-cdb8f38f><!--[-->unordered_map<!--]--></code>的<strong><!--[-->区别<!--]--></strong>：<!--]--></p><ol><!--[--><li><!--[-->底层结构<br>map：平衡二叉搜索树（C++ 标准里通常是红黑树）<br>unordered_map：哈希表（数组 + 链表/桶，或拉链法，具体实现取决于库）<!--]--></li><li><!--[-->键的顺序<br>map：迭代时按 key 从小到大有序<br>unordered_map：无序（遍历顺序和插入、rehash 等相关，不可依赖）<!--]--></li><!--]--></ol><p><!--[--><code data-v-cdb8f38f><!--[-->mp[pre]<!--]--></code><!--]--></p><p><!--[-->当你用 <strong><!--[-->下标运算符 <code data-v-cdb8f38f><!--[-->[]<!--]--></code><!--]--></strong> 访问一个键 <code data-v-cdb8f38f><!--[-->pre<!--]--></code> 时：<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->如果这个键存在<!--]--></strong>，就返回它对应的 <code data-v-cdb8f38f><!--[-->value<!--]--></code> 的引用。<!--]--></li><li><!--[--><strong><!--[-->如果这个键不存在<!--]--></strong>，就会 <strong><!--[-->自动插入<!--]--></strong> 一个新的键值对：<!--]--></li><!--]--></ul><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int subarraySum(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int,int&gt; mp;
        //mp[sum]=cnt表示前缀和为sum的情况出现过cnt次
        mp[0] = 1;
        int count = 0,pre = 0;
        for(auto &amp;x : nums)
        {
            pre += x;
            if(mp.find(pre-k) != mp.end()) count += mp[pre-k];
            mp[pre]++;
        }
        return count;
    }
};
</pre><!----></figure><h3 id="滑动窗口最大值"><a href="#滑动窗口最大值"><!--[--><a href="https://leetcode.cn/problems/sliding-window-maximum/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->滑动窗口最大值<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->队列的性质是<strong><!--[-->先进先出<!--]--></strong><!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->deque<!--]--></code>（双端队列）<!--]--></p><ul><!--[--><li><!--[-->全称 <strong><!--[-->double-ended queue<!--]--></strong>，存储结构是一个 <strong><!--[-->动态数组块链表<!--]--></strong>（不是连续的大数组，扩展时比 <code data-v-cdb8f38f><!--[-->vector<!--]--></code> 高效）。<!--]--></li><li><!--[-->特点：<ul><!--[--><li><!--[--><strong><!--[-->两端都能高效插入和删除<!--]--></strong>（<code data-v-cdb8f38f><!--[-->push_front<!--]--></code> / <code data-v-cdb8f38f><!--[-->pop_front<!--]--></code> / <code data-v-cdb8f38f><!--[-->push_back<!--]--></code> / <code data-v-cdb8f38f><!--[-->pop_back<!--]--></code>）。<!--]--></li><li><!--[-->随机访问（<code data-v-cdb8f38f><!--[-->[]<!--]--></code> 运算符）和迭代器可用，类似 <code data-v-cdb8f38f><!--[-->vector<!--]--></code>。<!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><p><!--[--><code data-v-cdb8f38f><!--[-->queue<!--]--></code>（队列）<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->容器适配器<!--]--></strong>，默认基于 <code data-v-cdb8f38f><!--[-->deque<!--]--></code> 实现。<!--]--></li><li><!--[-->特点：
<strong><!--[-->只能从一端进，另一端出<!--]--></strong>（FIFO，先进先出）。
接口比 <code data-v-cdb8f38f><!--[-->deque<!--]--></code> 少很多，只允许：<code data-v-cdb8f38f><!--[-->push()<!--]--></code>：入队（尾部），<code data-v-cdb8f38f><!--[-->pop()<!--]--></code>：出队（头部），<code data-v-cdb8f38f><!--[-->front()<!--]--></code>：访问队头，<code data-v-cdb8f38f><!--[-->back()<!--]--></code>：访问队尾<!--]--></li><li><!--[-->不能随便访问中间元素。<!--]--></li><!--]--></ul><p><!--[-->我们用 <strong><!--[-->双端队列 <code data-v-cdb8f38f><!--[-->deque<!--]--></code> 保存索引<!--]--></strong>，保证：<!--]--></p><ol><!--[--><li><!--[-->队头 <code data-v-cdb8f38f><!--[-->q.front()<!--]--></code> 总是窗口的最大值索引。<!--]--></li><li><!--[-->队列从前到后递减（对应 <code data-v-cdb8f38f><!--[-->nums<!--]--></code> 的值递减）。<!--]--></li><!--]--></ol><p><!--[-->维护一个<strong><!--[-->单调递减<!--]--></strong>的队列，元素是<strong><!--[-->下标<!--]--></strong>，队首是窗口里最大元素的下标，遍历数组，首先判断最大元素是否还在窗口里，然后将队列里小于当前新加入元素的老元素去掉（因为只要新元素在窗口，在老元素右边，它们就不可能是滑动窗口的最大值），然后加入这个新元素，遍历时记录队首的最大值即可。<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->nums[q[0]] &gt;= nums[q[1]] &gt;= nums[q[2]] ...<!--]--></code>，队列中只存<strong><!--[-->当前<!--]--></strong>窗口范围内的下标。<!--]--></p><p><!--[-->如何维持这个结构：<!--]--></p><ul><!--[--><li><!--[-->插入新元素 i 之前：把队尾那些值 &lt;= 新值 的下标全部弹掉，因为它们永远不可能再成为最大值（被更靠右且不更小的值遮蔽）。<!--]--></li><li><!--[-->把 i 放到队尾。<!--]--></li><li><!--[-->再把队头如果已经滑出窗口（下标 &lt;= i - k）就弹掉。<!--]--></li><!--]--></ul><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        deque&lt;int&gt; q;
        for(int i = 0; i &lt; k;i++)//先处理前k个元素，形成第一个窗口
        {   //把所有比当前元素小（或相等）的尾部下标移除
            while(!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();
            q.push_back(i);
        }// 此时队头就是第一个窗口最大值的下标
        vector&lt;int&gt; ans = {nums[q.front()]};
        for(int i = k; i &lt; n;i++)//继续处理后面的元素 i = k ... n-1
        {   //插入新元素之前，清理掉尾部不可能再用的
            while(!q.empty() &amp;&amp; nums[i] &gt;= nums[q.back()]) q.pop_back();
            q.push_back(i);
            //窗口现在是[i-k+1,i],如果队头已经出界就弹掉
            while(q.front() &lt;= i - k) q.pop_front();
            ans.push_back(nums[q.front()]);//队头就是当前窗口最大值
        }
        return ans;        
    }
};
</pre><!----></figure><h3 id="最小覆盖子串"><a href="#最小覆盖子串"><!--[--><a href="https://leetcode.cn/problems/minimum-window-substring/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->最小覆盖子串<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->思路：<strong><!--[-->滑动窗口<!--]--></strong><!--]--></p><p><!--[-->在滑动窗口类型的问题中都会有两个指针，一个用于「延伸」现有窗口的 r 指针，和一个用于「收缩」窗口的 l 指针。在任意时刻，只有一个指针运动，而另一个保持静止。<strong><!--[-->我们在 s 上滑动窗口，通过移动 r 指针不断扩张窗口。当窗口包含 t 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    unordered_map&lt;char,int&gt; ori,cnt;//cnt当前窗口各字符出现次数

    bool check(){//判断当前窗口是否已经覆盖t
        for(const auto &amp;p : ori) 
            if(cnt[p.first] &lt; p.second) return false;
        return true;
    }
    string minWindow(string s, string t) {
        for(const auto &amp;c:t) ori[c]++;//字符串t中每个字符出现次数(目标)

        int l = 0, r = -1;
        int len = INT_MAX,ansL = -1, ansR = -1;//最优的窗口左右边界
        //len记录目前找到的最短合法窗口长度
        while(r &lt; int(s.size())){
            if(ori.find(s[++r]) != ori.end()) cnt[s[r]]++;

            while(check() &amp;&amp; l &lt;= r)//如果满足条件，尝试缩短窗口
            {
                if(r - l + 1 &lt; len){
                    len = r - l + 1;
                    ansL = l;
                }
                if(ori.find(s[l]) != ori.end()) cnt[s[l]]--;//如果是目标字符，更新出现次数
                l++;
            } 
        }
        return ansL == -1?string():s.substr(ansL,len);//从ansl起，取长度为len的子串
    }
};
</pre><!----></figure><h2 id="普通数组"><a href="#普通数组"><!--[-->普通数组<!--]--></a></h2><h3 id="最大子数组和"><a href="#最大子数组和"><!--[--><a href="https://leetcode.cn/problems/maximum-subarray/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->最大子数组和<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int pre = 0,maxAns = nums[0];
        for(auto x : nums){
            pre = max(pre+x,x);//pre记录以当前元素结尾的连续子数组的最大和
            maxAns = max(maxAns,pre);
        }
        return maxAns;
    }
};
</pre><!----></figure><h3 id="合并区间"><a href="#合并区间"><!--[--><a href="https://leetcode.cn/problems/merge-intervals/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->合并区间<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->默认 <code data-v-cdb8f38f><!--[-->sort<!--]--></code> 对 <code data-v-cdb8f38f><!--[-->vector&lt;int&gt;<!--]--></code> 是按 <strong><!--[-->字典序<!--]--></strong> 排序。<!--]--></p><p><!--[-->对 <code data-v-cdb8f38f><!--[-->vector&lt;vector&lt;int&gt;&gt;<!--]--></code> 就是 <strong><!--[-->先比较第一列，再比较第二列...<!--]--></strong>。<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->vector::back()<!--]--></code> 的作用<!--]--></p><p><!--[-->在 C++ STL 里，<code data-v-cdb8f38f><!--[-->back()<!--]--></code> 是 <code data-v-cdb8f38f><!--[-->vector<!--]--></code> 的一个成员函数，功能是：<!--]--></p><p><!--[--><strong><!--[-->返回容器中最后一个元素的引用<!--]--></strong>。<!--]--></p><p><!--[-->首先，我们将列表中的区间按照左端点升序排序。然后我们将第一个区间加入 merged 数组中，并按顺序依次考虑之后的每个区间：
如果当前区间的<strong><!--[-->左端点<!--]--></strong>在数组 merged 中最后一个区间的<strong><!--[-->右端点<!--]--></strong>之后，那么它们不会重合，我们可以直接将这个区间加入数组 merged 的末尾；
否则，它们<strong><!--[-->重合<!--]--></strong>，我们需要用<strong><!--[-->当前<!--]--></strong>区间的<strong><!--[-->右端点<!--]--></strong>更新数组 merged 中最后一个区间的右端点，将其置为二者的较大值。<!--]--></p><figure class="image" data-v-9cbf15e9><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" data-nuxt-img srcset="https://7.isyangs.cn/20250819/8f0b5e48eebee6a5b15307ad03e57ac7.png 1x, https://7.isyangs.cn/20250819/8f0b5e48eebee6a5b15307ad03e57ac7.png 2x" class="image" style="cursor:zoom-in;" data-v-9cbf15e9 src="https://7.isyangs.cn/20250819/8f0b5e48eebee6a5b15307ad03e57ac7.png"><!----></figure><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {
        if(intervals.size() == 0) return {};

        sort(intervals.begin(),intervals.end());
        vector&lt;vector&lt;int&gt;&gt; merged;
        for(int i = 0; i &lt; intervals.size();i++)
        {
            int L = intervals[i][0],R = intervals[i][1];
            if(!merged.size() || merged.back()[1] &lt; L) merged.push_back({L,R});
            else merged.back()[1] = max(merged.back()[1],R);
        }
        return merged;
    }
};
</pre><!----></figure><h3 id="轮转数组"><a href="#轮转数组"><!--[--><a href="https://leetcode.cn/problems/rotate-array/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->轮转数组<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->🔹 <code data-v-cdb8f38f><!--[-->vector::assign<!--]--></code> 的作用<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->assign<!--]--></code> 是 <code data-v-cdb8f38f><!--[-->std::vector<!--]--></code> 的一个成员函数，用来把容器里的内容替换成新的内容<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->assign<!--]--></code> 会 <strong><!--[-->替换元素、修改 size<!--]--></strong>。<!--]--></p><p><!--[-->它不直接关心原来的容量，但如果原容量不够，会自动扩容。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    void rotate(vector&lt;int&gt;&amp; nums, int k) {
        int n = nums.size();
        vector&lt;int&gt; newArr(n);
        for(int i = 0; i &lt; n; i ++)
        {
            newArr[(i+k)%n] = nums[i];
        }
        nums.assign(newArr.begin(),newArr.end());
        //nums = newArr;
    }
};
</pre><!----></figure><h3 id="除自身以外数组的乘积"><a href="#除自身以外数组的乘积"><!--[--><a href="https://leetcode.cn/problems/product-of-array-except-self/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->除自身以外数组的乘积<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {
        int length = nums.size();
        vector&lt;int&gt; answer(length);

        //answer[i]表示索引左侧所有元素的乘积
        answer[0] = 1;
        for(int i = 1;i &lt; length;i++) answer[i] = nums[i-1] * answer[i-1];

        //R为右侧所有元素的乘积
        int R = 1;
        for(int i = length-1;i &gt;= 0; i --)
        {
            answer[i] = answer[i] * R;
            R *= nums[i];
        }
        return answer;
    }
};
</pre><!----></figure><h3 id="缺失的第一个正数"><a href="#缺失的第一个正数"><!--[--><a href="https://leetcode.cn/problems/first-missing-positive/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->缺失的第一个正数<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->我们的思路是首先，<strong><!--[-->正数<!--]--></strong>的范围为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>都出现，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">N+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>是缺少的数,其余则是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>然后，将数组中出现的正数进行标记，对于负数和0则不标记，那么，从小到大，没标记的第一个正整数就是缺失的数。<!--]--></p><p><!--[-->具体来说，对于遍历到的数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> ，如果它在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">[</mo><mn>1</mn><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[1,N] </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">]</span></span></span></span>的范围内，那么就将数组中的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">x−1 </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个位置打上标记<!--]--></p><p><!--[--><strong><!--[-->也就是说<!--]--></strong>，数组下标<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>对应着正数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，第一个没被标记的位置，其就是答案，对应的数为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        for(int &amp;i : nums){
            if(i &lt;= 0) i = n + 1;
        }

        for(int i = 0; i &lt; n;  i++)
        {
            int num = abs(nums[i]);
            if(num &lt;= n)//进行标记
                nums[num-1] = -abs(nums[num-1]);//变成负数
        }
        for(int i = 0;i &lt; n; i ++)
        {
            if(nums[i] &gt; 0) return i + 1;
        }
        return n + 1;//1-n的正数全部出现
    }
};
</pre><!----></figure><h2 id="矩阵"><a href="#矩阵"><!--[-->矩阵<!--]--></a></h2><h3 id="矩阵置零set"><a href="#矩阵置零set"><!--[--><a href="https://leetcode.cn/problems/set-matrix-zeroes/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->矩阵置零(set)<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->这里一开始我想用<code data-v-cdb8f38f><!--[-->find()<!--]--></code>和<code data-v-cdb8f38f><!--[-->count()<!--]--></code>但是想到只有<code data-v-cdb8f38f><!--[-->set<!--]--></code>和<code data-v-cdb8f38f><!--[-->map<!--]--></code>这两种容器有(并且都是不允许<strong><!--[-->重复<!--]--></strong>的)。<code data-v-cdb8f38f><!--[-->set<!--]--></code> 只存<strong><!--[-->元素<!--]--></strong>，<code data-v-cdb8f38f><!--[-->map<!--]--></code> 存<strong><!--[-->键值对<!--]--></strong><!--]--></p><p><!--[--><strong><!--[-->序列容器（vector/deque/list）<!--]--></strong><!--]--></p><ul><!--[--><li><!--[-->支持 <code data-v-cdb8f38f><!--[-->push_back<!--]--></code> / <code data-v-cdb8f38f><!--[-->push_front<!--]--></code> / <code data-v-cdb8f38f><!--[-->insert<!--]--></code><!--]--></li><li><!--[-->支持就地构造 <code data-v-cdb8f38f><!--[-->emplace_back<!--]--></code> / <code data-v-cdb8f38f><!--[-->emplace_front<!--]--></code> / <code data-v-cdb8f38f><!--[-->emplace(iterator, ...)<!--]--></code><!--]--></li><!--]--></ul><blockquote><!--[--><p><!--[--><strong><!--[-->注意<!--]--></strong>：<code data-v-cdb8f38f><!--[-->std::vector<!--]--></code> 没有 <code data-v-cdb8f38f><!--[-->push_front<!--]--></code>，因为在开头插入元素效率低（需要移动整个数组）。<!--]--></p><!--]--></blockquote><p><!--[--><strong><!--[-->关联容器（set/multiset/map/multimap）<!--]--></strong><!--]--></p><ul><!--[--><li><!--[-->没有“末尾/前端”的概念 → 没有 <code data-v-cdb8f38f><!--[-->push_back<!--]--></code> / <code data-v-cdb8f38f><!--[-->push_front<!--]--></code><!--]--></li><li><!--[-->插入用 <code data-v-cdb8f38f><!--[-->insert()<!--]--></code> 或 <code data-v-cdb8f38f><!--[-->emplace()<!--]--></code>，支持就地构造<!--]--></li><!--]--></ul><p><!--[-->下面是我的做法，通过利用2个set来存储出现0的位置，如果出现就将其变为0，否则不做变化。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        set&lt;int&gt; row,col;//行、列
        int m = matrix.size(),n = matrix[0].size();
        for(int i = 0; i &lt; m; i ++)
            for(int j = 0; j &lt; n; j++)
            {
                if(matrix[i][j] == 0)
                {
                    row.emplace(i);
                    col.emplace(j);
                }
            }
        for(int i = 0; i &lt; m; i ++)
        {
            for(int j = 0; j &lt; n; j++)
            {
                if(row.find(i) != row.end()|| col.find(j) != col.end()) matrix[i][j] = 0;
                else {}
                cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;;
            }
            cout &lt;&lt; endl;
        }
    }
};
</pre><!----></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵"><!--[--><a href="https://leetcode.cn/problems/spiral-matrix/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->螺旋矩阵<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->当路径超出界限或者进入之前访问过的位置时，顺时针旋转，进入下一个方向<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
private:
    //右下左上
    static constexpr int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
public:
    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }
        int rows = matrix.size(), columns = matrix[0].size();//行、列
        vector&lt;vector&lt;bool&gt;&gt; visited(rows, vector&lt;bool&gt;(columns));
        int total = rows * columns;
        vector&lt;int&gt; order(total);//答案数组

        int row = 0, column = 0;
        int dirId = 0;
        for (int i = 0; i &lt; total; i++) {
            order[i] = matrix[row][column];
            visited[row][column] = true;
            int nextRow = row + dir[dirId][0], nextColumn = column + dir[dirId][1];//下一步的坐标
            if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns || visited[nextRow][nextColumn]) {
                dirId = (dirId + 1) % 4;
            }
            row += dir[dirId][0];
            column += dir[dirId][1];
        }
        return order;
    }
};

</pre><!----></figure><h3 id="旋转图像"><a href="#旋转图像"><!--[--><a href="https://leetcode.cn/problems/rotate-image/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->旋转图像<!--]--><!--]--></a><!--]--></a></h3><blockquote><!--[--><p><!--[-->关键是在对于矩阵中第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 行的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个元素，在旋转后，它出现在倒数第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>列的第<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>个位置。<!--]--></p><!--]--></blockquote><p><!--[-->我们将其翻译成代码。由于矩阵中的行列从<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>开始计数，因此对于矩阵中的元素<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo stretchy="false">[</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex"> matrix[row][col]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal">x</span><span class="mopen">[</span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span></span></span></span>，在旋转后，它的新位置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><msub><mi>x</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo stretchy="false">[</mo><mi>c</mi><mi>o</mi><mi>l</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>−</mo><mi>r</mi><mi>o</mi><mi>w</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex"> matrix_{new}[col][n-1-row]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">[</span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ro</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span></span><!--]--></p><p><!--[-->参考题解:<a href="https://leetcode.cn/problems/rotate-image/solutions/526980/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->旋转图像<!--]--><!--]--></a><!--]--></p><p><!--[-->关键是在推出每个点的旋转涉及到四个点时，应该<strong><!--[-->旋转哪些点<!--]--></strong>。<!--]--></p><figure class="image" data-v-9cbf15e9><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" data-nuxt-img srcset="https://7.isyangs.cn/20250822/e30ded2a642f00c5f3614895d87b9628.png 1x, https://7.isyangs.cn/20250822/e30ded2a642f00c5f3614895d87b9628.png 2x" class="image" style="cursor:zoom-in;" data-v-9cbf15e9 src="https://7.isyangs.cn/20250822/e30ded2a642f00c5f3614895d87b9628.png"><!----></figure><p><!--[-->偶数如图所示，只需枚举四个块中一个即可，为了方便起见，选择蓝色的块。而当奇数时，要考虑下，<!--]--></p><figure class="image" data-v-9cbf15e9><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" data-nuxt-img srcset="https://7.isyangs.cn/20250824/7dd6de267732fb29496be9516813ec7f.webp 1x, https://7.isyangs.cn/20250824/7dd6de267732fb29496be9516813ec7f.webp 2x" class="image" style="cursor:zoom-in;" data-v-9cbf15e9 src="https://7.isyangs.cn/20250824/7dd6de267732fb29496be9516813ec7f.webp"><!----></figure><p><!--[-->同样四种颜色块选一个，这里我们将图中垂直纸面向左外翻转，枚举青色的这块，正好和偶数的能够对应上了。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>
class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {
        int n = matrix.size();

        for(int i = 0; i &lt; n / 2; i ++)
            for(int j = 0; j &lt; (n + 1) / 2;j++)
            {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = tmp;
            }
    }
};
</pre><!----></figure><h3 id="搜索二维矩阵-ii"><a href="#搜索二维矩阵-ii"><!--[--><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&amp;envId=top-100-liked" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->搜索二维矩阵 II<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->直接暴力枚举，因为数据较小，不会超时<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        int n = matrix.size(),m = matrix[0].size();
        for(int i = 0; i &lt; n;i++)
        for(int j = 0; j &lt; m;j++)
        {
            if(matrix[i][j] == target) return true;
        }
        return false;
    }
};
</pre><!----></figure><p><!--[-->但是这种并不<strong><!--[-->高效<!--]--></strong>。<!--]--></p><p><!--[--><strong><!--[-->每行二分查找<!--]--></strong>，复杂度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> 行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex"> n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 列。<!--]--></p><p><!--[-->核心点：<code data-v-cdb8f38f><!--[-->lower_bound<!--]--></code> 找到第一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≥</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">≥ target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span> 的位置，然后判断是否等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex"> target</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">e</span><span class="mord mathnormal">t</span></span></span></span>。<!--]--></p><p><!--[-->介绍下<code data-v-cdb8f38f><!--[-->lower_bound<!--]--></code>函数：<!--]--></p><p><!--[--><strong><!--[-->功能<!--]--></strong>：在 <code data-v-cdb8f38f><!--[-->[first, last)<!--]--></code> 范围内查找 <strong><!--[-->第一个不小于 value 的元素位置<!--]--></strong>。<!--]--></p><p><!--[--><strong><!--[-->要求<!--]--></strong>：区间必须 <strong><!--[-->已排序<!--]--></strong>（升序）才能正确工作。<!--]--></p><p><!--[--><strong><!--[-->返回值<!--]--></strong>：一个<strong><!--[-->迭代器<!--]--></strong>，指向 <strong><!--[-->第一个 &gt;= value 的元素<!--]--></strong>。<!--]--></p><ul><!--[--><li><!--[-->如果所有元素都小于 value，返回 <code data-v-cdb8f38f><!--[-->last<!--]--></code>（即末尾迭代器）。<!--]--></li><!--]--></ul><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) {
        for(const auto&amp; row : matrix)
        {
            auto it = lower_bound(row.begin(),row.end(),target);
            if(it != row.end() &amp;&amp; *it == target) return true;
        }
        return false;
    }
};
</pre><!----></figure><h3 id="划分字母区间"><a href="#划分字母区间"><!--[--><a href="https://leetcode.cn/problems/partition-labels/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->划分字母区间<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->要求片段数<strong><!--[-->尽可能的多<!--]--></strong>，同时<strong><!--[-->一个字母只能出现在一个片段中<!--]--></strong>。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;int&gt; partitionLabels(string s) {
        int last[26];
        int length = s.size();
        for(int i = 0; i &lt; length; i ++) last[s[i] - &#039;a&#039;] = i;//记录每个字母出现的下标

        vector&lt;int&gt; partition;
        int start = 0,end = 0;
        for(int i = 0; i &lt; length;i++){
            end = max(end,last[s[i]-&#039;a&#039;]);
            if(i == end){
                partition.push_back(end-start+1);
                start = end + 1;
            }
        }
        return partition;
    }
};
</pre><!----></figure><h2 id="链表"><a href="#链表"><!--[-->链表<!--]--></a></h2><h3 id="相交链表"><a href="#相交链表"><!--[--><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->相交链表<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        unordered_set&lt;ListNode*&gt; visited;
        ListNode *temp = headA;
        while(temp != NULL){
            visited.insert(temp);
            temp = temp-&gt;next;
        }
        temp = headB;
        while(temp != NULL){
            if(visited.count(temp)) return temp;
            temp = temp-&gt;next;
        }
        return NULL;
    }
};
</pre><!----></figure><h3 id="反转链表"><a href="#反转链表"><!--[--><a href="https://leetcode.cn/problems/reverse-linked-list/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->反转链表<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;// 反转后链表的头，一开始为空
        ListNode* cur = head;
        while(cur){
            ListNode* next = cur-&gt;next;// 1. 保存下一个节点
            cur-&gt;next = prev;//2. 进行翻转
            prev = cur;//3. 将头节点前进
            cur = next;//4. 下一个节点
        }
        return prev;
    }
};
</pre><!----></figure><h3 id="回文链表"><a href="#回文链表"><!--[--><a href="https://leetcode.cn/problems/palindrome-linked-list/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->回文链表<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->指针存的是地址.<!--]--></p><p><!--[-->通过快慢指针，得到中点位置，然后对两段进行比较。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (!head || !head-&gt;next) return true;

        // 1. 快慢指针找中点
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }
        // 此时 slow 在“前半段的末尾”：
        // n 为偶数：slow 在左中点
        // n 为奇数：slow 在真正中点的位置（下一步反转从 slow-&gt;next 开始）

        // 2. 反转后半部分
        ListNode* second = reverseList(slow-&gt;next);

        // 3. 比较前半部分和反转后的后半部分
        ListNode* p1 = head;
        ListNode* p2 = second;
        bool res = true;
        while (p2) {
            if (p1-&gt;val != p2-&gt;val) {
                res = false;
                break;
            }
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        }
        return res;
    }

    ListNode* reverseList(ListNode* head) {//返回头节点
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr) {
            ListNode* next = curr-&gt;next;
            curr-&gt;next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
};

</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>47 行</span></button></figure><h3 id="环形链表"><a href="#环形链表"><!--[-->环形链表<!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_set&lt;ListNode*&gt; seen;
        while(head != NULL){
            if(seen.count(head)) return true;
            seen.insert(head);
            head = head-&gt;next;
        } 
        return false;
    }
};
</pre><!----></figure><h3 id="环形链表-ii"><a href="#环形链表-ii"><!--[--><a href="https://leetcode.cn/problems/linked-list-cycle-ii/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->环形链表 II<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        unordered_set&lt;ListNode*&gt; seen;
        while(head != NULL)
        {
            if(seen.count(head)) return head;
            seen.insert(head);
            head = head-&gt;next;
        }
        return NULL;
    }
};
</pre><!----></figure><h3 id="合并两个有序链表"><a href="#合并两个有序链表"><!--[--><a href="https://leetcode.cn/problems/merge-two-sorted-lists/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->合并两个有序链表<!--]--><!--]--></a><!--]--></a></h3><h2 id="回溯"><a href="#回溯"><!--[-->回溯<!--]--></a></h2><h3 id="全排列"><a href="#全排列"><!--[--><a href="https://leetcode.cn/problems/permutations/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->全排列<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:     //output是待排列数组
    void backtrack(vector&lt;vector&lt;int&gt;&gt;&amp; res,vector&lt;int&gt;&amp; output,int first,int len)
    {//len数组长度，first当前填充位置
        if(first == len){
            res.emplace_back(output);
            return;
        }
        for(int i = first;i &lt; len;i++){//按位置考虑
            swap(output[i],output[first]);
            backtrack(res,output,first+1,len);
            swap(output[i],output[first]);
        }
    }
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        vector&lt;vector&lt;int&gt;&gt; res;
        backtrack(res,nums,0,(int)nums.size());
        return res;
    }
};
</pre><!----></figure><h3 id="n-皇后"><a href="#n-皇后"><!--[--><a href="https://leetcode.cn/problems/n-queens/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->N 皇后<!--]--><!--]--></a><!--]--></a></h3><p><!--[--><code data-v-cdb8f38f><!--[-->clear()<!--]--></code>作用是清空里面的内容。<!--]--></p><p><!--[--><code data-v-cdb8f38f><!--[-->assign<!--]--></code> 是 <strong><!--[-->STL 容器的方法<!--]--></strong>（如 <code data-v-cdb8f38f><!--[-->vector<!--]--></code>, <code data-v-cdb8f38f><!--[-->string<!--]--></code>, <code data-v-cdb8f38f><!--[-->deque<!--]--></code>, …），作用是<strong><!--[-->把容器重新赋值（替换内容）<!--]--></strong>。 它和 <code data-v-cdb8f38f><!--[-->=<!--]--></code> 类似，但更灵活<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;vector&lt;string&gt;&gt; res;  // 存所有解
    vector&lt;string&gt; board;        // 当前棋盘
    vector&lt;bool&gt; col, dg, udg;   // 列、主对角线、副对角线
    int n;

    void dfs(int r) {//当前考虑到了第几行
        if (r == n) {
            res.push_back(board); // 保存当前解
            return;
        }
        for (int i = 0; i &lt; n; i++) {//考虑列的填充(r行i列)
            if (!col[i] &amp;&amp; !dg[r + i] &amp;&amp; !udg[i - r + n]) {//当前位置能填的话
                col[i] = dg[r + i] = udg[i - r + n] = true;
                board[r][i] = &#039;Q&#039;;
                dfs(r + 1);
                board[r][i] = &#039;.&#039;;
                col[i] = dg[r + i] = udg[i - r + n] = false;
            }
        }
    }

    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int _n) {
        n = _n;
        res.clear();
        board = vector&lt;string&gt;(n, string(n, &#039;.&#039;));
        col.assign(n, false);
        dg.assign(2 * n, false);//对角线
        udg.assign(2 * n, false);
        dfs(0);
        return res;
    }
};

</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>35 行</span></button></figure><h2 id="贪心算法"><a href="#贪心算法"><!--[-->贪心算法<!--]--></a></h2><h3 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机"><!--[--><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->买卖股票的最佳时机<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int n = prices.size();
        int ans = 0,minprice = prices[0];
        for(auto i : prices)
        {
            minprice = min(minprice,i);
            ans = max(ans,i - minprice);
        }
        return ans;
    }
};
</pre><!----></figure><h3 id="跳跃游戏"><a href="#跳跃游戏"><!--[--><a href="https://leetcode.cn/problems/jump-game/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->跳跃游戏<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->只需每次考虑最远能跳到哪。维护一个当前能够跳到最远的变量<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightmost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">os</span><span class="mord mathnormal">t</span></span></span></span>,遍历数组，先看当前位置是否在当前能跳到的位置上，如果可以，更新<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightmost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">os</span><span class="mord mathnormal">t</span></span></span></span>。然后判断当前的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mi>m</mi><mi>o</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">rightmost</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">i</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">h</span><span class="mord mathnormal">t</span><span class="mord mathnormal">m</span><span class="mord mathnormal">os</span><span class="mord mathnormal">t</span></span></span></span>是否<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&gt;</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">&gt;=n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    bool canJump(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        int rightmost = 0;//当前最远能够到达的位置
        for(int i = 0; i &lt; n;i++)
        {
            if(i &lt;= rightmost) 
            {
                rightmost = max(rightmost,i + nums[i]);
                if(rightmost &gt;= n - 1) return true;
            }
        }
        return false;
    }
};
</pre><!----></figure><h3 id="跳跃游戏-ii"><a href="#跳跃游戏-ii"><!--[--><a href="https://leetcode.cn/problems/jump-game-ii/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->跳跃游戏 II<!--]--><!--]--></a><!--]--></a></h3><p><!--[-->每次找到<strong><!--[-->可到达<!--]--></strong>的<strong><!--[-->最远<!--]--></strong>位置<!--]--></p><p><!--[-->在遍历数组时，我们<strong><!--[-->不访问最后一个元素<!--]--></strong>，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。<strong><!--[-->如果访问最后一个元素<!--]--></strong>，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。<!--]--></p><p><!--[-->关于<strong><!--[-->这里<!--]--></strong>，详细解释下:如果访问最后一个元素，这种情况很好理解，之前已经能用更少的步数到达，不用再加次数，这里的依据是在<strong><!--[-->访问最后一个元素之前，我们的边界一定大于等于最后一个位置<!--]--></strong>。<!--]--></p><p><!--[-->那么<strong><!--[-->我们假设<!--]--></strong>访问最后一个元素之前，边界<strong><!--[-->小于<!--]--></strong>最后一个位置。也就是说当访问<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">i=n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mo>&lt;</mo><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">maxPos&lt;n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">os</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>。当到达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>时，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">maxPos = max(maxPos,n-2+nums[n-2])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">os</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mopen">(</span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">os</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">])</span></span></span></span>，那么如果<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">maxPos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">os</span></span></span></span>要小于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的话，就得确保<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi><mo>&lt;</mo><mo>=</mo><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">maxPos&lt;=n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">os</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>，那么可得<!--]--></p><p><!--[--><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">nums[n-2]&lt;=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，题目中说<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mn>1000</mn></mrow><annotation encoding="application/x-tex">0 &lt;= nums[i] &lt;= 1000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6835em;vertical-align:-0.0391em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1000</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>2</mn><mo stretchy="false">]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">nums[n-2]=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal">s</span><span class="mopen">[</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>，那么在此刻<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>x</mi><mi>P</mi><mi>o</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">maxPos</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">ma</span><span class="mord mathnormal">x</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">os</span></span></span></span>是无法通过更新来比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n-2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span>大的，即无法到达<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>，而题目中说了，<strong><!--[-->保证可以到达<!--]--></strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>,因此<strong><!--[-->假设错误<!--]--></strong>，即<strong><!--[-->访问最后一个元素之前，我们的边界一定大于等于最后一个位置<!--]--></strong>。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int jump(vector&lt;int&gt;&amp; nums) {
        int maxPos = 0,n = nums.size(),end = 0,step = 0;
        for(int i = 0;i &lt; n - 1;i++)
        {
            if(i &lt;= maxPos)
            {   //maxPos是当前能够最远到达的距离
                maxPos = max(maxPos,i + nums[i]);
                if(i == end){//end是当前这一步能够到达的边界
                    end = maxPos;
                    step++;
                }
            }
        }
        return step;
    }
};
</pre><!----></figure><h2 id="动态规划"><a href="#动态规划"><!--[-->动态规划<!--]--></a></h2><h3 id="爬楼梯"><a href="#爬楼梯"><!--[--><a href="https://leetcode.cn/problems/climbing-stairs/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->爬楼梯<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int climbStairs(int n) {
        vector&lt;int&gt; dp(n+1,0);
        dp[1] = 1;
        dp[0] = 1;
        for(int i = 2; i &lt;= n; i ++)
            dp[i] = dp[i-1] + dp[i-2];
        return dp[n];
    }
};
</pre><!----></figure><h3 id="杨辉三角"><a href="#杨辉三角"><!--[--><a href="https://leetcode.cn/problems/pascals-triangle/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->杨辉三角<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; ret(numRows);
        for(int i = 0; i &lt; numRows;i++)
        {
            ret[i].resize(i+1);
            ret[i][0] = ret[i][i] = 1;
            for(int j = 1; j &lt; i;j++)
            ret[i][j] = ret[i-1][j-1] + ret[i-1][j];
        }
        return ret;
    }
};
</pre><!----></figure><h3 id="打家劫舍"><a href="#打家劫舍"><!--[--><a href="https://leetcode.cn/problems/house-robber/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->打家劫舍<!--]--><!--]--></a><!--]--></a></h3><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int rob(vector&lt;int&gt;&amp; nums) {
        if(nums.empty()) return 0;

        int size = nums.size();
        if(size == 1) return nums[0];

        vector&lt;int&gt; dp = vector&lt;int&gt; (size,0);
        dp[0] = nums[0];
        dp[1] = max(nums[0],nums[1]);
        for(int i = 2; i &lt; size;i++)
            dp[i] = max(dp[i-2]+nums[i],dp[i-1]);
        return dp[size-1];
        
    }
};
</pre><!----></figure><h3 id="完全平方数"><a href="#完全平方数"><!--[--><a href="https://leetcode.cn/problems/perfect-squares/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->完全平方数<!--]--><!--]--></a><!--]--></a></h3><p><!--[--><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span> 表示最少需要多少个数的平方来表示整数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span><!--]--></p><p><!--[-->这道题的关键在于深刻理解<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">f[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span>是由前面的几个平方数加上最后一个<strong><!--[-->平方数<!--]--></strong>，<!--]--></p><p><!--[-->举例子 (n = 13)<!--]--></p><ul><!--[--><li><!--[--><code data-v-cdb8f38f><!--[-->f[1] = f[0] + 1 = 1<!--]--></code> → 1<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->f[2] = f[1] + 1 = 2<!--]--></code> → 1+1<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->f[3] = f[2] + 1 = 3<!--]--></code> → 1+1+1<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->f[4] = min(f[3], f[0]) + 1 = 1<!--]--></code> → 4<!--]--></li><li><!--[-->…<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->f[12] = min(f[11], f[8], f[3]) + 1 = 3<!--]--></code> → 4+4+4<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->f[13] = min(f[12], f[9], f[4]) + 1 = 2<!--]--></code> → 4+9<!--]--></li><!--]--></ul><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>class Solution {
public:
    int numSquares(int n) {
        vector&lt;int&gt; f(n+1);
        for(int i = 1;i &lt;= n;  i++)
        {
            int minn = INT_MAX;
            //枚举最后一个平方数之前的最少平方数是多少
            for(int j = 1;j * j &lt;= i;j++) minn = min(minn,f[i-j*j]);

            f[i] = minn + 1;
        }
        return f[n];
    }
};
</pre><!----></figure><h3 id="零钱兑换"><a href="#零钱兑换"><!--[--><a href="https://leetcode.cn/problems/coin-change/" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->零钱兑换<!--]--><!--]--></a><!--]--></a></h3></article><div class="post-footer" data-v-cdb923bb><!----><section class="license" data-v-cdb923bb><div class="title text-creative" data-v-cdb923bb> 许可协议 </div><div class="content" data-v-cdb923bb><p data-v-cdb923bb> 本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener noreferrer" target="_blank" class="z-link" data-v-cdb923bb data-v-b771bfcd><!--[--><span class="iconify i-ri:creative-commons-line domain-icon" aria-hidden="true" style="" data-v-b771bfcd></span><!--[-->署名-非商业性使用-相同方式共享 4.0 国际<!--]--><!--]--></a> 许可协议，转载请注明出处。 </p></div></section></div><!--[--><!----><div class="surround-post" dir="ltr" data-v-b609bb41><!--[--><a href="/2025/c++andyolo" class="surround-link" data-v-b609bb41><!--[--><span class="iconify i-solar:rewind-back-bold-duotone rtl-flip" aria-hidden="true" style="" data-v-b609bb41></span><div class="surround-text" data-v-b609bb41><strong class="title text-tech" data-v-b609bb41>C++面向对象与YOLO目标检测</strong><time datetime="2025-09-07T18:48:51.000Z" data-v-b609bb41>9月7日</time></div><!--]--></a><!--]--><!--[--><a href="/2025/review-math" class="surround-link" align-end data-v-b609bb41><!--[--><span class="iconify i-solar:rewind-forward-bold-duotone rtl-flip" aria-hidden="true" style="" data-v-b609bb41></span><div class="surround-text" data-v-b609bb41><strong class="title text-tech" data-v-b609bb41>复习——数学篇</strong><time datetime="2025-08-20T21:45:38.000Z" data-v-b609bb41>8月20日</time></div><!--]--></a><!--]--></div><!--]--><section class="z-comment" data-v-98eb1275><h3 class="text-creative" data-v-98eb1275> 评论区 </h3><div id="twikoo" data-v-98eb1275><p data-v-98eb1275>评论加载中...</p></div></section><!--]--><footer class="z-footer" data-v-005c9c56><nav class="footer-nav" data-v-005c9c56><!--[--><div class="footer-nav-group" data-v-005c9c56><h3 data-v-005c9c56>探索</h3><menu data-v-005c9c56><!--[--><li data-v-005c9c56><a href="/atom.xml" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:rss-simple-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>Atom订阅</span><!--]--></a></li><li data-v-005c9c56><a href="https://www.travellings.cn/" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:subway-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>开往</span><!--]--></a></li><!--]--></menu></div><div class="footer-nav-group" data-v-005c9c56><h3 data-v-005c9c56>社交</h3><menu data-v-005c9c56><!--[--><li data-v-005c9c56><a href="https://github.com/yingzya" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:github-logo-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>yingzya</span><!--]--></a></li><li data-v-005c9c56><a href="https://jq.qq.com/?_wv=1027&amp;k=lQfNSeEd" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ri:qq-line" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>群: 169994096</span><!--]--></a></li><li data-v-005c9c56><a href="mailto:yzy11235@qq.com" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:envelope-simple-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>yzy11235@qq.com</span><!--]--></a></li><!--]--></menu></div><div class="footer-nav-group" data-v-005c9c56><h3 data-v-005c9c56>信息</h3><menu data-v-005c9c56><!--[--><li data-v-005c9c56><a href="https://github.com/L33Z22L11/blog-v3" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-simple-icons:nuxtdotjs" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>主题: Clarity 1.4.0</span><!--]--></a></li><li data-v-005c9c56><a href="https://blog.zhilu.site/theme" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:swatches-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>主题和组件文档</span><!--]--></a></li><li data-v-005c9c56><a href="https://beian.miit.gov.cn/" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:certificate-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>晋ICP备2025064396号-2</span><!--]--></a></li><!--]--></menu></div><!--]--></nav><p data-v-005c9c56>© 2025 轻语</p></footer></main><!--[--><!----><aside id="z-aside" class="" data-v-377c1f75><!--[--><section class="widget" data-v-377c1f75 data-v-9ccca5b3 data-v-489d5b4f><hgroup class="widget-title text-creative" data-v-489d5b4f><!--[--><span class="title" data-v-9ccca5b3>文章目录</span><a href="#main-content" aria-label="返回开头" data-v-9ccca5b3><span class="iconify i-ph:arrow-circle-up-bold" aria-hidden="true" style="" data-v-9ccca5b3></span></a><a href="#twikoo" aria-label="评论区" data-v-9ccca5b3><span class="iconify i-ph:chat-circle-text-bold" aria-hidden="true" style="" data-v-9ccca5b3></span></a><!--]--></hgroup><div class="widget-body" data-v-489d5b4f><!----><!--[--><!----><span data-v-9ccca5b3></span><!--]--></div></section><!--]--></aside><!--]--></div><div id="z-panel" class="" data-v-a7de42e5><button id="toggle-sidebar" class="" aria-label="切换菜单" data-v-a7de42e5><span class="iconify i-ph:sidebar-duotone rtl-flip" aria-hidden="true" style="" data-v-a7de42e5></span></button><button id="toggle-aside" class="" aria-label="切换侧边栏" data-v-a7de42e5><span class="iconify i-ph:align-right-duotone rtl-flip" aria-hidden="true" style="" data-v-a7de42e5></span></button></div><!--[--><!--]--><!--]--></div><div id="teleports"></div><script type="application/ld+json" data-nuxt-schema-org="true" data-hid="schema-org-graph">{"@context":"https://schema.org","@graph":[{"@id":"https://blog.yangzy.top/#website","@type":"WebSite","inLanguage":"zh-CN","name":"字节追风者","url":"https://blog.yangzy.top/"},{"@id":"https://blog.yangzy.top/2025/lkhot100#webpage","@type":"WebPage","description":"​​力扣Hot100​​热门算法题库的题解，涵盖了​哈希、双指针、滑动窗口、子串、普通数组、矩阵、链表、回溯、贪心算法、动态规划​​等核心算法与数据结构。","name":"力扣Hot100","url":"https://blog.yangzy.top/2025/lkhot100","isPartOf":{"@id":"https://blog.yangzy.top/#website"},"potentialAction":[{"@type":"ReadAction","target":["https://blog.yangzy.top/2025/lkhot100"]}]}]}</script><script type="application/json" data-nuxt-data="nuxt-app" data-ssr="true" id="__NUXT_DATA__" data-src="/2025/lkhot100/_payload.json?42d9e1ea-82ef-4f58-a871-8d05a7412659">[{"state":1,"once":16,"_errors":17,"serverRendered":5,"path":19,"pinia":20,"prerenderedAt":162},["Reactive",2],{"$scolor-mode":3,"$snuxt-seo-utils:routeRules":7,"$ssite-config":8},{"preference":4,"value":4,"unknown":5,"forced":6},"system",true,false,{"head":-1,"seoMeta":-1},{"_priority":9,"defaultLocale":12,"env":13,"name":14,"url":15},{"name":10,"env":11,"url":10,"defaultLocale":10},-3,-15,"zh-CN","production","字节追风者","https://blog.yangzy.top/",["Set"],["ShallowReactive",18],{"/2025/lkhot100":-1,"surround-/2025/lkhot100":-1},"/2025/lkhot100",{"layout":21,"search":29,"popover":32,"content":36,"shiki":161},{"open":22,"asideWidgets":25},["Ref",23],["Reactive",24],{"sidebar":6,"aside":6,"search":6},["Ref",26],["Reactive",27],[28],"toc",{"word":30},["EmptyRef",31],"\"\"",{"pops":33},["Ref",34],["Reactive",35],[],{"toc":37,"meta":158},["Ref",38],["Reactive",39],{"title":40,"searchDepth":41,"depth":41,"links":42},"",4,[43,55,66,73,83,96,111,127,135,145],{"id":44,"depth":45,"text":44,"children":46},"哈希",2,[47,50,52],{"id":48,"depth":49,"text":48},"两数之和",3,{"id":51,"depth":49,"text":51},"字母异位词分组",{"id":53,"depth":49,"text":54},"最长连续序列set","最长连续序列(set)",{"id":56,"depth":45,"text":56,"children":57},"双指针",[58,60,62,64],{"id":59,"depth":49,"text":59},"移动零",{"id":61,"depth":49,"text":61},"盛最多水的容器",{"id":63,"depth":49,"text":63},"三数之和",{"id":65,"depth":49,"text":65},"接雨水",{"id":67,"depth":45,"text":67,"children":68},"滑动窗口",[69,71],{"id":70,"depth":49,"text":70},"无重复字符的最长子串",{"id":72,"depth":49,"text":72},"找到字符串中所有字母异位词",{"id":74,"depth":45,"text":74,"children":75},"子串",[76,79,81],{"id":77,"depth":49,"text":78},"和为-k-的子数组map","和为 K 的子数组(map)",{"id":80,"depth":49,"text":80},"滑动窗口最大值",{"id":82,"depth":49,"text":82},"最小覆盖子串",{"id":84,"depth":45,"text":84,"children":85},"普通数组",[86,88,90,92,94],{"id":87,"depth":49,"text":87},"最大子数组和",{"id":89,"depth":49,"text":89},"合并区间",{"id":91,"depth":49,"text":91},"轮转数组",{"id":93,"depth":49,"text":93},"除自身以外数组的乘积",{"id":95,"depth":49,"text":95},"缺失的第一个正数",{"id":97,"depth":45,"text":97,"children":98},"矩阵",[99,102,104,106,109],{"id":100,"depth":49,"text":101},"矩阵置零set","矩阵置零(set)",{"id":103,"depth":49,"text":103},"螺旋矩阵",{"id":105,"depth":49,"text":105},"旋转图像",{"id":107,"depth":49,"text":108},"搜索二维矩阵-ii","搜索二维矩阵 II",{"id":110,"depth":49,"text":110},"划分字母区间",{"id":112,"depth":45,"text":112,"children":113},"链表",[114,116,118,120,122,125],{"id":115,"depth":49,"text":115},"相交链表",{"id":117,"depth":49,"text":117},"反转链表",{"id":119,"depth":49,"text":119},"回文链表",{"id":121,"depth":49,"text":121},"环形链表",{"id":123,"depth":49,"text":124},"环形链表-ii","环形链表 II",{"id":126,"depth":49,"text":126},"合并两个有序链表",{"id":128,"depth":45,"text":128,"children":129},"回溯",[130,132],{"id":131,"depth":49,"text":131},"全排列",{"id":133,"depth":49,"text":134},"n-皇后","N 皇后",{"id":136,"depth":45,"text":136,"children":137},"贪心算法",[138,140,142],{"id":139,"depth":49,"text":139},"买卖股票的最佳时机",{"id":141,"depth":49,"text":141},"跳跃游戏",{"id":143,"depth":49,"text":144},"跳跃游戏-ii","跳跃游戏 II",{"id":146,"depth":45,"text":146,"children":147},"动态规划",[148,150,152,154,156],{"id":149,"depth":49,"text":149},"爬楼梯",{"id":151,"depth":49,"text":151},"杨辉三角",{"id":153,"depth":49,"text":153},"打家劫舍",{"id":155,"depth":49,"text":155},"完全平方数",{"id":157,"depth":49,"text":157},"零钱兑换",["Ref",159],["Reactive",160],{},{},1758977468536]</script><script>window.__NUXT__={};window.__NUXT__.config={public:{buildTime:"2025-09-27T12:50:44.584Z",nodeVersion:"v22.19.0",platform:"linux",arch:"x64",ci:"GitHub Actions",content:{wsUrl:""},mdc:{components:{prose:true,map:{}},headings:{anchorLinks:{h1:false,h2:true,h3:true,h4:true,h5:false,h6:false}}},"seo-utils":{canonicalQueryWhitelist:["page","sort","filter","search","q","category","tag"],canonicalLowercase:true}},app:{baseURL:"/",buildId:"42d9e1ea-82ef-4f58-a871-8d05a7412659",buildAssetsDir:"/_nuxt/",cdnURL:""}}</script></body></html>