[{"data":1,"prerenderedAt":2211},["ShallowReactive",2],{"/2025/lanqiao2025":3,"surround-/2025/lanqiao2025":2200},{"id":4,"title":5,"body":6,"categories":2178,"date":2180,"description":2181,"draft":2182,"extension":2183,"image":2184,"meta":2185,"navigation":2186,"path":2187,"readingTime":2188,"recommend":2193,"references":2193,"seo":2194,"sitemap":2195,"stem":2196,"tags":2197,"type":2193,"updated":2180,"url":2193,"__hash__":2199},"content/posts/2025/lanqiao2025.md","2025蓝桥杯突击训练",{"type":7,"value":8,"toc":2137},"minimark",[9,13,104,108,123,133,143,153,156,162,165,185,188,191,197,203,205,210,216,226,229,240,243,247,256,262,265,268,274,278,285,288,294,298,304,308,314,317,320,326,330,333,339,343,349,353,359,362,368,371,375,381,385,391,395,401,405,408,412,418,424,429,437,446,458,465,476,482,486,493,537,546,551,574,588,603,610,613,619,625,627,633,636,642,648,654,658,661,669,672,675,682,685,692,702,709,712,718,722,725,736,742,746,752,756,759,832,843,850,860,863,866,881,891,894,897,903,907,913,919,924,931,949,952,967,973,976,981,992,996,1002,1006,1017,1023,1027,1033,1036,1042,1047,1050,1085,1091,1094,1097,1103,1106,1125,1131,1137,1142,1214,1219,1232,1238,1242,1257,1268,1274,1278,1281,1284,1290,1293,1299,1305,1311,1317,1324,1327,1333,1340,1346,1357,1362,1365,1386,1392,1398,1403,1409,1413,1416,1422,1426,1431,1466,1471,1490,1496,1500,1506,1510,1526,1529,1553,1562,1568,1572,1578,1584,1591,1597,1601,1624,1629,1635,1653,1669,1674,1774,1779,1785,1791,1795,1801,1807,1812,1823,1828,1909,1912,1926,1932,1935,1939,1948,1977,1985,1991,1997,2001,2007,2011,2017,2020,2027,2034,2040,2049,2055,2059,2064,2067,2074,2080,2084,2088,2094,2097,2101,2106,2112,2116,2122,2128,2131],[10,11,12],"h2",{"id":12},"个人的变量命名习惯",[14,15,16,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77,80,83,86,89,92,95,98,101],"ul",{},[17,18,19],"li",{},"T test_case",[17,21,22],{},"mark 标记",[17,24,25],{},"n    number",[17,27,28],{},"e edge",[17,30,31],{},"v vertex",[17,33,34],{},"v vector",[17,36,37],{},"v volume",[17,39,40],{},"v value",[17,42,43],{},"w weight",[17,45,46],{},"d depth",[17,48,49],{},"h head",[17,51,52],{},"u/v/w 输入边的起点终点和权重",[17,54,55],{},"vis   visited",[17,57,58],{},"l left",[17,60,61],{},"r right",[17,63,64],{},"mid middle",[17,66,67],{},"pos position",[17,69,70],{},"p pointer",[17,72,73],{},"s/st start",[17,75,76],{},"ed end",[17,78,79],{},"m matrix",[17,81,82],{},"g graph",[17,84,85],{},"s set",[17,87,88],{},"q queue",[17,90,91],{},"c/cnt count",[17,93,94],{},"ans answer",[17,96,97],{},"ret return",[17,99,100],{},"res result",[17,102,103],{},"t/tmp temporary临时变量",[105,106,107],"h1",{"id":107},"数据分析",[109,110,111,115,116,119,120],"p",{},[112,113,114],"strong",{},"int","的数据范围最高到",[112,117,118],{},"1e9",",超了记得换",[112,121,122],{},"long long",[109,124,125],{},[112,126,127,128,132],{},"第二步：构造 ",[129,130,131],"code",{"code":131},"tm"," 结构体",[134,135,141],"pre",{"className":136,"code":138,"language":139,"meta":140},[137],"language-c++","tm t = {0, 0, 0, d, m - 1, y - 1900};\n","c++","",[129,142,138],{"__ignoreMap":140},[109,144,145,146,149,150,152],{},"这里用到了 ",[129,147,148],{"code":148},"\u003Cctime>"," 库里定义的结构体 ",[129,151,131],{"code":131},"，这是 c/c++ 里专门用来表示日期的结构体。",[109,154,155],{},"结构如下：",[134,157,160],{"className":158,"code":159,"language":139,"meta":140},[137],"struct tm {\nint tm_sec;   // 秒\nint tm_min;   // 分\nint tm_hour;  // 时\nint tm_mday;  // 天\nint tm_mon;   // 月（0~11）❗️注意不是 1~12\nint tm_year;  // 年（从 1900 开始）❗️\n};\n",[129,161,159],{"__ignoreMap":140},[109,163,164],{},"所以：",[14,166,167,173,179],{},[17,168,169,172],{},[129,170,171],{"code":171},"t.tm_mday = d;"," // 天 = 11",[17,174,175,178],{},[129,176,177],{"code":177},"t.tm_mon = m - 1;"," // 月 = 4 - 1 = 3（代表 4 月）",[17,180,181,184],{},[129,182,183],{"code":183},"t.tm_year = y - 1900;"," // 年 = 2025 - 1900 = 125",[186,187],"hr",{},[109,189,190],{},"第三步：日期 +1 天",[134,192,195],{"className":193,"code":194,"language":139,"meta":140},[137],"t.tm_mday += 1;\n",[129,196,194],{"__ignoreMap":140},[109,198,199,200],{},"直接把天数加 1，",[112,201,202],{},"可能会超出当前月的天数，比如加到 31 号或 29 号（2 月）等等。",[186,204],{},[109,206,207],{},[112,208,209],{},"第四步：让系统帮你“进位”",[134,211,214],{"className":212,"code":213,"language":139,"meta":140},[137],"mktime(&t);\n",[129,215,213],{"__ignoreMap":140},[109,217,218,221,222,225],{},[129,219,220],{"code":220},"mktime"," 会自动处理你加了一天后产生的 ",[112,223,224],{},"月进位 / 年进位 / 闰年处理","。",[109,227,228],{},"比如：",[14,230,231,234,237],{},[17,232,233],{},"2月28日 +1 → 3月1日（非闰年）",[17,235,236],{},"2月28日 +1 → 2月29日（闰年）",[17,238,239],{},"12月31日 +1 → 下一年 1月1日",[105,241,242],{"id":242},"算法1-3暴力枚举",[10,244,246],{"id":245},"p2241统计方形","P2241统计方形",[109,248,249,250],{},"参考的大佬的题解：",[251,252,253],"a",{"href":253,"rel":254},"https://www.luogu.com.cn/problem/solution/P2241",[255],"nofollow",[109,257,258,259,261],{},"注意要开",[112,260,122],{},"，因为最坏的情况是从1➕到5000 * 5000，超出了int",[109,263,264],{},"等差数列求和公式：",[109,266,267],{},"S=n*(n+1) / 2",[134,269,272],{"className":270,"code":271,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint n,m;\ntypedef long long ll;\n\nll zheng,chang;\n\nint main()\n{\n    cin >> n >> m;             //对于正方形来说，子矩阵的个数是有原矩阵减去相同的数得到\n    for(int i = 0; i \u003C n; i ++)//对于长方形来说，子矩形构成的矩阵的长宽是由原矩形长宽减去不同数而得\n        for(int j = 0; j \u003C m;j++)//棋盘中的矩阵不是正方形就是长方形，\n        {\n            if(i == j) zheng += (n-i)*(m - i);\n            else chang += (n-i)*(m-j);\n        }\n    cout \u003C\u003C zheng \u003C\u003C \" \" \u003C\u003C chang \u003C\u003C endl;\n    return 0;\n}\n",[129,273,271],{"__ignoreMap":140},[10,275,277],{"id":276},"p2089烤鸡","P2089烤鸡",[109,279,280,281],{},"题目链接： ",[251,282,283],{"href":283,"rel":284},"https://www.luogu.com.cn/problem/P2089",[255],[109,286,287],{},"一道比较简单的dfs，这里需要考虑的是最多有几种方案，因为题目说n最大5000，但是从题目意思可知，美味程度最大是30.数据量较小，如果非要说确定的话，3的10次方，最多开6w即可。",[134,289,292],{"className":290,"code":291,"language":139,"meta":140},[137],"\n#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint n,ans; //n表示需要的美味程度\nint a[10000][10],cmp[10];\n\nvoid dfs(int id,int degree){//id表示接下来考虑的是哪种配料，degree表示目前的美味程度\n    if(id > 10 || degree > n) return;\n    \n    if(id == 10 && degree == n){\n        for(int i = 0; i \u003C 10;i++) a[ans][i] = cmp[i];\n        ans++;\n    }\n    \n    for(int i = 1; i \u003C= 3; i ++){\n        cmp[id] = i;\n        dfs(id + 1,degree + i);//无需恢复现场，因为下次的值会覆盖\n    }\n}\n\nint main()\n{\n    cin >> n;\n    dfs(0,0);\n    cout \u003C\u003C ans \u003C\u003C endl;\n    if(ans){\n        for(int i = 0; i \u003C ans ;i++)\n        {\n            for(int j = 0; j \u003C 10; j ++) cout \u003C\u003C a[i][j] \u003C\u003C \" \";\n            cout \u003C\u003C endl;\n        }\n    }\n    return 0;\n}\n\n",[129,293,291],{"__ignoreMap":140},[10,295,297],{"id":296},"p1618三连击","P1618三连击",[134,299,302],{"className":300,"code":301,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint a,b,c;\nint used[10],m[10];//used用来标识数字是否用过，a用来存每一位上放的数字\nbool ans = false;\nint seg(int w){//w能取1、2、3\n    int num = 0;\n    for(int i = 3*w - 2;i \u003C= 3*w;i++){\n        num *= 10;\n        num += m[i]; //就是将对应的前三位，中三位，后三位取出来\n    }\n    return num;\n}\n\n//一共9个数\nvoid dfs(int id){//id表示接下来考虑的是第几位\n    if(id > 10) return;\n    if(id == 10){\n        if(seg(1)*b == seg(2)*a && seg(1)*c == seg(3)*a){\n            ans = true;\n            cout \u003C\u003C seg(1) \u003C\u003C \" \" \u003C\u003C seg(2) \u003C\u003C \" \" \u003C\u003C seg(3) \u003C\u003C endl;\n            return;\n        }\n    }\n    \n    for(int i = 1; i \u003C= 9;i++){\n        if(!used[i]){\n            m[id] = i;\n            used[i] = 1;\n            dfs(id+1);\n            used[i] = 0;\n        }\n    }\n}\n\nint main()\n{\n    cin >> a >> b >> c;\n    dfs(1);\n    if(!ans){\n        cout \u003C\u003C \"No!!!\";\n    }\n    return 0;\n}\n",[129,303,301],{"__ignoreMap":140},[10,305,307],{"id":306},"p1036选数","P1036选数",[109,309,310,311,225],{},"该题的关键是选出数的组合不能重复，即",[112,312,313],{},"位置不同也不行",[109,315,316],{},"如1 、2、3和2、1、3是同一种",[109,318,319],{},"因此要设置一个参数来控制选数的顺序，每次选的时候只从他后面选，即可。",[134,321,324],{"className":322,"code":323,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 30;\nint q[N],ans,k,n;\n\nbool iszs(int x){\n    if(x == 0 || x == 1) return false;\n    if(x == 2) return true;\n    \n    for(int i = 2; i \u003C x;i++){\n        if(x % i == 0) return false;\n    }\n    return true;\n}\n\nvoid dfs(int id,int sum,int order){\n    if(id == k){\n        if(iszs(sum)) ans++;\n        return;\n    }\n    \n    for(int i = order;i \u003C n; i ++)\n        dfs(id+1, sum + q[i],i + 1);\n}\n\nint main()\n{\n    cin >> n >> k;\n    for(int i = 0; i \u003C n;i++) cin >> q[i];\n    dfs(0,0,0);\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,325,323],{"__ignoreMap":140},[10,327,329],{"id":328},"p1088火星人","P1088火星人",[109,331,332],{},"该题的意思就是从给定的一个全排列，顺序往下m个，然后输出他。那么在写的时候按全排列写即可，第一次直接定位到输入的全排列即可",[134,334,337],{"className":335,"code":336,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 10010;\nint n, m, ans, flag; //n表示总共几个数排列，m表示要加上的数，ans表示方案数\nint a[N];\nbool used[N];\n\nvoid dfs(int u)//接下来考虑第几个数\n{\n    if(flag == 1) return ;\n    if(u > n)\n    {\n        ans++;\n        if(ans == m + 1) \n        {\n            for(int i = 1; i \u003C= n; i ++) cout \u003C\u003C a[i] \u003C\u003C ' ';\n            flag = 1;\n        }\n        return ;    \n    }\n    \n    for(int i = 1; i \u003C= n; i ++)\n    {\n        if(ans == 0) i = a[u];//将输入的作为排列起点\n        if(!used[i])\n        {\n            a[u] = i;\n            used[i] = 1;\n            dfs(u + 1);\n            a[u] = 0;\n            used[i] = 0;\n            \n        }\n    }\n}\n\nint main()\n{\n    cin >> n >> m;\n    for(int i = 1; i \u003C= n; i ++) cin >> a[i];\n    \n    dfs(1);\n    return 0;\n}\n",[129,338,336],{"__ignoreMap":140},[10,340,342],{"id":341},"p3799小y拼木棒","P3799小Y拼木棒",[134,344,347],{"className":345,"code":346,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n#define int long long\n        \nusing namespace std;\nconst int mod = 1e9 + 7,N = 1e5 + 10;\nint num[N];\nint n,ans;\n        \nsigned main()\n{   \n    cin >> n;\n    int Min = INT_MAX,Max = INT_MIN;\n    for(int i = 0; i \u003C n; i ++) {\n        int a;\n        cin >> a;\n        num[a]++;\n        Min = min(Min,a);\n        Max = max(Max,a);\n    }\n    //先选两根相同的，再选出两根使这两根的长度之和与先前选出的相同\n    for(int i = Min + 1; i \u003C= Max;i++){\n        if(num[i] >= 2){ \n            for(int j = Min; j \u003C= i / 2; j ++){\n                if(j != i - j)\n                    ans += num[i] * (num[i] - 1) *num[j] * num[i - j] / 2 % mod;//只有之前的两根相同，用公式cn2\n                else if(num[j] >= 2 && 2*j == i)\n                    ans += num[i] * (num[i] - 1) * num[j] * (num[j] - 1) / 4 % mod;//剩下的两根也想相同\n            }\n            ans %= mod;//if里只能保证每次加的不超过mod，但是加完之后ans可能超过，因此要mod\n        }\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n}\n",[129,348,346],{"__ignoreMap":140},[10,350,352],{"id":351},"p1044栈","P1044栈",[134,354,357],{"className":355,"code":356,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 20;\nint a[2*N][N];\nint n;\n\nint dfs(int k,int num){//k表示当前是第几次操作，num表示当前栈内元素个数\n    int t = 0;\n    if(k == 2*n){\n        if(num == 0) return 1;//是合法序列\n        else return 0;//不是合法序列\n    }\n    if(a[k][num] != 0) return a[k][num];//如果之前计算过,直接返回  \n    if(num \u003C n) t += dfs(k + 1,num + 1); //栈未满可以push\n    if(num > 0) t += dfs(k + 1,num - 1); //栈内有元素可pop\n    a[k][num] += t;//记录当前状态的计算结果\n    return t; //当前k,num状态下,有多少种合法序列#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 20;\nint a[2*N][N];\nint n;\n\nint dfs(int k,int num){//k表示当前是第几次操作，num表示当前栈内元素个数\n    int t = 0;\n    if(k == 2*n){\n        if(num == 0) return 1;//是合法序列\n        else return 0;//不是合法序列\n    }\n    if(a[k][num] != 0) return a[k][num];//如果之前计算过,直接返回  \n    if(num \u003C n) t += dfs(k + 1,num + 1); //栈未满可以push\n    if(num > 0) t += dfs(k + 1,num - 1); //栈内有元素可pop\n    a[k][num] += t;//记录当前状态的计算结果\n    return t; //当前k,num状态下,有多少种合法序列\n}\nint main()\n{\n    cin >> n;\n    cout \u003C\u003C dfs(0,0);\n    return 0;\n}\n}\nint main()\n{\n    cin >> n;\n    cout \u003C\u003C dfs(0,0);\n    return 0;\n}\n",[129,358,356],{"__ignoreMap":140},[105,360,361],{"id":361},"写递归的要点",[109,363,364,367],{},[112,365,366],{},"明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，"," 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。",[105,369,370],{"id":370},"算法1-4递推与递归",[10,372,374],{"id":373},"p1464记忆化搜索","P1464记忆化搜索",[134,376,379],{"className":377,"code":378,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\n#define int long long\n\nint d[25][25][25];\n\nint w(int a,int b,int c){\n    if(a \u003C= 0 || b \u003C= 0 || c \u003C= 0) return 1;\n    if(a > 20 || b > 20 || c > 20) return w(20,20,20);\n    if(a \u003C b && b \u003C c )\n    {\n        if(!d[a][b][c-1]) d[a][b][c-1] = w(a,b,c-1);\n        if(!d[a][b-1][c-1]) d[a][b-1][c-1] = w(a,b-1,c-1);\n        if(!d[a][b-1][c]) d[a][b-1][c] = w(a,b-1,c);\n        d[a][b][c] = d[a][b][c-1] + d[a][b-1][c-1] -  d[a][b-1][c];\n    }else{\n        if(!d[a-1][b][c]) d[a-1][b][c] = w(a-1,b,c);\n        if(!d[a-1][b-1][c]) d[a-1][b-1][c] = w(a-1,b-1,c);\n        if(!d[a-1][b][c-1]) d[a-1][b][c-1] = w(a-1,b,c-1);\n        if(!d[a-1][b-1][c-1]) d[a-1][b-1][c-1] = w(a-1,b-1,c-1);\n        d[a][b][c] = d[a-1][b][c] + d[a-1][b-1][c] + d[a-1][b][c-1] - d[a-1][b-1][c-1];\n    }   \n    return d[a][b][c];\n}\n\nsigned main()\n{\n    int a,b,c;\n    while(scanf(\"%lld%lld%lld\",&a,&b,&c)){\n        if(a == -1 && b == -1 && c == -1) break;\n        int ans = w(a,b,c);\n        printf(\"w(%lld, %lld, %lld) = %lld\\n\",a,b,c,ans);\n    }\n    return 0;\n}\n",[129,380,378],{"__ignoreMap":140},[10,382,384],{"id":383},"p1928-外星密码","P1928 外星密码",[134,386,389],{"className":387,"code":388,"language":139,"meta":140},[137],"#include \u003Cbits/stdc++.h>\n\nusing namespace std;\n\nstring dg() { // 解压缩函数\n    int k;//压缩的次数\n    char ch;//输入的字符\n    string s = \"\", str = \"\";//s是最终答案，str是被压缩的字串\n    \n    //cin >> ch 会跳过空格和换行符\n    while (cin.get(ch)) { //用cin.get()读取字符,避免跳过空格和换行\n        if (ch == '[') {//如果找到了被压缩的字串\n            cin >> k; // 读取压缩次数\n            str = dg(); // 递归调用\n            while (k--) {\n                s += str;//把解压后的字串复制k次后添加到原来的字符串上\n            }\n        } else if (ch == ']') {//如果找到了压缩的字串的末尾\n            return s; // 结束这一层递归并返回已经解压的字符串\n        } else {\n            s += ch;//直接在最后添上这个字符。\n        }\n    }\n    \n    return s; // 确保函数有返回值\n}\n\nint main() {\n    cout \u003C\u003C dg();\n    return 0;\n}\n",[129,390,388],{"__ignoreMap":140},[10,392,394],{"id":393},"p1255-数楼梯","P1255 数楼梯",[134,396,399],{"className":397,"code":398,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint n,len = 1,arr[5010][5010];//arr[k][i]第k阶台阶所对应的走法,len表示位数 \n\nvoid highadd(int k)//第k阶台阶,高精度加法 \n{\n    for(int i = 1; i \u003C= len; i ++)\n        arr[k][i] = arr[k-1][i] + arr[k-2][i];//第k阶的方法等于一次走一步+一次性走两步的 \n        \n    for(int i = 1; i \u003C= len; i ++)\n    {\n        if(arr[k][i] >= 10)\n        {\n            arr[k][i+ 1] += arr[k][i] / 10;//进位\n            arr[k][i] %= 10;\n            if(arr[k][len + 1] != 0) len++;//如果最高位有进位，那么位数➕➕\n        }\n     } \n } \n\nint main()\n{\n    cin >> n;\n    arr[1][1] = 1, arr[2][1] = 2;//初始化\n    \n    for(int i = 3; i \u003C= n; i ++)//从3开始避免越界 \n        highadd(i);\n        \n    for(int i = len; i >= 1; i --) cout \u003C\u003C arr[n][i]; ////逆序输出  \n    return 0;\n    \n } \n",[129,400,398],{"__ignoreMap":140},[10,402,404],{"id":403},"p2437-蜜蜂路线","P2437 蜜蜂路线",[109,406,407],{},"和数楼梯思路一样，只不过要上的阶数是n-m。",[10,409,411],{"id":410},"p1164-小a点菜","P1164 小A点菜",[109,413,414,417],{},[112,415,416],{},"暴力dfs版本","(果然TLE了)",[134,419,422],{"className":420,"code":421,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\n\nint f[110];//存储菜的价格\nint n,m,used[110],ans;\n\nvoid dfs(int id,int num){//id表示当前考虑的是第几个菜品，num表示当前的菜钱\n    if(id == n)\n    {\n        if(num == m) ans++;\n        return;\n    }\n    \n    dfs(id+1,num + f[id]);//直接dfs会超时\n    dfs(id+1,num);\n}\n\nint main()\n{\n    cin >> n >> m;\n    for(int i = 0; i \u003C n; i ++) cin >> f[i];\n    dfs(0,0);\n    cout \u003C\u003C ans;\n    return 0;\n}\n",[129,423,421],{"__ignoreMap":140},[109,425,426],{},[112,427,428],{},"动态规划正解",[109,430,431,432,436],{},"这是一道简单的动规题，定义f[i]",[433,434,435],"span",{},"j","为用前i道菜用光j元钱的办法总数，其状态转移方程如下：",[109,438,439,440,442,443,445],{},"（1）if(j==第i道菜的价格)f[i]",[433,441,435],{},"=f[i-1]",[433,444,435],{},"+1;",[109,447,448,449,442,451,453,454,457],{},"（2）if(j>第i道菜的价格) f[i]",[433,450,435],{},[433,452,435],{},"+f[i-1]",[433,455,456],{},"j-第i道菜的价格",";",[109,459,460,461,442,463,457],{},"（3）if(j\u003C第i道菜的价格) f[i]",[433,462,435],{},[433,464,435],{},[109,466,467,468,471,472,475],{},"说的简单一些，这三个方程，",[112,469,470],{},"每一个都是在吃与不吃之间抉择","。若钱充足，办法总数就等于吃这道菜的办法数与不吃这道菜的办法数之和；若不充足，办法总数就只能承袭吃前i-1道菜的办法总数。依次递推，在最后，我们只要输出f[n]",[433,473,474],{},"m","的值即可。",[134,477,480],{"className":478,"code":479,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint f[110][10010];//f[i][j]表示前i道菜(包括第i道),花费j元的方案数\nint a[110];//存储菜的单价\n\nint main()\n{\n    int n,m;\n    cin >> n >> m;\n    for(int i = 1; i \u003C= n; i ++) cin >> a[i];\n    for(int i = 1; i \u003C= n; i ++)\n        for(int j = 1; j \u003C= m; j ++){//每种的方案数等于前i-1种选与不选的方案数之和\n            if(j > a[i]) f[i][j] = f[i-1][j] + f[i-1][j - a[i]];\n            else if(j == a[i]) f[i][j] = f[i-1][j] + 1;\n            else f[i][j] = f[i-1][j];\n        }\n    cout \u003C\u003C f[n][m];\n    return 0;\n}\n",[129,481,479],{"__ignoreMap":140},[10,483,485],{"id":484},"p1990-覆盖墙壁","P1990 覆盖墙壁",[109,487,488,489,492],{},"G",[433,490,491],{},"N","：铺满前 N 列墙，且第 N+1列有一个单元被覆盖的方案数，且不考虑第N+1列的格子是上还是下！！",[109,494,495,496,499,500,502,503,506,507,510,511,513,514,516,517,519,520,522,523,502,525,527,528,530,531,533,534,536],{},"F",[433,497,498],{},"2","=2,F",[433,501,498],{}," = F",[433,504,505],{},"1","+F",[433,508,509],{},"0","+2*G",[433,512,509],{},", F",[433,515,505],{}," = 1, F",[433,518,509],{}," = 1，所以G",[433,521,509],{}," = 0，又因为G",[433,524,505],{},[433,526,509],{}," + G",[433,529,509],{},",所以G",[433,532,505],{}," = 1. F",[433,535,509],{}," = 1即什么都不放也是一种方案。",[109,538,495,539,541,542,545],{},[433,540,491],{},"表示",[112,543,544],{},"铺满","前N*2的面积的墙的方案数.",[109,547,495,548,550],{},[433,549,491],{},"的转移方程就是：",[109,552,553,566,567,569,570,573],{},[112,554,495,555,557,558,506,561,510,564],{},[433,556,491],{},"=F",[433,559,560],{},"N-1",[433,562,563],{},"N-2",[433,565,563],{},"（别忘了前面讲过G",[433,568,563],{},"的情况有",[112,571,572],{},"两种","）",[109,575,576,577,550,579,225],{},"而G",[433,578,491],{},[112,580,488,581,557,583,585,586],{},[433,582,491],{},[433,584,560],{},"+G",[433,587,560],{},[109,589,590,591,593,594,596,597,599,600,602],{},"初始化：F",[433,592,509],{},"=1,G",[433,595,509],{},"=0;F",[433,598,505],{},"=G",[433,601,505],{},"=1;",[109,604,605],{},[606,607],"img",{"alt":608,"src":609},"image-20250404091917380","https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404091917380.png",[109,611,612],{},"但是，L形的瓷砖又怎么办呢？",[109,614,615],{},[616,617,618],"del",{},"（呵呵，刚开始想到这里的时候，我自己都蒙了。）",[109,620,621,622,573],{},"为了方便大家思考，我们先往简单的方向想。（",[112,623,624],{},"以下是重点！！！",[186,626],{},[109,628,629,630,632],{},"我们可以用一个数组G",[433,631,491],{},"来表示**铺满前(N+1)*2的面积的墙，但是第(N+1)列有一个瓷砖已经被铺过（注意，是已经被铺过！）**的方案数。",[109,634,635],{},"所以，L形瓷砖的问题就已经被“初步”解决了。",[109,637,638,639,641],{},"所以，下面这种情况的方案数就是G",[433,640,563],{},"（因为实际上第N列已经铺满了，所以这里要处理的是前N-1列墙，所以多减了1）（如下图所示）:",[109,643,644],{},[606,645],{"alt":646,"src":647},"image-20250404092007618","https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404092007618.png",[134,649,652],{"className":650,"code":651,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int mod = 10000, N = 1e6 + 10;\nint f[N],g[N];\n\nint main()\n{\n    int n;\n    cin >> n;\n    f[0] = 1;\n    f[1] = g[1] = 1;\n    for(int i = 2; i \u003C= n; i ++){\n        f[i] = (f[i-1] + f[i-2] + 2*g[i-2]) % mod;\n        g[i] = (g[i-1] + f[i-1]) % mod; \n    }\n    cout \u003C\u003C f[n];\n    return 0;\n}\n",[129,653,651],{"__ignoreMap":140},[10,655,657],{"id":656},"p3612-secret-cow-code-s","P3612 Secret cow code S",[109,659,660],{},"先看样例",[109,662,663,664,668],{},"cOW*−>",[665,666,667],"em",{},"cOW WcO","−>*cOWWcO OcOWWc",[109,670,671],{},"我们把这三个字符串编号为1,2,3",[109,673,674],{},"现在我们要求第8位，假如我们已经知道在3串，能否逆推出在第2串中的位置呢?如果能，似乎问题就迎刃而解了,因为2逆推到1也是一个相同的子问题。",[109,676,677,678,681],{},"题目的古怪要求复制要先复制最后一个字符，再复制前缀，我们姑且",[112,679,680],{},"先直接复制前缀",".",[109,683,684],{},"cOW−>cOW  cOW*−>*cOWcOW  cOWcOW",[109,686,687,688,691],{},"现在求3串的8位置，3串长L,逆推回2串即为8−",[665,689,690],{},"L","/2位置",[109,693,694,695,698,699,701],{},"但我们复制的时候是先复制最后一个字符,所以要",[112,696,697],{},"多减一","为8−1−",[665,700,690],{},"/2",[109,703,704,705,708],{},"特别的,如果求的n刚好是先复制原串的",[112,706,707],{},"最后一个位置",",特殊处理",[109,710,711],{},"因为如果是原串的最后一个位置，假设原串长为L，则复制后的串为2L，若位置x - L / 2 - 1 == 0 即是原串的最后一个位置，则将他赋值为i",[134,713,716],{"className":714,"code":715,"language":139,"meta":140},[137],"#include \u003Cbits/stdc++.h>\nusing namespace std;\nstring s;\nlong long n,num,i;\nint main()\n{\n    cin>>s>>n;\n    num=s.length(); //求出原串的长度\n    while(num\u003Cn)//n表示要求字符的位置\n    {\n        i=num;\n        while(n>i)  i*=2;//求出当前刚好包括n位置的串长 \n        i=i/2;//得到当前串的一半长 \n        \n        n-=(i+1); \n        if(n==0)    n=i;//即上一个串的最后一个位置\n    }\n    cout\u003C\u003Cs[n-1];\n    return 0;\n}\n",[129,717,715],{"__ignoreMap":140},[10,719,721],{"id":720},"p1259-黑白棋子的移动","P1259 黑白棋子的移动",[109,723,724],{},"最左边的o*与空位交换 然后空位再和最右边连续**的最后**两个交换",[109,726,727,728,731,732,735],{},"但是注意当",[112,729,730],{},"o*与空位交换之后","，连续的白棋",[112,733,734],{},"只剩三个","的时候规律发生了变化，此时直接打表。",[134,737,740],{"className":738,"code":739,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 210;\nchar a[N];\nint n;\nstring db[4] = {\"ooo*o**--*\", \"o--*o**oo*\", \"o*o*o*--o*\", \"--o*o*o*o*\"};//无规律的\n\nvoid out()\n{\n    for(int i = 1; i \u003C= 2*n+2;i++) cout \u003C\u003C a[i];\n    cout \u003C\u003C endl;\n}\n\nvoid move(int start,int endi)\n{\n    swap(a[start],a[endi]);\n    swap(a[start+1],a[endi+1]);\n    out();\n}\n\nint main()\n{\n    cin >> n;\n    for(int i = 1; i \u003C= n;i++) a[i] = 'o';\n    for(int i = n+1; i \u003C= 2*n;i++) a[i] = '*';\n    a[2*n + 1] = a[2*n + 2] = '-';\n    \n    out();//输出起始序列\n    int len = n;//需要移动的黑/白棋\n    while(true)\n    {\n        move(len,2*len + 1);//空位和o*交换\n        len--;\n        if(len == 3) break;\n        move(len + 1,2*len + 1);\n    }\n    string ss;\n    for (int i = 0; i \u003C n - 4; i++)\n        ss += \"o*\";\n    for (int i = 0; i \u003C 4; i++)\n        cout \u003C\u003C db[i] \u003C\u003C ss \u003C\u003C endl;\n    return 0;\n}\n",[129,741,739],{"__ignoreMap":140},[10,743,745],{"id":744},"p1010幂次方","P1010幂次方",[134,747,750],{"className":748,"code":749,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint n;\n\nvoid recur(int x)//分解x使其表示为2和2(0)的组合\n{\n    for(int i = 14; i >= 0;i--)\n    {\n        if(pow(2,i) \u003C= x)\n        {\n            if(i == 1) cout \u003C\u003C \"2\";//2(1)不用再往后分解了且2^1输出为2,单独出来\n            else if(i == 0) cout \u003C\u003C \"2(0)\";//2(0)也不用再往后分解了,单独出来\n            else{//指数不是这两种情况则还得分解\n                cout \u003C\u003C\"2(\";\n                recur(i);\n                cout \u003C\u003C \")\";\n            }\n            x -= pow(2,i);\n            if(x != 0) cout \u003C\u003C \"+\";//加号处理的最简单方法:若此x还没分解完,则后面还有项,所以输出一个+号\n            \n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    recur(n);\n    return 0;\n}\n",[129,751,749],{"__ignoreMap":140},[10,753,755],{"id":754},"p1228-地毯填补问题","P1228 地毯填补问题",[109,757,758],{},"棋盘是如何划分的：",[760,761,762,772],"ol",{},[17,763,764,765,768,769,225],{},"设当前棋盘的左上角坐标为 ",[129,766,767],{"code":767},"(a, b)","，边长为 ",[129,770,771],{"code":771},"l",[17,773,774,775,778,779],{},"该棋盘被划分成四个 ",[129,776,777],{"code":777},"l/2 × l/2"," 的小棋盘：\n",[14,780,781,797,809,821],{},[17,782,783,784,787,788,791,787,794],{},"左上角子棋盘范围：\n",[112,785,786],{},"横坐标："," ",[129,789,790],{"code":790},"[a, a + l/2 - 1]",[112,792,793],{},"纵坐标：",[129,795,796],{"code":796},"[b, b + l/2 - 1]",[17,798,799,800,787,802,804,787,806],{},"右上角子棋盘范围： ",[112,801,786],{},[129,803,790],{"code":790},[112,805,793],{},[129,807,808],{"code":808},"[b + l/2, b + l - 1]",[17,810,811,812,787,814,817,787,819],{},"左下角子棋盘范围： ",[112,813,786],{},[129,815,816],{"code":816},"[a + l/2, a + l - 1]",[112,818,793],{},[129,820,796],{"code":796},[17,822,823,824,787,826,828,787,830],{},"右下角子棋盘范围： ",[112,825,786],{},[129,827,816],{"code":816},[112,829,793],{},[129,831,808],{"code":808},[109,833,834,835,838,839,842],{},"void dfs(ll x, ll y, ll a,ll b, ll l)//",[112,836,837],{},"(x,y)是障碍点",",",[112,840,841],{},"(a,b)是当前棋盘的左上角坐标",",l是棋盘边长",[109,844,845,846,849],{},"初看这个问题，似乎无从下手，于是我们可以先考虑最简单的情况，既",[112,847,848],{},"n = 2","时",[109,851,852,853,856,857],{},"0 0 0 1 这时，",[112,854,855],{},"无论公主在哪个格子","，",[112,858,859],{},"我们都可以用一块毯子填满",[109,861,862],{},"继续考虑n = 4的情况",[109,864,865],{},"我们已经知道了解决2 * 2的格子中有一个障碍的情况如何解决，因此我们可以尝试构造这种情况",[109,867,868,869,872,873,876,877,880],{},"首先，显然可以将4 * 4的盘面划分成",[112,870,871],{},"4个2 * 2的小盘面","，其中",[112,874,875],{},"一块","已经",[112,878,879],{},"存在一个障碍","了",[109,882,883,884,887,888],{},"而我们只需在正中间的2 * 2方格中放入一块地毯，就可以使",[112,885,886],{},"所有","小盘面",[112,889,890],{},"都有一个障碍",[109,892,893],{},"于是，n = 4的情况就解决了",[109,895,896],{},"我们可以将n = 4时的解法可以推广到一般情况，既当n = 2 k时，我们均可以将问题划分为4个n = 2 k – 1的子问题，然后分治解决即可。",[134,898,901],{"className":899,"code":900,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nll x,y; //x,y表示公主坐标\n\nint k; //表示迷宫规格\n\nvoid dfs(ll x, ll y, ll a,ll b, ll l)//(x,y)是障碍点,(a,b)是当前棋盘的左上角坐标,l是棋盘边长\n{\n    if(l == 1) return ;//棋盘的大小是1×1,无法再继续拆分\n    if(x - a  + 1\u003C= l / 2&& y - b + 1\u003C= l / 2)//则在左上角\n    {\n        printf(\"%lld %lld 1\\n\",a + l/2,b + l/2);//则需在中心放置1号地毯,这里坐标是毯子的拐角\n        dfs(x,y,a,b,l/2);//递归处理左上角\n        dfs(a + l/2-1 , b+ l/2    , a         , b + l/2   ,l/2);//右上角\n        dfs(a + l/2   , b+ l/2 - 1, a + l/2   , b         ,l/2);//左下角   \n        dfs(a + l/2   , b+ l/2    , a + l/2   , b + l/2   ,l/2);//右下角\n    }\n    else if(x - a  + 1 \u003C= l / 2&& y - b + 1 > l / 2)//在右上角\n    {\n        printf(\"%lld %lld 2\\n\",a + l/2,b + l/2 - 1);//则需在中心放置2号地毯\n        dfs(a + l/2-1,b + l/2-1,a,b,l/2);//递归处理左上角\n        dfs(x,y,a,b+l/2,l/2);//右上角\n        dfs(a + l/2,b+ l/2 - 1, a + l/2, b,l/2);//左下角   \n        dfs(a + l/2, b+ l/2, a + l/2, b + l/2,l/2);//右下角\n    }\n    else if(x - a  + 1 > l / 2&& y - b + 1 \u003C= l / 2)//左下角\n    {\n        printf(\"%lld %lld 3\\n\",a + l/2 - 1,b + l/2);//则需在中心放置3号地毯\n        dfs(a + l/2-1,b + l/2-1,a,b,l/2);//递归处理左上角\n        dfs(a+l/2-1,b+l/2,a,b+l/2,l/2);//右上角\n        dfs(x,y,a+l/2,b,l/2);//左下角  \n        dfs(a + l/2, b+ l/2, a + l/2, b + l/2,l/2);//右下角\n    }\n    else\n    {\n        printf(\"%lld %lld 4\\n\",a + l/2 - 1,b + l/2-1);//则需在中心放置3号地毯\n        dfs(a + l/2-1,b + l/2-1,a,b,l/2);//递归处理左上角\n        dfs(a+l/2-1,b+l/2,a,b+l/2,l/2);//右上角\n        dfs(a+l/2,b+l/2-1,a+l/2,b,l/2);//左下角    \n        dfs(x,y, a + l/2, b + l/2,l/2);//右下角\n    }\n}\n\nint main()\n{\n    cin >> k >> x >> y;\n    dfs(x,y,1,1,pow(2,k));\n    return 0;\n}\n",[129,902,900],{"__ignoreMap":140},[10,904,906],{"id":905},"p1498-南蛮图腾","P1498 南蛮图腾",[134,908,911],{"className":909,"code":910,"language":139,"meta":140},[137],"for(int j=i;j>0;j--)a[j]^=a[j-1];//修改数组\n",[129,912,910],{"__ignoreMap":140},[109,914,915,918],{},[112,916,917],{},"动态生成分形图案的每一行状态",",它本质上是在模拟杨辉三角（Pascal's Triangle）的生成过程，但只关心每个位置的奇偶性（用异或运算实现）。",[109,920,921],{},[112,922,923],{},"为什么倒序更新？",[109,925,926,927,930],{},"假设我们有一个数组 ",[129,928,929],{"code":929},"a = [1, 1, 0, 1]","，想要生成下一行：",[14,932,933,943],{},[17,934,935,938,939,942],{},[112,936,937],{},"正序更新","（从左到右）：会",[112,940,941],{},"覆盖前面的值","，导致后续计算错误。",[17,944,945,948],{},[112,946,947],{},"倒序更新","（从右到左）：先处理高位，保留低位未修改的值，确保计算的正确性。",[109,950,951],{},"例如，生成杨辉三角第3行（索引从0开始）：",[14,953,954,964],{},[17,955,956,957,960,961,573],{},"原数组：",[129,958,959],{"code":959},"[1, 2, 1]","（但这里只关心奇偶性，实际存储的是 ",[129,962,963],{"code":963},"[1, 0, 1]",[17,965,966],{},"生成第4行时，需要从右向左更新，避免覆盖前一行数据。",[134,968,971],{"className":969,"code":970,"language":139,"meta":140},[137],"#include\u003Ciostream>\nusing namespace std;\nint n,a[1030]={1};//初始化数组,第一个元素为1,其余为0\n\nint main(){\n    cin>>n;\n    for(int i=0;i\u003C1\u003C\u003Cn;i++){//共2的n次方行\n        for(int j=1;j\u003C(1\u003C\u003Cn)-i;j++)cout\u003C\u003C\" \";//前导空格,1-2^n-1,1-2^n-2...\n        \n        for(int j=i;j>0;j--)a[j]^=a[j-1];//修改数组\n        if(!(i%2))for(int j=0;j\u003C=i;j++)cout\u003C\u003C(a[j]?\"/\\\\\":\"  \");//奇数行,2个空格,1个0等于2个空格\n        else for(int j=0;j\u003C=i;j+=2)cout\u003C\u003C(a[j]?\"/__\\\\\":\"    \");//偶数行,4个空格\n        cout\u003C\u003Cendl;\n    }\n    return 0;\n}\n",[129,972,970],{"__ignoreMap":140},[105,974,975],{"id":975},"算法1-5贪心",[109,977,978],{},[112,979,980],{},"总结",[109,982,983,984,987,988,991],{},"贪心的题一般会进行",[112,985,986],{},"排序","，并且多用",[112,989,990],{},"结构体","。一般是最小最大问题",[10,993,995],{"id":994},"p1223-排队接水","P1223 排队接水",[134,997,1000],{"className":998,"code":999,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint n;\nconst int N = 1010;\nstruct node{\n    double t;\n    int id;\n    bool operator\u003C(const node&W)const{\n        return t \u003C W.t;\n    }\n}a[N];\n\nint wait[N];//wait[i]表示第i人的等待时间\n\nint main()\n{\n    cin >> n;\n    double ans = 0,time = 0;//time表示等待时间\n    for(int i = 1; i \u003C= n; i ++){\n        cin >> a[i].t;\n        a[i].id = i;\n    }\n    sort(a+1,a+1+n);\n    for(int i = 1;i \u003C= n; i ++) {\n        cout \u003C\u003C a[i].id \u003C\u003C \" \";\n        time += a[i-1].t;\n        wait[i] = time;//第i人的等待时间\n        ans += wait[i];\n    }\n    cout \u003C\u003C endl;\n    printf(\"%.2f\",ans*1.0 / n);\n    return 0;\n}\n",[129,1001,999],{"__ignoreMap":140},[10,1003,1005],{"id":1004},"p1803-凌乱的yyy-线段覆盖","P1803 凌乱的yyy / 线段覆盖",[109,1007,1008,1009,1012,1013,1016],{},"这道题",[112,1010,1011],{},"贪心的思路","是每次选择",[112,1014,1015],{},"结束时间最早","的，这样能为后面留下更多的时间参赛。",[134,1018,1021],{"className":1019,"code":1020,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e6 + 10;\n\nstruct node{\n    int start,endi;\n    bool operator\u003C(const node&W)const{\n        return endi \u003C W.endi;\n    }\n}a[N];\n\nint n;\n\nint main()\n{\n    cin >> n;\n    for(int i = 0; i \u003C n;i ++) cin >> a[i].start >> a[i].endi;\n    sort(a,a+n);\n    int pre = a[0].endi;//第一个结束时间最短,一定会选上\n    int ans = 1;//记录方案数\n    \n    for(int i = 1; i \u003C n; i ++)\n    {\n        if(a[i].start >= pre)\n        {\n            ans++;\n            pre = a[i].endi;\n        }\n    }\n    \n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1022,1020],{"__ignoreMap":140},[10,1024,1026],{"id":1025},"p1090合并果子","P1090合并果子",[1028,1029,1030],"blockquote",{},[109,1031,1032],{},"复杂度是 O(n^2)超时",[109,1034,1035],{},"sort复杂度是O(nlogn)",[134,1037,1040],{"className":1038,"code":1039,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint n;//果子的种类数\ntypedef long long ll;\nll ans;\n\n\nint main()\n{\n    cin >> n;\n    vector\u003Cll> a(n);\n    for(int i = 0; i \u003C n;i++) cin >> a[i];\n    ll tmp = 0;\n    while(a.size() > 1){\n        sort(a.begin(),a.end());//集合排序使用迭代器，复杂度是O(nlogn)\n        ll tmp = a[0] + a[1];\n        a.erase(a.begin());\n        a.erase(a.begin());\n        ans += tmp;\n        a.push_back(tmp);\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1041,1039],{"__ignoreMap":140},[109,1043,1044],{},[112,1045,1046],{},"O(n)做法",[109,1048,1049],{},"🍔 先说说：什么是堆？",[14,1051,1052,1065],{},[17,1053,1054,1057,1058,1061,1062,225],{},[112,1055,1056],{},"堆","（Heap）是一种特殊的",[112,1059,1060],{},"完全二叉树","，在编程里常用来做",[112,1063,1064],{},"优先级排序",[17,1066,1067,1068],{},"有两种堆：\n",[14,1069,1070,1079],{},[17,1071,1072,1075,1076,573],{},[112,1073,1074],{},"最大堆","：顶端是最大的元素（默认的 ",[129,1077,1078],{"code":1078},"priority_queue",[17,1080,1081,1084],{},[112,1082,1083],{},"最小堆","：顶端是最小的元素（我们需要的！）",[109,1086,1087,1088,1090],{},"🧰 c++ 默认的 ",[129,1089,1078],{"code":1078}," 是最大堆",[109,1092,1093],{},"🧲 想要最小堆怎么办？",[109,1095,1096],{},"我们用这个写法：",[134,1098,1101],{"className":1099,"code":1100,"language":139,"meta":140},[137],"priority_queue\u003Cint, vector\u003Cint>, greater\u003Cint>> q;\n",[129,1102,1100],{"__ignoreMap":140},[109,1104,1105],{},"解释一下：",[14,1107,1108,1113,1119],{},[17,1109,1110,1112],{},[129,1111,114],{"code":114},"：存放的类型",[17,1114,1115,1118],{},[129,1116,1117],{"code":1117},"vector\u003Cint>","：底层容器",[17,1120,1121,1124],{},[129,1122,1123],{"code":1123},"greater\u003Cint>","：比较函数，告诉它“小的优先”，也就是最小堆！",[109,1126,1127,1128,1130],{},"🪄 你可以记住这个",[112,1129,1083],{},"模板：",[134,1132,1135],{"className":1133,"code":1134,"language":139,"meta":140},[137],"priority_queue\u003C类型, vector\u003C类型>, greater\u003C类型>> 变量名;\n",[129,1136,1134],{"__ignoreMap":140},[109,1138,1139],{},[112,1140,1141],{},"📝 总结一下",[1143,1144,1145,1161],"table",{},[1146,1147,1148],"thead",{},[1149,1150,1151,1155,1158],"tr",{},[1152,1153,1154],"th",{},"操作",[1152,1156,1157],{},"意义",[1152,1159,1160],{},"举例",[1162,1163,1164,1184,1199],"tbody",{},[1149,1165,1166,1172,1179],{},[1167,1168,1169],"td",{},[129,1170,1171],{"code":1171},"push(x)",[1167,1173,1174,1175,1178],{},"把 ",[129,1176,1177],{"code":1177},"x"," 放进堆里",[1167,1180,1181],{},[129,1182,1183],{"code":1183},"pq.push(5);",[1149,1185,1186,1191,1194],{},[1167,1187,1188],{},[129,1189,1190],{"code":1190},"pop()",[1167,1192,1193],{},"删除堆顶元素（最小值）",[1167,1195,1196],{},[129,1197,1198],{"code":1198},"pq.pop();",[1149,1200,1201,1206,1209],{},[1167,1202,1203],{},[129,1204,1205],{"code":1205},"top()",[1167,1207,1208],{},"查看堆顶元素（最小值）",[1167,1210,1211],{},[129,1212,1213],{"code":1213},"cout \u003C\u003C pq.top();",[109,1215,1216],{},[112,1217,1218],{},"仅堆顶可读",[109,1220,1221,1224,1225,1228,1229],{},[112,1222,1223],{},"贪心","思路：每次选择",[112,1226,1227],{},"最小","的两堆",[112,1230,1231],{},"进行合并",[134,1233,1236],{"className":1234,"code":1235,"language":139,"meta":140},[137],"#include \u003Cbits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n    int n;\n    cin >> n;\n    priority_queue\u003Cll, vector\u003Cll>, greater\u003Cll>> pq; // 小根堆\n    for (int i = 0; i \u003C n; i++) {\n        ll x;\n        cin >> x;\n        pq.push(x);\n    }\n\n    ll ans = 0;\n    while (pq.size() > 1) {\n        ll a = pq.top(); pq.pop();\n        ll b = pq.top(); pq.pop();\n        ll sum = a + b;\n        ans += sum;\n        pq.push(sum);\n    }\n\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n\n",[129,1237,1235],{"__ignoreMap":140},[10,1239,1241],{"id":1240},"p3817-小a的糖果","P3817 小A的糖果",[109,1243,1244,1245,1248,1249,1252,1253,1256],{},"如果",[112,1246,1247],{},"相邻两个盒子糖果的数量大于 x","，就吃",[112,1250,1251],{},"右边","盒子的",[112,1254,1255],{},"糖","，否则不进行任何操作。",[109,1258,1259,1260,1263,1264,1267],{},"为什么要",[112,1261,1262],{},"吃右边盒子的糖","：这是因为如果我们吃掉左边盒子里的糖，就只会减少这一轮相邻两个盒子糖果的数量；如果我们吃掉右边盒子里的糖，那么这次操作还可以减少",[112,1265,1266],{},"下一轮相邻两个盒子糖果的数量","，符合贪心的逻辑。",[134,1269,1272],{"className":1270,"code":1271,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst int N = 1e5 + 10;\nll a[N];\n\nint main()\n{\n    int n,x;\n    cin >> n >> x;\n    for(int i = 1; i \u003C= n;i++) cin >> a[i];\n    ll ans = 0;\n    for(int i = 1; i \u003C= n;i++) //正好利用a[0] = 0\n    {\n        if(a[i-1] + a[i] > x)//如果超了，则吃掉右边多余的糖果\n        {\n            ans += a[i-1] + a[i] - x;\n            a[i] = x - a[i-1];\n        }\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1273,1271],{"__ignoreMap":140},[10,1275,1277],{"id":1276},"p1106-删数问题","P1106 删数问题",[109,1279,1280],{},"sort函数的用法",[109,1282,1283],{},"默认是从小到大排序，如果要从大到小排序，则可写成如下格式：",[134,1285,1288],{"className":1286,"code":1287,"language":139,"meta":140},[137],"sort(a,a+len,greater\u003Cint>());\n",[129,1289,1287],{"__ignoreMap":140},[109,1291,1292],{},"重点是原左右次序",[109,1294,1295,1296],{},"🧠 我们先说 ",[112,1297,1298],{},"string 的 erase 用法",[134,1300,1303],{"className":1301,"code":1302,"language":139,"meta":140},[137],"string str = \"abcdef\";\nstr.erase(pos, len);  // 从 pos的索引位置开始，删除 len 个字符\n",[129,1304,1302],{"__ignoreMap":140},[109,1306,1307,1308],{},"✅ 示例 3：只给一个参数，删除从",[112,1309,1310],{},"这个位置到末尾",[134,1312,1315],{"className":1313,"code":1314,"language":139,"meta":140},[137],"string str = \"abcdef\";\nstr.erase(3); // 删除从索引3开始（含）之后的所有字符\ncout \u003C\u003C str;  // 输出 abc\n",[129,1316,1314],{"__ignoreMap":140},[109,1318,1319,1320,1323],{},"🧠 vector 的 ",[129,1321,1322],{"code":1322},"erase"," 用法也很类似",[109,1325,1326],{},"这里只给一个参数，只能删除给定位置索引的元素，不会删后面的",[134,1328,1331],{"className":1329,"code":1330,"language":139,"meta":140},[137],"vector\u003Cint> v = {1, 2, 3, 4, 5};\nv.erase(v.begin() + 2); // 删除索引为 2 的元素（也就是 3）\n",[129,1332,1330],{"__ignoreMap":140},[109,1334,1335,1336,1339],{},"你也可以删除一个范围：(",[112,1337,1338],{},"含头不含尾",")",[134,1341,1344],{"className":1342,"code":1343,"language":139,"meta":140},[137],"v.erase(v.begin() + 1, v.begin() + 4); // 删除 2~4（含头不含尾），结果是 {1, 5}\n",[129,1345,1343],{"__ignoreMap":140},[109,1347,1348,1349,1352,1353,1356],{},"贪心的思想是每次",[112,1350,1351],{},"删除","数字中的",[112,1354,1355],{},"极大值","！",[109,1358,1359],{},[112,1360,1361],{},"❓ 你想让一个数变小，怎么做？",[109,1363,1364],{},"从左到右，先比较高位！",[14,1366,1367,1370,1376],{},[17,1368,1369],{},"最高位大 → 整体大",[17,1371,1372,1373],{},"所以你想尽早删掉一个",[112,1374,1375],{},"大数",[17,1377,1378,1379,1382,1383,1385],{},"如果你删的是",[112,1380,1381],{},"左边","的“高位的",[112,1384,1375],{},"”，整体数就更小",[109,1387,1388,1389,1356],{},"所以：\n",[112,1390,1391],{},"从左往右找到第一个比后面大的数，删掉它，最有“贡献”",[134,1393,1396],{"className":1394,"code":1395,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\nusing namespace std;\nint main(){\n    string n;\n    int s,i;\n    cin>>n>>s;\n    while(s){\n        for(i=0;n[i]\u003C=n[i+1] && i + 1 \u003C n.size();)//找极大值\n            i++;\n        n.erase(i,1);//删除函数,就是从第i个位置连续删1个。如果不清楚删除函数，可以百度。\n        s--;\n    }\n    while(n[0]=='0'&&n.size()>1){//处理前导零，注意如果长度是1就不能再删了。\n        n.erase(0,1);\n    }\n    cout\u003C\u003Cn;\n    return 0;\n}\n",[129,1397,1395],{"__ignoreMap":140},[109,1399,1400],{},[112,1401,1402],{},"解法二：",[134,1404,1407],{"className":1405,"code":1406,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint a[260];\nbool flag;//用来标识是否全为0\n\nint main()\n{\n    string n;\n    int k;\n    cin >> n >> k;\n    \n    for(int i = 1; i \u003C= n.size();i++) a[i] = n[i-1] - '0';\n    int aim = n.size() - k,now = 0,tmp = 1,minp = 0;//tmp表示当前序列的起点\n    while(now \u003C aim)\n    {\n        minp = tmp;\n        for(int i = tmp;i \u003C= k + tmp;i++) if(a[minp] > a[i]) minp = i;//到k+tmp之间有k个数足够删除\n        if(a[minp]) flag = true;//不为0的话\n        if(flag) cout \u003C\u003C a[minp]; //首位特判，首位非0后面则输出\n        k -= minp - tmp;//表示删除了几个数\n        tmp = minp + 1;//下次从选了的数后面开始\n        now++;//当前选了的数加1\n    }\n    \n    if(!flag) cout \u003C\u003C 0;//如果一直是0的话\n    \n    return 0;\n}\n",[129,1408,1406],{"__ignoreMap":140},[10,1410,1412],{"id":1411},"p1478-陶陶摘苹果","P1478 陶陶摘苹果",[109,1414,1415],{},"贪心的思路是先取花费力气少的，留下更多的力气去拿后面的。",[134,1417,1420],{"className":1418,"code":1419,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nstruct node{\n    int x,y;//分别是高度和力气\n    bool operator\u003C(const node&W)const{\n        return y \u003C W.y;\n    }\n}arr[5010];\n\nint main()\n{\n    int n,s;\n    cin >> n >> s;\n    int a,b;\n    cin >> a >> b;//椅子高度和手伸直长度\n    \n    if(n == 0){cout \u003C\u003C 0; return  0;}\n    \n    for(int i = 0; i \u003C n; i ++) cin >> arr[i].x >> arr[i].y;\n    \n    sort(arr,arr+n);\n    int i = 0,sum = a + b,ans = 0;\n    \n    while(true)\n    {\n        if(arr[i].x \u003C= sum && s >= arr[i].y){\n            ans++;\n            s -= arr[i].y;\n        }\n        else if(s \u003C arr[i].y || s \u003C 0) break;\n        i++;\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1421,1419],{"__ignoreMap":140},[10,1423,1425],{"id":1424},"p5019-铺设道路","P5019 铺设道路",[109,1427,1428],{},[112,1429,1430],{},"贪心的核心思想：",[14,1432,1433,1456],{},[17,1434,1435,1446,1447,1449,1450,1452,1453,225],{},[112,1436,1437,1438,1441,1442,1445],{},"如果 ",[129,1439,1440],{"code":1440},"a[i]"," 比 ",[129,1443,1444],{"code":1444},"a[i-1]"," 大","：那么我们知道从 ",[129,1448,1444],{"code":1444}," 到 ",[129,1451,1440],{"code":1440}," 之间的差就是需要额外填充的部分，因此我们加上 ",[129,1454,1455],{"code":1455},"a[i] - a[i-1]",[17,1457,1458,1465],{},[112,1459,1437,1460,1441,1462,1464],{},[129,1461,1440],{"code":1440},[129,1463,1444],{"code":1444}," 小","：这个时候，我们不需要额外填充，只要关注前一个坑即可，因为当前坑已经被前一个坑的操作填补掉了。",[109,1467,1468],{},[112,1469,1470],{},"为什么贪心是对的：",[14,1472,1473,1483],{},[17,1474,1437,1475,1441,1477,1479,1480,1482],{},[129,1476,1440],{"code":1440},[129,1478,1444],{"code":1444}," 大，直接填充当前的差值 ",[129,1481,1455],{"code":1455},"，这相当于我们处理一个新坑的深度。",[17,1484,1437,1485,1441,1487,1489],{},[129,1486,1440],{"code":1440},[129,1488,1444],{"code":1444}," 小，那么前一个坑已经处理过它并填充了这个部分，当前坑不需要额外的操作。",[134,1491,1494],{"className":1492,"code":1493,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\nint a[N],ans;//ans表示答案\n\nint main()\n{\n    int n;\n    cin >> n;\n    for(int i = 1; i \u003C= n; i ++){\n        cin >> a[i];\n        ans += max(a[i] - a[i-1],0);//当前坑需要填的深度\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1495,1493],{"__ignoreMap":140},[10,1497,1499],{"id":1498},"p1208mixing-milk","P1208Mixing Milk",[134,1501,1504],{"className":1502,"code":1503,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e6 + 10;\n\nstruct node{\n    int p,num;\n    bool operator\u003C(const node&W)const{\n        return p \u003C W.p;\n    }\n}a[N];\n\nint main()\n{\n    int n,m;\n    cin >>n >> m;\n    for(int i = 0; i \u003C m;i ++) cin >> a[i].p >> a[i].num;\n    int now = 0,ans = 0;\n    int i = 0,need = n;\n    sort(a,a+m);\n\n    while(now != n)\n    {\n        int tmp = (a[i].num >= need ? need:a[i].num);\n//      cout \u003C\u003C \"tmp=\" \u003C\u003C tmp \u003C\u003C endl;\n        ans += tmp * a[i].p;\n        now += tmp;\n        need -= tmp;\n        i++;\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1505,1503],{"__ignoreMap":140},[10,1507,1509],{"id":1508},"p1094-纪念品分组","P1094 纪念品分组",[109,1511,1512,1513,1515,1516,1519,1520,1522,1523,1525],{},"我们先将数据进行排序，然后维护两个变量 ",[665,1514,1177],{}," 和 ",[665,1517,1518],{},"y","，让 ",[665,1521,1177],{}," 指向开头，让 ",[665,1524,1518],{}," 指向结尾。",[109,1527,1528],{},"一直循环，过程中会出现两种情况。",[760,1530,1531,1544],{},[17,1532,1533,1534,1537,1538,1540,1541,1543],{},"如果当前两个变量所指的两个数之和小于或等于 ",[665,1535,1536],{},"w","，说明可行，就把它们两个分为一组，同时将 ",[665,1539,1177],{}," 加 1，将 ",[665,1542,1518],{}," 减 1，并将答案加 1，这是第一种情况。",[17,1545,1546,1547,1549,1550,1552],{},"如果当前两个变量所指的两个数之和大于 ",[665,1548,1536],{},"，说明不可行，只将 ",[665,1551,1518],{}," 减 1，同时答案加 1 即可，这是第二种情况。",[109,1554,1555,1556,1558,1559,1561],{},"重复以上过程，直到 ",[665,1557,1177],{},">",[665,1560,1518],{}," 时停止循环。",[134,1563,1566],{"className":1564,"code":1565,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 3e4 + 10;\nint a[N],used[N];\nint ans;\n\nusing namespace std;\nint main()\n{\n    int w,n;\n    cin >> w >> n;\n    for(int i = 1; i \u003C= n; i ++) cin >> a[i];\n    \n    sort(a+1,a+n+1);\n    int i = 1, j = n;\n    while(i \u003C= j)\n    {\n        if(a[i] + a[j] > w) j--;\n        else i++,j--;\n        ans++;      \n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1567,1565],{"__ignoreMap":140},[10,1569,1571],{"id":1570},"p4995-跳跳","P4995 跳跳！",[109,1573,1574,1575,1577],{},"记得开",[112,1576,122],{},"，因为hi最大可能为1e4，平方完1e8，继续加可能爆int",[134,1579,1582],{"className":1580,"code":1581,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 310;\nint a[N];\ntypedef long long ll;\n\nint main()\n{\n    int n;\n    cin >> n;\n    for(int i = 1; i \u003C= n; i ++) cin >> a[i];\n    \n    sort(a,a+n+1);\n//  for(int i = 0; i \u003C= n;i ++) cout \u003C\u003C a[i] \u003C\u003C ' ';\n    ll ans = 0,num = 0,i = 0,j = n;\n    while(i \u003C= j){\n        ans += pow(a[j] - a[i],2);//向右跳\n        i++,j--;\n    }\n    i = 1, j = n;\n    while(i \u003C= j)\n    {\n        ans += pow(a[j] - a[i],2);//向左跳\n        i++,j--;\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    return 0;\n}\n",[129,1583,1581],{"__ignoreMap":140},[109,1585,1586,1587,1590],{},"更",[112,1588,1589],{},"便捷","的写法：",[134,1592,1595],{"className":1593,"code":1594,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\nusing namespace std;\nunsigned long long ans=0;\nint h[330];\nbool sum=0;\nsigned main()\n{\n    int n;\n    cin>>n;\n    for (int i=1;i\u003C=n;i++) cin >> h[i];\n    sort(h+1,h+n+1);\n    int j=0,hpast=0; //j表示当前取的石头位置，hpast是上一次跳的石头高度\n    for (int i=1;i\u003C=n;i++)\n    {\n        j=n-j+sum;// 交替：n-j 是从另一边开始，+sum 是让左右交替\n        sum=!sum;\n        ans+=(h[j]-hpast)*(h[j]-hpast);\n        hpast=h[j];\n    }\n    cout\u003C\u003Cans;\n    return 0;\n}\n",[129,1596,1594],{"__ignoreMap":140},[10,1598,1600],{"id":1599},"p4447-分组","P4447 分组",[109,1602,1603,1604,1607,1608,1611,1612,1615,1616,1619,1620,1623],{},"在 c++ 中，",[129,1605,1606],{"code":1606},"map"," 是一个非常常用的 ",[112,1609,1610],{},"关联容器","，定义在 ",[129,1613,1614],{"code":1614},"\u003Cmap>"," 头文件中。它是 ",[112,1617,1618],{},"STL（标准模板库）"," 的一部分，提供了 ",[112,1621,1622],{},"键值对（key-value）"," 的数据结构",[109,1625,1626],{},[112,1627,1628],{},"🌟 简要定义",[134,1630,1633],{"className":1631,"code":1632,"language":139,"meta":140},[137],"std::map\u003CKeyType, ValueType>\n",[129,1634,1632],{"__ignoreMap":140},[14,1636,1637,1647],{},[17,1638,1639,1642,1643,1646],{},[129,1640,1641],{"code":1641},"KeyType","：键的类型（必须支持 ",[129,1644,1645],{"code":1645},"\u003C"," 比较）",[17,1648,1649,1652],{},[129,1650,1651],{"code":1651},"ValueType","：值的类型",[109,1654,1655,1657,1658,1661,1662,1665,1666,1668],{},[129,1656,1606],{"code":1606}," 会 ",[112,1659,1660],{},"自动按照 key 排序","，通常是按",[112,1663,1664],{},"升序","排列（默认使用 ",[129,1667,1645],{"code":1645}," 运算符）。",[109,1670,1671],{},[112,1672,1673],{},"🔧 常用操作",[1143,1675,1676,1688],{},[1146,1677,1678],{},[1149,1679,1680,1682,1685],{},[1152,1681,1154],{},[1152,1683,1684],{},"示例",[1152,1686,1687],{},"说明",[1162,1689,1690,1707,1723,1735,1748,1761],{},[1149,1691,1692,1695,1704],{},[1167,1693,1694],{},"插入",[1167,1696,1697,1700,1701],{},[129,1698,1699],{"code":1699},"m[\"key\"] = value;"," 或 ",[129,1702,1703],{"code":1703},"m.insert({key, value});",[1167,1705,1706],{},"插入或修改元素",[1149,1708,1709,1712,1717],{},[1167,1710,1711],{},"查找",[1167,1713,1714],{},[129,1715,1716],{"code":1716},"m.find(key)",[1167,1718,1719,1720],{},"返回迭代器，指向元素；若不存在，返回 ",[129,1721,1722],{"code":1722},"m.end()",[1149,1724,1725,1727,1732],{},[1167,1726,1351],{},[1167,1728,1729],{},[129,1730,1731],{"code":1731},"m.erase(key);",[1167,1733,1734],{},"删除指定 key 的元素",[1149,1736,1737,1740,1745],{},[1167,1738,1739],{},"判断是否存在",[1167,1741,1742],{},[129,1743,1744],{"code":1744},"m.count(key)",[1167,1746,1747],{},"返回 0 或 1（map 不允许重复键）",[1149,1749,1750,1753,1758],{},[1167,1751,1752],{},"大小",[1167,1754,1755],{},[129,1756,1757],{"code":1757},"m.size()",[1167,1759,1760],{},"元素个数",[1149,1762,1763,1766,1771],{},[1167,1764,1765],{},"清空",[1167,1767,1768],{},[129,1769,1770],{"code":1770},"m.clear()",[1167,1772,1773],{},"删除所有元素",[109,1775,1776],{},[112,1777,1778],{},"✅ 正确写法回顾",[134,1780,1783],{"className":1781,"code":1782,"language":139,"meta":140},[137],"std::map\u003Cint, int> m;\nauto i = m.begin();\n// 第一种写法（解引用 + 点）\n(*i).second--;\n// 第二种写法（推荐，简洁）\ni->second--;\n",[129,1784,1782],{"__ignoreMap":140},[134,1786,1789],{"className":1787,"code":1788,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\n\nmap\u003Cint,int> m;\n\nint main()\n{\n    int n, ans = INT_MAX;\n    cin >> n;\n    for(int i = 0; i \u003C n; i ++) {int t;cin >> t;m[t] ++;}\n    \n    while (!m.empty())\n    {\n        auto i = m.begin(), j = m.begin();  // 使用 auto推导迭代器类型\n        i->second--;  // 已经画线，所以下面找递增是大于\n        int t = 1;// 若 i, j 所对应的能力值是连续的，且i对应的那一列高度不高于j，则继续画线\n        for (++j; j != m.end() && j->first == i->first + 1 && j->second > i->second; i++, j++) {\n            t++;\n            j->second--;\n        }\n        i = m.begin();\n        while (i != m.end() && i->second == 0) m.erase(i++->first);  // 删除画完线高度为0的元素\n        \n        if (t \u003C ans) ans = t;  //动态记录画线过程中的最小值\n    }\n    cout \u003C\u003C ans \u003C\u003C endl;\n    \n    return 0;\n}\n",[129,1790,1788],{"__ignoreMap":140},[10,1792,1794],{"id":1793},"p1080-国王游戏","P1080 国王游戏",[109,1796,1797],{},[606,1798],{"alt":1799,"src":1800},"image-20250408144329517","https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250408144329517.png",[109,1802,1803,1804,1806],{},"**ans",[433,1805,505],{},"是最高位,**高位在前,低位在后",[109,1808,1809,1810,1806],{},"**p",[433,1811,505],{},[109,1813,1814,787,1819,1822],{},[112,1815,1816,1817],{},"sum",[433,1818,505],{},[112,1820,1821],{},"是最低位","，低位在前，高位在后",[109,1824,1825],{},[112,1826,1827],{},"✅ 对比总结一下",[1143,1829,1830,1846],{},[1146,1831,1832],{},[1149,1833,1834,1837,1840,1843],{},[1152,1835,1836],{},"数组",[1152,1838,1839],{},"用途",[1152,1841,1842],{},"低位",[1152,1844,1845],{},"高位",[1162,1847,1848,1870,1890],{},[1149,1849,1850,1854,1860,1865],{},[1167,1851,1852],{},[129,1853,1816],{"code":1816},[1167,1855,1856,1857,573],{},"当前正在参与计算的数（",[665,1858,1859],{},"参与乘法和除法",[1167,1861,1862],{},[129,1863,1864],{"code":1864},"sum[1]",[1167,1866,1867],{},[129,1868,1869],{"code":1869},"sum[m]",[1149,1871,1872,1877,1880,1885],{},[1167,1873,1874],{},[129,1875,1876],{"code":1876},"ans",[1167,1878,1879],{},"每次除法的结果",[1167,1881,1882],{},[129,1883,1884],{"code":1884},"ans[ls]",[1167,1886,1887],{},[129,1888,1889],{"code":1889},"ans[1]",[1149,1891,1892,1896,1899,1904],{},[1167,1893,1894],{},[129,1895,109],{"code":109},[1167,1897,1898],{},"最终记录的最大结果",[1167,1900,1901],{},[129,1902,1903],{"code":1903},"p[lp]",[1167,1905,1906],{},[129,1907,1908],{"code":1908},"p[1]",[109,1910,1911],{},"所以这份代码内部其实用了两种顺序：",[14,1913,1914,1920],{},[17,1915,1916,1919],{},[112,1917,1918],{},"计算时","（如乘法）用“低位在前”顺序（便于进位）",[17,1921,1922,1925],{},[112,1923,1924],{},"结果保存/比较/输出时","用“高位在前”顺序（符合人类习惯）",[134,1927,1930],{"className":1928,"code":1929,"language":139,"meta":140},[137],"#include \u003Cbits/stdc++.h>\nusing namespace std;\n\nint n, a, b, m;             // m 表示 sum 的有效位最大下标\nint p[1010], lp = 0;        // p 存当前最大值结果，高精度整数，lp 是最大下标\nint sum[1010];              // sum 存当前乘积，高精度整数\nint ans[1010], ls = 0;      // ans 存除法结果临时数组，ls 是最大下标\nint res;                    // 除法中保存的余数\n\nstruct node {\n    int a, b;\n    bool operator\u003C(const node &W) const {\n        return a * b \u003C W.a * W.b;\n    }\n} arr[1010];\n\nbool compare() {\n    int i = 0, j = 0;\n    while (i \u003C= lp && p[i] == 0) i++;  // 去除 p 的前导 0\n    while (j \u003C= ls && ans[j] == 0) j++;  // 去除 ans 的前导 0\n    \n    int len1 = lp - i + 1;\n    int len2 = ls - j + 1;\n    if (len1 > len2) return false;\n    if (len1 \u003C len2) return true;\n    \n    while (i \u003C= lp && j \u003C= ls) {\n        if (p[i] \u003C ans[j]) return true;\n        if (p[i] > ans[j]) return false;\n        i++;\n        j++;\n    }\n    return false;\n}\n\nvoid cheng(int d) {\n    for (int i = 0; i \u003C= m; i++) sum[i] *= arr[d].a;\n    for (int i = 0; i \u003C= m; i++) {\n        sum[i + 1] += sum[i] / 10000;\n        sum[i] %= 10000;\n    }\n    if (sum[m + 1] != 0) m++;\n}\n\nvoid div(int d) {\n    memset(ans, 0, sizeof(ans));\n    ls = 0;\n    while (m >= 0 && sum[m] == 0) m--;  // 去掉前导0\n    res = 0;\n    int flag = 0;\n    for (int i = m; i >= 0; i--) {\n        res = res * 10000 + sum[i];\n        ans[++ls] = res / arr[d].b;\n        if (ans[ls] == 0 && !flag) ls--;  // 不保留前导 0\n        else flag = 1;\n        res %= arr[d].b;\n    }\n}\n\nint main() {\n    cin >> n >> a >> b;\n    for (int i = 0; i \u003C n; i++) cin >> arr[i].a >> arr[i].b;\n    sort(arr, arr + n);\n    \n    m = 0;\n    memset(sum, 0, sizeof(sum));\n    sum[0] = a;\n    \n    for (int i = 0; i \u003C n; i++) {\n        div(i);  // 先除\n        if (compare()) {\n            lp = ls;\n            memcpy(p, ans, sizeof(ans));\n        }\n        cheng(i);  // 再乘\n    }\n    \n    int i = 0;\n    while (i \u003C= lp && p[i] == 0) i++;  // 去前导0\n    if (i > lp) {  // 全是0\n        printf(\"0\\n\");\n        return 0;\n    }\n    \n    printf(\"%d\", p[i++]);\n    for (; i \u003C= lp; i++) {\n        printf(\"%04d\", p[i]);  // 补足4位\n    }\n    printf(\"\\n\");\n    return 0;\n}\n",[129,1931,1929],{"__ignoreMap":140},[105,1933,1934],{"id":1934},"算法1-7搜索",[10,1936,1938],{"id":1937},"p1135-奇怪的电梯","P1135 奇怪的电梯",[109,1940,1941],{},[112,1942,1943,1944,1947],{},"1. ",[129,1945,1946],{"code":1946},"memset(dist, 0x3f, sizeof(dist))"," 实际干了啥？",[14,1949,1950,1968],{},[17,1951,1952,1955,1956,1959,1960,1963,1964,1967],{},[129,1953,1954],{"code":1954},"memset"," 会把内存中每个 ",[112,1957,1958],{},"字节","（byte）都设成 ",[129,1961,1962],{"code":1962},"0x3f","（也就是十进制的 ",[129,1965,1966],{"code":1966},"63","）。",[17,1969,1970,1971,1973,1974,225],{},"而一个 ",[129,1972,114],{"code":114}," 在 c++ 中通常是 ",[112,1975,1976],{},"4 个字节（32 位）",[109,1978,1979],{},[112,1980,1981,1982,1984],{},"所以，每个 ",[129,1983,114],{"code":114}," 被填成：",[134,1986,1989],{"className":1987,"code":1988,"language":139,"meta":140},[137],"0x3f3f3f3f\n",[129,1990,1988],{"__ignoreMap":140},[134,1992,1995],{"className":1993,"code":1994,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 210;\nint k[N],dist[N];\nint n,a,b;\n\n\nvoid dfs(int id,int step)//id表示当前在几楼,step表示到该楼的最小步数\n{\n    dist[id] = step;\n    int nextid = id - k[id];\n    if(nextid >= 1 && step + 1 \u003C dist[nextid]) dfs(nextid,step + 1);//下，注意剪枝\n    \n    nextid = id + k[id];\n    if(nextid \u003C= n && step + 1 \u003C dist[nextid]) dfs(nextid,step + 1);//上\n    return;\n}\n\nint main()\n{\n    memset(dist,0x3f,sizeof(dist));\n    cin >> n >> a >> b;\n    for(int i = 1; i \u003C= n; i ++) cin >> k[i];\n    dfs(a,0);\n    if(dist[b] == 0x3f3f3f3f) cout \u003C\u003C -1;\n    else cout \u003C\u003C dist[b];\n    return 0;\n}\n",[129,1996,1994],{"__ignoreMap":140},[10,1998,2000],{"id":1999},"p1219八皇后-checker-challenge","P1219八皇后 checker challenge",[134,2002,2005],{"className":2003,"code":2004,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint a[20][20];//棋盘\nint ans;\nint col[20],dg[40],udg[40];\nint n;\nint path[20];\n\nvoid dfs(int id)//当前在考虑第几行\n{\n    if(id == n + 1)\n    {\n        ans++;\n        if(ans \u003C= 3) {\n            for(int i = 1; i \u003C= n;i++) cout \u003C\u003C path[i] \u003C\u003C \" \";\n            cout \u003C\u003C endl;\n        }\n    }\n    \n    for(int i = 1; i \u003C= n; i ++) //考虑id行i列\n    {\n        if(!col[i] && !dg[id + i] && !udg[i - id + n])\n        {\n            col[i] = dg[id + i] = udg[i - id + n] = 1;\n            path[id] = i;\n            dfs(id + 1);\n            col[i] = dg[id + i] = udg[i - id + n] = 0;\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    \n    dfs(1);\n    cout \u003C\u003C ans;\n    return 0;\n}\n",[129,2006,2004],{"__ignoreMap":140},[10,2008,2010],{"id":2009},"p1443-马的遍历","P1443 马的遍历",[109,2012,2013,2014],{},"✅ ",[112,2015,2016],{},"宽度优先搜索（BFS）特别适合用来找“无权图”的最短路！",[109,2018,2019],{},"🧠 为什么？",[109,2021,2022,2023,2026],{},"因为 BFS 是",[112,2024,2025],{},"一层一层扩展的","，它保证了：",[1028,2028,2029],{},[109,2030,2031],{},[112,2032,2033],{},"第一次到达某个点的时候，所走的步数就是最短的。",[134,2035,2038],{"className":2036,"code":2037,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\n# define PII pair\u003Cint,int>\nusing namespace std;\n\nqueue\u003CPII> q;//queue是先进先出\nint f[410][410];//存到某点的最短步数\nbool vis[410][410];//保存是否走过\n\nint dx[8] = {-2,-1,1,2, 2, 1,-1,-2};\nint dy[8] = { 1, 2,2,1,-1,-2,-2,-1};\nint n,m,x,y;\n\nint main()\n{\n    cin >> n >> m >> x >> y;\n    memset(f,-1,sizeof(f));\n    memset(vis,false,sizeof(vis));\n    \n    f[x][y] = 0;\n    vis[x][y] = true;\n    q.push({x,y});\n    \n    while(!q.empty())\n    {\n        int xi = q.front().first,yi = q.front().second;\n        q.pop();\n        for(int i = 0; i \u003C 8; i ++){\n            int u = xi + dx[i], v = yi + dy[i];\n            if(u \u003C 1 || u > n || v \u003C 1 || v > m || vis[u][v]) continue;\n            vis[u][v] = true;\n            q.push({u,v});\n            f[u][v] = f[xi][yi] + 1;\n        }\n    }\n    for(int i = 1; i \u003C= n;i++){\n        for(int j = 1; j \u003C= m; j ++) cout \u003C\u003C f[i][j] \u003C\u003C \" \";\n        cout \u003C\u003C endl;\n    }\n        \n    return 0;\n}\n",[129,2039,2037],{"__ignoreMap":140},[109,2041,2042,2045,2046],{},[112,2043,2044],{},"dfs","结果",[112,2047,2048],{},"超时",[134,2050,2053],{"className":2051,"code":2052,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint path[410][410];//表示最短距离\n\nint px[8] = {-2,-1,1,2, 2, 1,-1,-2};\nint py[8] = { 1, 2,2,1,-1,-2,-2,-1};\nint n,m,x,y;\n\nbool iscan(int x,int y)\n{\n    if(x \u003C 1 || x > n || y \u003C 1 || y > m) return false;\n    return true;\n}\n\nvoid dfs(int xi,int yi,int step)//表示当前所在的位置,以及到该点用了几步\n{\n    path[xi][yi] = step;\n    for(int i = 0; i \u003C 8;i++)\n    {\n        if(iscan(xi+px[i],yi+py[i]) && step + 1 \u003C path[xi + px[i]][yi+py[i]]) \n            dfs(xi + px[i],yi+py[i],step + 1);\n    }\n    return ;\n}\n\nint main()\n{\n    memset(path,0x3f,sizeof(path));\n    cin >> n >> m >> x >> y;\n    dfs(x,y,0);\n    for(int i = 1; i \u003C= n; i ++)\n    {\n        for(int j = 1; j \u003C= m;j++) \n        {\n            if(path[i][j] == 0x3f3f3f3f) cout \u003C\u003C -1 \u003C\u003C \" \";\n            else cout \u003C\u003C path[i][j] \u003C\u003C \" \";\n        }\n        cout \u003C\u003C endl;\n    }\n        \n    \n    return 0;\n}\n",[129,2054,2052],{"__ignoreMap":140},[10,2056,2058],{"id":2057},"p2895-meteor-shower-s","P2895 Meteor Shower S",[109,2060,2061],{},[112,2062,2063],{},"✅ 那为什么 BFS 要判断“有没有走过”呢？",[109,2065,2066],{},"因为——",[1028,2068,2069],{},[109,2070,2071],{},[112,2072,2073],{},"BFS 是一层一层地找最短路的，如果一个点你已经访问过，说明你之前已经用更短的时间走到它了！现在再来一次，就是浪费时间，还可能是“更慢的路径”。",[134,2075,2078],{"className":2076,"code":2077,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\n#define PII pair\u003Cint,int>\nint n;\nint a[310][310];//记录陨石砸落时间\nint vis[310][310];//记录是否走过\nint x,y,t;//陨石坐标，砸落时间\nint dist[310][310]; //记录到达某点的最短时间\n\nint dx[5]={0,0,0,1,-1};//方便移动和处理陨石砸落\nint dy[5]={0,1,-1,0,0};\n\nint ch(int x){//判断路过该点时是否陨石已经砸落，如果是没有陨石，相当于n年后砸落\n    if (x==-1) return 99999;\n    else return x;\n}\n\nvoid sign(int i,int t)//标记陨石的下落时间\n{\n    if(x + dx[i] >= 0 && y + dy[i] >= 0 && (a[x + dx[i]][y + dy[i]] == -1 || a[x + dx[i]][y + dy[i]] > t))\n        a[x + dx[i]][y + dy[i]] = t;\n}\n\nint main()\n{\n    cin >> n;\n    memset(a,-1,sizeof(a));//陨石砸落时间初始化\n    for(int i = 1; i \u003C= n; i++){\n        cin >> x >> y >> t;\n        for(int i = 0; i \u003C 5; i ++) sign(i,t);\n    }\n    \n    queue\u003CPII> q;\n    vis[0][0] = true;\n    q.push({0,0});\n    while(!q.empty())\n    {\n        int x = q.front().first,y = q.front().second;\n        q.pop();\n        int s = dist[x][y] + 1;//下一格子到达的时间等于当前格子加1\n        if(a[x][y] == -1){\n            cout \u003C\u003C s - 1;\n            return 0;\n        }\n        for(int i = 1; i \u003C= 4; i ++)\n        {\n            int xi = x + dx[i],yi = y + dy[i];\n            if(xi >= 0 && yi >= 0 && s \u003C ch(a[xi][yi]) && vis[xi][yi] == 0)//在边界内\n            //且下一时刻陨石没下楼且没被访问\n            {\n                q.push({xi,yi});\n                vis[xi][yi] = 1;\n                dist[xi][yi] = s;\n            }\n        }\n    }\n    cout \u003C\u003C -1 \u003C\u003C endl;\n    return 0;\n}\n",[129,2079,2077],{"__ignoreMap":140},[105,2081,2083],{"id":2082},"算法2-1前缀和差分与离散化","算法2-1前缀和、差分与离散化",[10,2085,2087],{"id":2086},"p8218-求区间和","P8218 求区间和",[134,2089,2092],{"className":2090,"code":2091,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nconst int N = 1e5 + 10;\nint a[N];\n\nint main()\n{\n    int n,m;\n    cin >> n;\n    for(int i = 1; i \u003C= n; i ++) cin >> a[i],a[i] += a[i-1];//a[i]表示的是截止到i为止的和\n    cin >> m;\n    for(int i = 0; i \u003C m;i++)\n    {\n        int c,d;\n        cin >> c >> d;\n        cout \u003C\u003C a[d] - a[c-1] \u003C\u003C endl;\n    }\n    return 0;\n}\n",[129,2093,2091],{"__ignoreMap":140},[105,2095,2096],{"id":2096},"动态规划1",[10,2098,2100],{"id":2099},"p2196-挖地雷","P2196 挖地雷",[109,2102,2103],{},[112,2104,2105],{},"暴力DFS写法",[134,2107,2110],{"className":2108,"code":2109,"language":139,"meta":140},[137],"#include\u003Cbits/stdc++.h>\n\nusing namespace std;\nint a[30][30];//表示地窖之间的连接情况,1表示有连接\nint path[30],ans;//存放最终结果的路径数组,最终的地雷数\nint tempath[30],temp;//中间变量\nint used[30];//是否用过\nint passby;//表示走过的地窖数\nint pass_ans;//表示最终走过的地窖数\n\nint n;//表示地窖数\nint num[30];//表示地窖内的地雷数组\n\nbool isconnect(int id)//判断是否还有路径\n{\n    for(int i = 1;i \u003C= n;i++)\n        if(a[id][i] && !used[i]) return true;\n    return false;\n}\n\nvoid dfs(int id)//当前准备进入的地窖是id号地窖\n{\n    if(!isconnect(id)) //没连接返回\n    {\n        if(temp > ans)//找到了更多地雷的方案\n        {\n            ans = temp;\n            pass_ans = passby;\n            for(int i = 1; i \u003C= passby;i++) path[i] = tempath[i];\n        }\n        return ;\n    }\n    \n    for(int i = 1; i \u003C= n;i++)\n    {\n        if(a[id][i] && !used[i])\n        {\n            used[i] = 1;//该地窖走过了\n            passby++;//走过的地窖数➕➕\n            tempath[passby] = i;\n            temp += num[i];\n            \n            dfs(i);//去该地窖\n            \n            used[i] = 0;\n            tempath[passby] = 0;\n            passby--;\n            temp -= num[i];\n        }\n    }\n}\n\nint main()\n{\n    cin >> n;\n    for(int i = 1; i \u003C= n;i++) cin >> num[i];\n    for(int i = 1; i \u003C= n - 1;i++)//共n-1行\n    {\n        int index = i + 1,t;\n        for(int j = 1; j \u003C= n - i;j++) {cin >> t; a[i][index] = t;\n            index++;\n        }   \n    }\n        \n    for(int i = 1; i \u003C= n;i++)//因为起点不一定是1,所以每个起点都遍历一下\n    {\n        used[i] = 1;\n        passby = 0;\n        tempath[++passby] = i;\n        temp += num[i];\n        dfs(i);\n        temp -= num[i];\n        used[i] = 0;\n        \n    }\n    for(int i = 1; i \u003C= pass_ans;i++) cout \u003C\u003C path[i] \u003C\u003C \" \";\n    cout \u003C\u003C endl \u003C\u003C ans\u003C\u003C endl;\n    return 0;\n}\n",[129,2111,2109],{"__ignoreMap":140},[105,2113,2115],{"id":2114},"ac贪心","Ac贪心:",[109,2117,2118,2121],{},[129,2119,2120],{"code":2120},"memcpy"," 的正确用法是：",[134,2123,2126],{"className":2124,"code":2125,"language":139,"meta":140},[137],"void *memcpy(void *dest, const void *src, size_t n);\n",[129,2127,2125],{"__ignoreMap":140},[109,2129,2130],{},"也就是：",[134,2132,2135],{"className":2133,"code":2134,"language":139,"meta":140},[137],"memcpy(目标地址, 源地址, 拷贝的字节数);\n",[129,2136,2134],{"__ignoreMap":140},{"title":140,"searchDepth":2138,"depth":2138,"links":2139},4,[2140,2142,2143,2144,2145,2146,2147,2148,2149,2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177],{"id":12,"depth":2141,"text":12},2,{"id":245,"depth":2141,"text":246},{"id":276,"depth":2141,"text":277},{"id":296,"depth":2141,"text":297},{"id":306,"depth":2141,"text":307},{"id":328,"depth":2141,"text":329},{"id":341,"depth":2141,"text":342},{"id":351,"depth":2141,"text":352},{"id":373,"depth":2141,"text":374},{"id":383,"depth":2141,"text":384},{"id":393,"depth":2141,"text":394},{"id":403,"depth":2141,"text":404},{"id":410,"depth":2141,"text":411},{"id":484,"depth":2141,"text":485},{"id":656,"depth":2141,"text":657},{"id":720,"depth":2141,"text":721},{"id":744,"depth":2141,"text":745},{"id":754,"depth":2141,"text":755},{"id":905,"depth":2141,"text":906},{"id":994,"depth":2141,"text":995},{"id":1004,"depth":2141,"text":1005},{"id":1025,"depth":2141,"text":1026},{"id":1240,"depth":2141,"text":1241},{"id":1276,"depth":2141,"text":1277},{"id":1411,"depth":2141,"text":1412},{"id":1424,"depth":2141,"text":1425},{"id":1498,"depth":2141,"text":1499},{"id":1508,"depth":2141,"text":1509},{"id":1570,"depth":2141,"text":1571},{"id":1599,"depth":2141,"text":1600},{"id":1793,"depth":2141,"text":1794},{"id":1937,"depth":2141,"text":1938},{"id":1999,"depth":2141,"text":2000},{"id":2009,"depth":2141,"text":2010},{"id":2057,"depth":2141,"text":2058},{"id":2086,"depth":2141,"text":2087},{"id":2099,"depth":2141,"text":2100},[2179],"算法","2025-03-27 23:45:35","汇总了2025蓝桥杯突击训练过程中的经典算法题解及代码示例，涵盖暴力枚举、递归与递推、贪心算法、搜索算法等多种算法类型",false,"md","https://7.isyangs.cn/20250731/1e40d3e28e500126d257c30072340d5b.png",{},true,"/2025/lanqiao2025",{"text":2189,"minutes":2190,"time":2191,"words":2192},"51 min read",50.275,3016500,10055,null,{"title":5,"description":2181},{"loc":2187},"posts/2025/lanqiao2025",[2198,139],"蓝桥杯","lHxajDqPyeoboAy8ieRDDcNED8IbwZoIcwfqgUQ4-cM",[2201,2206],{"title":2202,"path":2203,"stem":2204,"date":2205,"type":2193,"children":-1},"Java苍穹外卖","/2025/sky_takeaway","posts/2025/Sky_takeaway","2025-03-18 21:24:59",{"title":2207,"path":2208,"stem":2209,"date":2210,"type":2193,"children":-1},"Git自动化部署","/2025/git","posts/2025/Git自动化部署","2025-07-31 19:42:40",1758973829057]