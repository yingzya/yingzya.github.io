<!DOCTYPE html><html  lang="zh-CN"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script type="importmap">{"imports":{"#entry":"/_nuxt/CuRDy5bR.js"}}</script><title>2025蓝桥杯突击训练 | 字节追风者</title><link rel="preconnect" href="https://twikoo.zhilu.cyou/"><link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin><link rel="stylesheet" href="https://lib.baomitu.com/KaTeX/0.16.9/katex.min.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://rsms.me/inter/inter.css" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://fonts.googleapis.cn/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Noto+Sans+SC:wght@100..900&family=Noto+Serif+SC:wght@200..900&display=swap" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="https://cdn-font.hyperos.mi.com/font/css?family=MiSans:100,200,300,400,450,500,600,650,700,900:Chinese_Simplify,Latin&display=swap" media="print" onload="this.media=&quot;all&quot;"><link rel="stylesheet" href="/_nuxt/entry.CbLaJWFq.css" crossorigin><link rel="stylesheet" href="/_nuxt/_...BJDcHRWl.css" crossorigin><link rel="stylesheet" href="/_nuxt/Comment.DHhhws_e.css" crossorigin><link rel="stylesheet" href="/_nuxt/ProseA.BTfGpl4j.css" crossorigin><link rel="stylesheet" href="/_nuxt/Toc.Bo4Cbq2k.css" crossorigin><link rel="stylesheet" href="/_nuxt/ZWidget.B1kbKjic.css" crossorigin><link rel="stylesheet" href="/_nuxt/ProseCode.a2_W97gt.css" crossorigin><link rel="stylesheet" href="/_nuxt/ProseTable.DQgQdj7r.css" crossorigin><style>:where(.i-ph\:align-right-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cg fill='black'%3E%3Cpath d='M184 64v40a8 8 0 0 1-8 8H80a8 8 0 0 1-8-8V64a8 8 0 0 1 8-8h96a8 8 0 0 1 8 8m-8 80H40a8 8 0 0 0-8 8v40a8 8 0 0 0 8 8h136a8 8 0 0 0 8-8v-40a8 8 0 0 0-8-8' opacity='.2'/%3E%3Cpath d='M224 40v176a8 8 0 0 1-16 0V40a8 8 0 0 1 16 0m-32 24v40a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16V64a16 16 0 0 1 16-16h96a16 16 0 0 1 16 16m-16 0H80v40h96Zm16 88v40a16 16 0 0 1-16 16H40a16 16 0 0 1-16-16v-40a16 16 0 0 1 16-16h136a16 16 0 0 1 16 16m-16 0H40v40h136Z'/%3E%3C/g%3E%3C/svg%3E")}:where(.i-ph\:archive-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M224 44H32a20 20 0 0 0-20 20v24a20 20 0 0 0 16 19.6V192a20 20 0 0 0 20 20h160a20 20 0 0 0 20-20v-84.4A20 20 0 0 0 244 88V64a20 20 0 0 0-20-20M36 68h184v16H36Zm16 120v-80h152v80Zm112-52a12 12 0 0 1-12 12h-48a12 12 0 0 1 0-24h48a12 12 0 0 1 12 12'/%3E%3C/svg%3E")}:where(.i-ph\:arrow-circle-up-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M128 20a108 108 0 1 0 108 108A108.12 108.12 0 0 0 128 20m0 192a84 84 0 1 1 84-84a84.09 84.09 0 0 1-84 84m40.49-100.49a12 12 0 0 1-17 17L140 117v51a12 12 0 0 1-24 0v-51l-11.51 11.52a12 12 0 0 1-17-17l32-32a12 12 0 0 1 17 0Z'/%3E%3C/svg%3E")}:where(.i-ph\:arrow-u-down-left-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M236 112a68.07 68.07 0 0 1-68 68H61l27.52 27.51a12 12 0 0 1-17 17l-48-48a12 12 0 0 1 0-17l48-48a12 12 0 1 1 17 17L61 156h107a44 44 0 0 0 0-88H80a12 12 0 0 1 0-24h88a68.07 68.07 0 0 1 68 68'/%3E%3C/svg%3E")}:where(.i-ph\:calendar-dots-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M208 28h-20v-4a12 12 0 0 0-24 0v4H92v-4a12 12 0 0 0-24 0v4H48a20 20 0 0 0-20 20v160a20 20 0 0 0 20 20h160a20 20 0 0 0 20-20V48a20 20 0 0 0-20-20M68 52a12 12 0 0 0 24 0h72a12 12 0 0 0 24 0h16v24H52V52ZM52 204V100h152v104Zm92-76a16 16 0 1 1-16-16a16 16 0 0 1 16 16m48 0a16 16 0 1 1-16-16a16 16 0 0 1 16 16m-96 48a16 16 0 1 1-16-16a16 16 0 0 1 16 16m48 0a16 16 0 1 1-16-16a16 16 0 0 1 16 16m48 0a16 16 0 1 1-16-16a16 16 0 0 1 16 16'/%3E%3C/svg%3E")}:where(.i-ph\:caret-double-up-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M216.49 191.51a12 12 0 0 1-17 17L128 137l-71.51 71.49a12 12 0 0 1-17-17l80-80a12 12 0 0 1 17 0Zm-160-63L128 57l71.51 71.52a12 12 0 0 0 17-17l-80-80a12 12 0 0 0-17 0l-80 80a12 12 0 0 0 17 17Z'/%3E%3C/svg%3E")}:where(.i-ph\:certificate-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M128 140a12 12 0 0 1-12 12H72a12 12 0 0 1 0-24h44a12 12 0 0 1 12 12m-12-52H72a12 12 0 0 0 0 24h44a12 12 0 0 0 0-24m120 79.14V228a12 12 0 0 1-17.95 10.42L196 225.82l-22 12.6A12 12 0 0 1 156 228v-24H40a20 20 0 0 1-20-20V56a20 20 0 0 1 20-20h176a20 20 0 0 1 20 20v32.86a55.87 55.87 0 0 1 0 78.28M196 160a32 32 0 1 0-32-32a32 32 0 0 0 32 32m-40 20v-12.86a56 56 0 0 1 56-92.8V60H44v120Zm56 27.32v-25.66a55.87 55.87 0 0 1-32 0v25.66l10.05-5.74a12 12 0 0 1 11.9 0Z'/%3E%3C/svg%3E")}:where(.i-ph\:chat-circle-text-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M172 108a12 12 0 0 1-12 12H96a12 12 0 0 1 0-24h64a12 12 0 0 1 12 12m-12 28H96a12 12 0 0 0 0 24h64a12 12 0 0 0 0-24m76-8a108 108 0 0 1-157.23 96.15L46.34 235A20 20 0 0 1 21 209.66l10.81-32.43A108 108 0 1 1 236 128m-24 0a84 84 0 1 0-156.73 42.06a12 12 0 0 1 1 9.81l-9.93 29.79l29.79-9.93a12.1 12.1 0 0 1 3.8-.62a12 12 0 0 1 6 1.62A84 84 0 0 0 212 128'/%3E%3C/svg%3E")}:where(.i-ph\:code-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M71.68 97.22L34.74 128l36.94 30.78a12 12 0 1 1-15.36 18.44l-48-40a12 12 0 0 1 0-18.44l48-40a12 12 0 0 1 15.36 18.44m176 21.56l-48-40a12 12 0 1 0-15.36 18.44L221.26 128l-36.94 30.78a12 12 0 1 0 15.36 18.44l48-40a12 12 0 0 0 0-18.44M164.1 28.72a12 12 0 0 0-15.38 7.18l-64 176a12 12 0 0 0 7.18 15.37a11.8 11.8 0 0 0 4.1.73a12 12 0 0 0 11.28-7.9l64-176a12 12 0 0 0-7.18-15.38'/%3E%3C/svg%3E")}:where(.i-ph\:envelope-simple-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M224 44H32a12 12 0 0 0-12 12v136a20 20 0 0 0 20 20h176a20 20 0 0 0 20-20V56a12 12 0 0 0-12-12m-30.85 24L128 127.72L62.85 68ZM44 188V83.28l75.89 69.57a12 12 0 0 0 16.22 0L212 83.28V188Z'/%3E%3C/svg%3E")}:where(.i-ph\:files-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='m220.49 59.51l-40-40A12 12 0 0 0 172 16H92a20 20 0 0 0-20 20v20H56a20 20 0 0 0-20 20v140a20 20 0 0 0 20 20h108a20 20 0 0 0 20-20v-20h20a20 20 0 0 0 20-20V68a12 12 0 0 0-3.51-8.49M160 212H60V80h67l33 33Zm40-40h-16v-64a12 12 0 0 0-3.51-8.49l-40-40A12 12 0 0 0 132 56H96V40h71l33 33Zm-56-28a12 12 0 0 1-12 12H88a12 12 0 0 1 0-24h44a12 12 0 0 1 12 12m0 40a12 12 0 0 1-12 12H88a12 12 0 0 1 0-24h44a12 12 0 0 1 12 12'/%3E%3C/svg%3E")}:where(.i-ph\:github-logo-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M212.62 75.17A63.7 63.7 0 0 0 206.39 26A12 12 0 0 0 196 20a63.71 63.71 0 0 0-50 24h-20a63.71 63.71 0 0 0-50-24a12 12 0 0 0-10.39 6a63.7 63.7 0 0 0-6.23 49.17A61.5 61.5 0 0 0 52 104v8a60.1 60.1 0 0 0 45.76 58.28A43.66 43.66 0 0 0 92 192v4H76a20 20 0 0 1-20-20a44.05 44.05 0 0 0-44-44a12 12 0 0 0 0 24a20 20 0 0 1 20 20a44.05 44.05 0 0 0 44 44h16v12a12 12 0 0 0 24 0v-40a20 20 0 0 1 40 0v40a12 12 0 0 0 24 0v-40a43.66 43.66 0 0 0-5.76-21.72A60.1 60.1 0 0 0 220 112v-8a61.5 61.5 0 0 0-7.38-28.83M196 112a36 36 0 0 1-36 36h-48a36 36 0 0 1-36-36v-8a37.87 37.87 0 0 1 6.13-20.12a11.65 11.65 0 0 0 1.58-11.49a39.9 39.9 0 0 1-.4-27.72a39.87 39.87 0 0 1 26.41 17.8a12 12 0 0 0 10.1 5.53h32.35a12 12 0 0 0 10.11-5.53a39.84 39.84 0 0 1 26.41-17.8a39.9 39.9 0 0 1-.4 27.72a12 12 0 0 0 1.61 11.53A37.85 37.85 0 0 1 196 104Z'/%3E%3C/svg%3E")}:where(.i-ph\:highlighter-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M252.49 107.51a12 12 0 0 0-17 0L192 151l-79-79l43.52-43.51a12 12 0 0 0-17-17L93.17 57.86a20 20 0 0 0-4.72 20.72L69.17 97.86a20 20 0 0 0 0 28.28L71 128l-55.49 55.51a12 12 0 0 0 4.7 19.87l72 24A11.8 11.8 0 0 0 96 228a12 12 0 0 0 8.49-3.52L136 193l1.86 1.86a20 20 0 0 0 28.28 0l19.27-19.27a20.3 20.3 0 0 0 6.59 1.13a19.86 19.86 0 0 0 14.14-5.86l46.35-46.34a12 12 0 0 0 0-17.01M92.76 202.27l-46.55-15.51L88 145l31 31ZM152 175l-55.51-55.48L89 112l15-15l63 63Z'/%3E%3C/svg%3E")}:where(.i-ph\:house-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='m222.14 105.85l-80-80a20 20 0 0 0-28.28 0l-80 80A19.86 19.86 0 0 0 28 120v96a12 12 0 0 0 12 12h64a12 12 0 0 0 12-12v-52h24v52a12 12 0 0 0 12 12h64a12 12 0 0 0 12-12v-96a19.86 19.86 0 0 0-5.86-14.15M204 204h-40v-52a12 12 0 0 0-12-12h-48a12 12 0 0 0-12 12v52H52v-82.35l76-76l76 76Z'/%3E%3C/svg%3E")}:where(.i-ph\:link-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M117.18 188.74a12 12 0 0 1 0 17l-5.12 5.12A58.26 58.26 0 0 1 70.6 228a58.62 58.62 0 0 1-41.46-100.08l34.75-34.75a58.64 58.64 0 0 1 98.56 28.11a12 12 0 1 1-23.37 5.44a34.65 34.65 0 0 0-58.22-16.58l-34.75 34.75A34.62 34.62 0 0 0 70.57 204a34.4 34.4 0 0 0 24.49-10.14l5.11-5.12a12 12 0 0 1 17.01 0M226.83 45.17a58.65 58.65 0 0 0-82.93 0l-5.11 5.11a12 12 0 0 0 17 17l5.12-5.12a34.63 34.63 0 1 1 49 49l-34.81 34.7A34.4 34.4 0 0 1 150.61 156a34.63 34.63 0 0 1-33.69-26.72a12 12 0 0 0-23.38 5.44A58.64 58.64 0 0 0 150.56 180h.05a58.28 58.28 0 0 0 41.47-17.17l34.75-34.75a58.62 58.62 0 0 0 0-82.91'/%3E%3C/svg%3E")}:where(.i-ph\:magnifying-glass-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M232.49 215.51L185 168a92.12 92.12 0 1 0-17 17l47.53 47.54a12 12 0 0 0 17-17ZM44 112a68 68 0 1 1 68 68a68.07 68.07 0 0 1-68-68'/%3E%3C/svg%3E")}:where(.i-ph\:monitor-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M208 36H48a28 28 0 0 0-28 28v112a28 28 0 0 0 28 28h160a28 28 0 0 0 28-28V64a28 28 0 0 0-28-28m4 140a4 4 0 0 1-4 4H48a4 4 0 0 1-4-4V64a4 4 0 0 1 4-4h160a4 4 0 0 1 4 4Zm-40 52a12 12 0 0 1-12 12H96a12 12 0 0 1 0-24h64a12 12 0 0 1 12 12'/%3E%3C/svg%3E")}:where(.i-ph\:moon-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M236.37 139.4a12 12 0 0 0-12-3A84.07 84.07 0 0 1 119.6 31.59a12 12 0 0 0-15-15a108.86 108.86 0 0 0-54.91 38.48A108 108 0 0 0 136 228a107.1 107.1 0 0 0 64.93-21.69a108.86 108.86 0 0 0 38.44-54.94a12 12 0 0 0-3-11.97m-49.88 47.74A84 84 0 0 1 68.86 69.51a84.9 84.9 0 0 1 23.41-21.22Q92 52.13 92 56a108.12 108.12 0 0 0 108 108q3.87 0 7.71-.27a84.8 84.8 0 0 1-21.22 23.41'/%3E%3C/svg%3E")}:where(.i-ph\:paragraph-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M208 36H96a68 68 0 0 0 0 136h36v36a12 12 0 0 0 24 0V60h16v148a12 12 0 0 0 24 0V60h12a12 12 0 0 0 0-24m-76 112H96a44 44 0 0 1 0-88h36Z'/%3E%3C/svg%3E")}:where(.i-ph\:rss-simple-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M228 192a12 12 0 0 1-24 0c0-77.2-62.8-140-140-140a12 12 0 0 1 0-24c90.43 0 164 73.57 164 164M64 100a12 12 0 0 0 0 24a68.07 68.07 0 0 1 68 68a12 12 0 0 0 24 0a92.1 92.1 0 0 0-92-92m4 72a16 16 0 1 0 16 16a16 16 0 0 0-16-16'/%3E%3C/svg%3E")}:where(.i-ph\:share-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='m232.49 112.49l-48 48a12 12 0 0 1-17-17L195 116h-30a84 84 0 0 0-81.36 63a12 12 0 1 1-23.24-6A107.94 107.94 0 0 1 165 92h30l-27.49-27.52a12 12 0 0 1 17-17l48 48a12 12 0 0 1-.02 17.01M192 204H44V88a12 12 0 0 0-24 0v128a12 12 0 0 0 12 12h160a12 12 0 0 0 0-24'/%3E%3C/svg%3E")}:where(.i-ph\:sidebar-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cg fill='black'%3E%3Cpath d='M88 48v160H40a8 8 0 0 1-8-8V56a8 8 0 0 1 8-8Z' opacity='.2'/%3E%3Cpath d='M216 40H40a16 16 0 0 0-16 16v144a16 16 0 0 0 16 16h176a16 16 0 0 0 16-16V56a16 16 0 0 0-16-16M40 152h16a8 8 0 0 0 0-16H40v-16h16a8 8 0 0 0 0-16H40V88h16a8 8 0 0 0 0-16H40V56h40v144H40Zm176 48H96V56h120z'/%3E%3C/g%3E%3C/svg%3E")}:where(.i-ph\:subway-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M228 96v112a12 12 0 0 1-24 0V96a52.06 52.06 0 0 0-52-52h-48a52.06 52.06 0 0 0-52 52v112a12 12 0 0 1-24 0V96a76.08 76.08 0 0 1 76-76h48a76.08 76.08 0 0 1 76 76m-40 0v72a28 28 0 0 1-18.89 26.47l2 5.07a12 12 0 0 1-6.68 15.6a11.9 11.9 0 0 1-4.43.86a12 12 0 0 1-11.14-7.54l-5-12.46h-31.74l-5 12.46A12 12 0 0 1 96 216a11.9 11.9 0 0 1-4.46-.86a12 12 0 0 1-6.68-15.6l2-5.07A28 28 0 0 1 68 168V96a28 28 0 0 1 28-28h64a28 28 0 0 1 28 28m-96 0v36h72V96a4 4 0 0 0-4-4H96a4 4 0 0 0-4 4m72 72v-12h-24v16h20a4 4 0 0 0 4-4m-48 4v-16H92v12a4 4 0 0 0 4 4Z'/%3E%3C/svg%3E")}:where(.i-ph\:sun-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M116 36V20a12 12 0 0 1 24 0v16a12 12 0 0 1-24 0m80 92a68 68 0 1 1-68-68a68.07 68.07 0 0 1 68 68m-24 0a44 44 0 1 0-44 44a44.05 44.05 0 0 0 44-44M51.51 68.49a12 12 0 1 0 17-17l-12-12a12 12 0 0 0-17 17Zm0 119l-12 12a12 12 0 0 0 17 17l12-12a12 12 0 1 0-17-17M196 72a12 12 0 0 0 8.49-3.51l12-12a12 12 0 0 0-17-17l-12 12A12 12 0 0 0 196 72m8.49 115.51a12 12 0 0 0-17 17l12 12a12 12 0 0 0 17-17ZM48 128a12 12 0 0 0-12-12H20a12 12 0 0 0 0 24h16a12 12 0 0 0 12-12m80 80a12 12 0 0 0-12 12v16a12 12 0 0 0 24 0v-16a12 12 0 0 0-12-12m108-92h-16a12 12 0 0 0 0 24h16a12 12 0 0 0 0-24'/%3E%3C/svg%3E")}:where(.i-ph\:swatches-bold){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 256 256' width='256' height='256'%3E%3Cpath fill='black' d='M242.79 149.32L223.7 97.11a20 20 0 0 0-25.58-11.91l-61.31 22.22l10.89-62.24A20 20 0 0 0 131.55 22l-54.68-9.69a19.94 19.94 0 0 0-23.11 16.24l-25 143.13a48 48 0 0 0 38.64 55.58a51 51 0 0 0 8.7.74H224a20 20 0 0 0 20-20v-51.81a21.7 21.7 0 0 0-1.21-6.87M99 184.18a23.84 23.84 0 0 1-9.86 15.56a23.28 23.28 0 0 1-17.56 3.89a24 24 0 0 1-19.23-27.82L76.71 36.66L123.37 45zm23.64 4.13l9.39-53.64l70.49-25.54l16.3 44.59l-96.23 34.87c.03-.09.06-.18.07-.28ZM220 204h-69.48L220 178.82ZM89.22 174.07l-1.4 8A12 12 0 0 1 76 192a12.4 12.4 0 0 1-2.08-.18a12 12 0 0 1-9.75-13.89l1.4-8a12 12 0 0 1 23.64 4.14Z'/%3E%3C/svg%3E")}:where(.i-ri\:creative-commons-line){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='M9 8c1.104 0 2.105.448 2.829 1.173l-1.414 1.413a2 2 0 1 0 0 2.828l1.413 1.414A4.001 4.001 0 0 1 5 12c0-2.208 1.792-4 4-4m9.829 1.173A4.001 4.001 0 0 0 12 12a4.001 4.001 0 0 0 6.828 2.828l-1.414-1.414a2 2 0 1 1 0-2.828zM2 12C2 6.477 6.477 2 12 2s10 4.477 10 10s-4.477 10-10 10S2 17.523 2 12m10-8a8 8 0 1 0 0 16a8 8 0 0 0 0-16'/%3E%3C/svg%3E")}:where(.i-ri\:qq-line){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='m17.536 12.514l-.696-1.796c0-.021.01-.375.01-.558C16.85 7.088 15.447 4 12 4s-4.848 3.088-4.848 6.16c0 .183.009.537.01.557l-.696 1.797c-.19.515-.38 1.05-.517 1.51c-.657 2.189-.444 3.095-.282 3.115c.348.043 1.354-1.648 1.354-1.648c0 .98.487 2.258 1.542 3.18c-.394.127-.878.32-1.188.557c-.28.214-.245.431-.194.52c.22.385 3.79.245 4.82.125c1.03.12 4.599.26 4.82-.126c.05-.088.085-.305-.194-.519c-.311-.237-.795-.43-1.19-.556c1.055-.923 1.542-2.202 1.542-3.181c0 0 1.007 1.691 1.355 1.648c.162-.02.378-.928-.283-3.116a27 27 0 0 0-.516-1.509m1.021 8.227c-.373.652-.833.892-1.438 1.057a5 5 0 0 1-.794.138c-.44.045-.986.065-1.613.064a33 33 0 0 1-2.71-.116c-.692.065-1.785.114-2.71.116a16 16 0 0 1-1.614-.064a5 5 0 0 1-.793-.138c-.605-.164-1.065-.405-1.44-1.059a2.27 2.27 0 0 1-.239-1.652c-.592-.132-1.001-.482-1.279-.911a2.4 2.4 0 0 1-.309-.71a4 4 0 0 1-.116-1.106c.013-.785.187-1.762.532-2.912c.14-.466.327-1.008.567-1.655l.554-1.43l-.002-.203C5.153 5.605 7.589 2 12 2c4.413 0 6.848 3.605 6.848 8.16l-.001.203l.553 1.43l.01.026c.225.606.413 1.153.556 1.626c.348 1.15.522 2.128.535 2.916q.012.61-.118 1.108c-.066.246-.161.48-.31.708c-.276.427-.684.776-1.277.91c.13.554.055 1.14-.24 1.654'/%3E%3C/svg%3E")}:where(.i-simple-icons\:nuxtdotjs){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' d='M13.464 19.83h8.922c.283 0 .562-.073.807-.21a1.6 1.6 0 0 0 .591-.574a1.53 1.53 0 0 0 .216-.783a1.53 1.53 0 0 0-.217-.782L17.792 7.414a1.6 1.6 0 0 0-.591-.573a1.65 1.65 0 0 0-.807-.21c-.283 0-.562.073-.807.21a1.6 1.6 0 0 0-.59.573L13.463 9.99L10.47 4.953a1.6 1.6 0 0 0-.591-.573a1.65 1.65 0 0 0-.807-.21c-.284 0-.562.073-.807.21a1.6 1.6 0 0 0-.591.573L.216 17.481a1.53 1.53 0 0 0-.217.782c0 .275.074.545.216.783a1.6 1.6 0 0 0 .59.574c.246.137.525.21.808.21h5.6c2.22 0 3.856-.946 4.982-2.79l2.733-4.593l1.464-2.457l4.395 7.382h-5.859Zm-6.341-2.46l-3.908-.002l5.858-9.842l2.923 4.921l-1.957 3.29c-.748 1.196-1.597 1.632-2.916 1.632'/%3E%3C/svg%3E")}:where(.i-solar\:rewind-back-bold-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' fill-rule='evenodd' d='M22 6.426v11.148c0 1.847-1.6 3.015-2.903 2.118L13 15.232V8.768l6.097-4.46C20.399 3.411 22 4.58 22 6.426' clip-rule='evenodd' opacity='.5'/%3E%3Cpath fill='black' d='M13 7.123v9.754c0 1.616-1.467 2.638-2.661 1.853L2.92 13.853c-1.228-.807-1.228-2.899 0-3.706l7.42-4.877c1.193-.785 2.66.237 2.66 1.853'/%3E%3C/svg%3E")}:where(.i-solar\:rewind-forward-bold-duotone){display:inline-block;width:1em;height:1em;background-color:currentColor;-webkit-mask-image:var(--svg);mask-image:var(--svg);-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;-webkit-mask-size:100% 100%;mask-size:100% 100%;--svg:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='24' height='24'%3E%3Cpath fill='black' fill-rule='evenodd' d='M2 6.426v11.148c0 1.847 1.6 3.015 2.903 2.118L11 15.232V8.768l-6.097-4.46C3.601 3.411 2 4.58 2 6.426' clip-rule='evenodd' opacity='.5'/%3E%3Cpath fill='black' d='M11 7.123v9.754c0 1.616 1.467 2.638 2.661 1.853l7.418-4.877c1.228-.807 1.228-2.899 0-3.706L13.66 5.27C12.467 4.485 11 5.507 11 7.123'/%3E%3C/svg%3E")}</style><link rel="preload" as="fetch" crossorigin="anonymous" href="/2025/lanqiao2025/_payload.json?65e504e3-144a-4672-8899-6d7e0db34e11"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CuRDy5bR.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/Bpcnp12S.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DR1pY-pW.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/BCtObj3c.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CR5il1yG.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CLgq55kq.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/rJCbAzvX.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DxRn-wyQ.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/BpBpkyY5.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CNBUYbyu.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/CogeDm5j.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DT9x559x.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/OyYXSbqT.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/C1KxpfgX.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/iF45TmEy.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DEhIqN2q.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DRuWKRet.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/SLTiFf2K.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/JjPd1uVN.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/rVs8wUBv.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/D4wCQXZh.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DzbFwEpR.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/B1kM-2Tz.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ujVNAKx7.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/U9u3eSb9.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/Bhk59Wr3.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ChrFluuA.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/DN8SQizn.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/S8rEwdrW.js"><link rel="preload" as="fetch" fetchpriority="low" crossorigin="anonymous" href="/_nuxt/builds/meta/65e504e3-144a-4672-8899-6d7e0db34e11.json"><script src="https://lib.baomitu.com/twikoo/1.6.44/twikoo.min.js" defer></script><link rel="prefetch" as="style" crossorigin href="/_nuxt/Search.CGXRp4r1.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Cc3VQCsS.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/CJ6W8aET.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/DlGroup.DNv-X34Y.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Cmuwgckb.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/C2lTr802.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DMif9sG2.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/BlogTech.BKG_gLiK.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DD6A8v_H.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Chg9i9KU.js"><link rel="prefetch" as="style" crossorigin href="/_nuxt/GithubCard.DxCGmoqz.css"><link rel="prefetch" as="script" crossorigin href="/_nuxt/B0XRyzrU.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/CIF3D_B3.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/deGonkTA.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/Jep7L2Wt.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DVMEJ2y_.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/DHHWsMLB.js"><link rel="icon" href="https://7.isyangs.cn/20250805/c77df6ed888acf748d49f457f1eb9d72.jpg"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="author" content="轻语, yzy11235@qq.com"><meta name="generator" content="QingYu-blog" data-github-repo="https://github.com/yingzya/yingzya.github.io" data-version="1.4.0"><meta name="mobile-web-app-capable" content="yes"><meta property="og:type" content="article"><script>((e,t)=>{let n=e.map(atob),r=atob(t),i=document.querySelector(`link[rel="canonical"]`);n.some(e=>location.hostname.endsWith(e))&&(i&&(i.href=i.href.replace(location.host,r)),location.host=r)})([`ZGdqbHguY29t`,`ZGd2aHF0LmNvbQ==`,`aGNtc2xhLmNvbQ==`,`d21sb3AuY29t`,`eXN3anhzLmNvbQ==`],`aHR0cHM6Ly9ibG9nLnlhbmd6eS50b3Av`);</script><meta name="robots" content="index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1"><meta property="og:image" content="https://7.isyangs.cn/20250731/1e40d3e28e500126d257c30072340d5b.png"><meta name="description" content="汇总了2025蓝桥杯突击训练过程中的经典算法题解及代码示例，涵盖暴力枚举、递归与递推、贪心算法、搜索算法等多种算法类型"><script type="module" src="/_nuxt/CuRDy5bR.js" crossorigin></script><meta name="twitter:card" content="summary_large_image"><meta property="og:title" data-infer="" content="2025蓝桥杯突击训练 | 字节追风者"><meta property="og:description" data-infer="" content="汇总了2025蓝桥杯突击训练过程中的经典算法题解及代码示例，涵盖暴力枚举、递归与递推、贪心算法、搜索算法等多种算法类型"><link rel="canonical" href="https://blog.yangzy.top/2025/lanqiao2025"><meta property="og:url" content="https://blog.yangzy.top/2025/lanqiao2025"><meta property="og:locale" content="zh_CN"><meta property="og:site_name" content="字节追风者"><script id="unhead:payload" type="application/json">{"templateParams":{"separator":"|"},"titleTemplate":"%s %separator 字节追风者"}</script><script>"use strict";(()=>{const t=window,e=document.documentElement,c=["dark","light"],n=getStorageValue("localStorage","nuxt-color-mode")||"system";let i=n==="system"?u():n;const r=e.getAttribute("data-color-mode-forced");r&&(i=r),l(i),t["__NUXT_COLOR_MODE__"]={preference:n,value:i,getColorScheme:u,addColorScheme:l,removeColorScheme:d};function l(o){const s=""+o+"",a="";e.classList?e.classList.add(s):e.className+=" "+s,a&&e.setAttribute("data-"+a,o)}function d(o){const s=""+o+"",a="";e.classList?e.classList.remove(s):e.className=e.className.replace(new RegExp(s,"g"),""),a&&e.removeAttribute("data-"+a)}function f(o){return t.matchMedia("(prefers-color-scheme"+o+")")}function u(){if(t.matchMedia&&f("").media!=="not all"){for(const o of c)if(f(":"+o).matches)return o}return"light"}})();function getStorageValue(t,e){switch(t){case"localStorage":return window.localStorage.getItem(e);case"sessionStorage":return window.sessionStorage.getItem(e);case"cookie":return getCookie(e);default:return null}}function getCookie(t){const c=("; "+window.document.cookie).split("; "+t+"=");if(c.length===2)return c.pop()?.split(";").shift()}</script></head><body><div id="z-root"><!--[--><div class="nuxt-loading-indicator" style="position:fixed;top:0;right:0;left:0;pointer-events:none;width:auto;height:3px;opacity:0;background:repeating-linear-gradient(to right,#00dc82 0%,#34cdfe 50%,#0047e1 100%);background-size:0% auto;transform:scaleX(0%);transform-origin:left;transition:transform 0.1s, height 0.4s, opacity 0.4s;z-index:999999;"></div><a href="#main-content" class="skip-link gradient-card active" data-v-8fdfd33d> 跳转到主要内容 / Skip to content </a><!--[--><!----><aside id="z-sidebar" class="" data-v-781ebb1d><a href="/" class="zhilu-header sidebar-header" data-v-781ebb1d data-v-d727d25c><!--[--><div class="emoji-tail" data-v-d727d25c><!--[--><span class="split-char" style="--delay:-3s;" data-v-d727d25c>🔥</span><span class="split-char" style="--delay:-2.4s;" data-v-d727d25c>💨</span><span class="split-char" style="--delay:-1.8s;" data-v-d727d25c>🌟</span><span class="split-char" style="--delay:-1.2000000000000002s;" data-v-d727d25c>⚡</span><span class="split-char" style="--delay:-0.6000000000000001s;" data-v-d727d25c>🚀</span><!--]--></div><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" alt="字节追风者" data-nuxt-img srcset="https://7.isyangs.cn/20250730/c65a56b5206f765b8a30203c71be985e.jpg 1x, https://7.isyangs.cn/20250730/c65a56b5206f765b8a30203c71be985e.jpg 2x" class="zhilu-logo circle" src="https://7.isyangs.cn/20250730/c65a56b5206f765b8a30203c71be985e.jpg" data-v-d727d25c><div class="zhilu-text" data-v-d727d25c><div class="header-title" data-v-d727d25c><!--[--><span class="split-char" style="--delay:0.1s;" data-v-d727d25c>字</span><span class="split-char" style="--delay:0.2s;" data-v-d727d25c>节</span><span class="split-char" style="--delay:0.30000000000000004s;" data-v-d727d25c>追</span><span class="split-char" style="--delay:0.4s;" data-v-d727d25c>风</span><span class="split-char" style="--delay:0.5s;" data-v-d727d25c>者</span><!--]--></div><div class="header-subtitle" data-v-d727d25c>博客爱好者</div></div><!--]--></a><nav class="sidebar-nav scrollcheck-y" data-v-781ebb1d><div class="search-btn sidebar-nav-item gradient-card" data-v-781ebb1d><span class="iconify i-ph:magnifying-glass-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>搜索</span><span class="keycut" data-v-781ebb1d data-v-6a540ef3></span></div><!--[--><!--[--><!----><menu data-v-781ebb1d><!--[--><li data-v-781ebb1d><a href="/" class="sidebar-nav-item" data-v-781ebb1d><!--[--><span class="iconify i-ph:files-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>文章</span><!----><!--]--></a></li><li data-v-781ebb1d><a href="/link" class="sidebar-nav-item" data-v-781ebb1d><!--[--><span class="iconify i-ph:link-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>友链</span><!----><!--]--></a></li><li data-v-781ebb1d><a href="/archive" class="sidebar-nav-item" data-v-781ebb1d><!--[--><span class="iconify i-ph:archive-bold" aria-hidden="true" style="" data-v-781ebb1d></span><span class="nav-text" data-v-781ebb1d>归档</span><!----><!--]--></a></li><!--]--></menu><!--]--><!--]--></nav><footer class="sidebar-footer" data-v-781ebb1d><div class="theme-toggle" data-v-781ebb1d data-v-e7a12ec1><!--[--><button aria-label="浅色模式" class="" data-v-e7a12ec1><span class="iconify i-ph:sun-bold" aria-hidden="true" style="" data-v-e7a12ec1></span></button><button aria-label="跟随系统" class="active" data-v-e7a12ec1><span class="iconify i-ph:monitor-bold" aria-hidden="true" style="" data-v-e7a12ec1></span></button><button aria-label="深色模式" class="" data-v-e7a12ec1><span class="iconify i-ph:moon-bold" aria-hidden="true" style="" data-v-e7a12ec1></span></button><!--]--></div><menu data-v-781ebb1d data-v-915035bb><!--[--><a href="https://yangzy.top/" rel="noopener noreferrer" target="_blank" aria-label="个人主页" data-v-915035bb><!--[--><span class="iconify i-ph:house-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="https://jq.qq.com/?_wv=1027&amp;k=lQfNSeEd" rel="noopener noreferrer" target="_blank" aria-label="交流群: 169994096" data-v-915035bb><!--[--><span class="iconify i-ri:qq-line" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="https://github.com/yingzya" rel="noopener noreferrer" target="_blank" aria-label="GitHub: yingzya" data-v-915035bb><!--[--><span class="iconify i-ph:github-logo-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="/atom.xml" rel="noopener noreferrer" target="_blank" aria-label="Atom订阅" data-v-915035bb><!--[--><span class="iconify i-ph:rss-simple-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><a href="https://www.travellings.cn/go-by-clouds.html" rel="noopener noreferrer" target="_blank" aria-label="开往" data-v-915035bb><!--[--><span class="iconify i-ph:subway-bold" aria-hidden="true" style="" data-v-915035bb></span><!--]--></a><!--]--></menu></footer></aside><!--]--><div id="content"><main id="main-content"><!--[--><div class="post-header has-cover" data-v-d1ca4385><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" alt="2025蓝桥杯突击训练" data-nuxt-img srcset="https://7.isyangs.cn/20250731/1e40d3e28e500126d257c30072340d5b.png 1x, https://7.isyangs.cn/20250731/1e40d3e28e500126d257c30072340d5b.png 2x" class="post-cover" src="https://7.isyangs.cn/20250731/1e40d3e28e500126d257c30072340d5b.png" data-v-d1ca4385><div class="post-nav" data-v-d1ca4385><div class="operations" data-v-d1ca4385><button class="button" data-v-d1ca4385 data-v-32e6a543><div class="button-main" data-v-32e6a543><span class="iconify i-ph:share-bold" aria-hidden="true" style="" data-v-32e6a543></span><!--[--> 文字分享 <!--]--></div><!----></button></div><div class="post-info" data-v-d1ca4385><time datetime="2025-03-27T23:45:35.000Z" data-v-d1ca4385><span class="iconify i-ph:calendar-dots-bold" aria-hidden="true" style="" data-v-d1ca4385></span> 3月27日</time><!----><span data-v-d1ca4385><span class="iconify i-ph:code-bold" aria-hidden="true" style="" data-v-d1ca4385></span> 算法</span><span data-v-d1ca4385><span class="iconify i-ph:paragraph-bold" aria-hidden="true" style="" data-v-d1ca4385></span> 1.01万 字 </span></div></div><h1 class="text-tech post-title" data-v-d1ca4385>2025蓝桥杯突击训练</h1></div><div class="md-excerpt gradient-card" data-v-186a6ec2><span class="iconify i-ph:highlighter-bold" aria-hidden="true" style="" data-v-186a6ec2></span></div><article class="article md-tech"><h2 id="个人的变量命名习惯"><a href="#个人的变量命名习惯"><!--[-->个人的变量命名习惯<!--]--></a></h2><ul><!--[--><li><!--[-->T test_case<!--]--></li><li><!--[-->mark 标记<!--]--></li><li><!--[-->n    number<!--]--></li><li><!--[-->e edge<!--]--></li><li><!--[-->v vertex<!--]--></li><li><!--[-->v vector<!--]--></li><li><!--[-->v volume<!--]--></li><li><!--[-->v value<!--]--></li><li><!--[-->w weight<!--]--></li><li><!--[-->d depth<!--]--></li><li><!--[-->h head<!--]--></li><li><!--[-->u/v/w 输入边的起点终点和权重<!--]--></li><li><!--[-->vis   visited<!--]--></li><li><!--[-->l left<!--]--></li><li><!--[-->r right<!--]--></li><li><!--[-->mid middle<!--]--></li><li><!--[-->pos position<!--]--></li><li><!--[-->p pointer<!--]--></li><li><!--[-->s/st start<!--]--></li><li><!--[-->ed end<!--]--></li><li><!--[-->m matrix<!--]--></li><li><!--[-->g graph<!--]--></li><li><!--[-->s set<!--]--></li><li><!--[-->q queue<!--]--></li><li><!--[-->c/cnt count<!--]--></li><li><!--[-->ans answer<!--]--></li><li><!--[-->ret return<!--]--></li><li><!--[-->res result<!--]--></li><li><!--[-->t/tmp temporary临时变量<!--]--></li><!--]--></ul><h1 id="数据分析"><!--[-->数据分析<!--]--></h1><p><!--[--><strong><!--[-->int<!--]--></strong>的数据范围最高到<strong><!--[-->1e9<!--]--></strong>,超了记得换<strong><!--[-->long long<!--]--></strong><!--]--></p><p><!--[--><strong><!--[-->第二步：构造 <code data-v-cdb8f38f><!--[-->tm<!--]--></code> 结构体<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>tm t = {0, 0, 0, d, m - 1, y - 1900};
</pre><!----></figure><p><!--[-->这里用到了 <code data-v-cdb8f38f><!--[-->&lt;ctime&gt;<!--]--></code> 库里定义的结构体 <code data-v-cdb8f38f><!--[-->tm<!--]--></code>，这是 c/c++ 里专门用来表示日期的结构体。<!--]--></p><p><!--[-->结构如下：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>struct tm {
int tm_sec;   // 秒
int tm_min;   // 分
int tm_hour;  // 时
int tm_mday;  // 天
int tm_mon;   // 月（0~11）❗️注意不是 1~12
int tm_year;  // 年（从 1900 开始）❗️
};
</pre><!----></figure><p><!--[-->所以：<!--]--></p><ul><!--[--><li><!--[--><code data-v-cdb8f38f><!--[-->t.tm_mday = d;<!--]--></code> // 天 = 11<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->t.tm_mon = m - 1;<!--]--></code> // 月 = 4 - 1 = 3（代表 4 月）<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->t.tm_year = y - 1900;<!--]--></code> // 年 = 2025 - 1900 = 125<!--]--></li><!--]--></ul><hr><p><!--[-->第三步：日期 +1 天<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>t.tm_mday += 1;
</pre><!----></figure><p><!--[-->直接把天数加 1，<strong><!--[-->可能会超出当前月的天数，比如加到 31 号或 29 号（2 月）等等。<!--]--></strong><!--]--></p><hr><p><!--[--><strong><!--[-->第四步：让系统帮你“进位”<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>mktime(&amp;t);
</pre><!----></figure><p><!--[--><code data-v-cdb8f38f><!--[-->mktime<!--]--></code> 会自动处理你加了一天后产生的 <strong><!--[-->月进位 / 年进位 / 闰年处理<!--]--></strong>。<!--]--></p><p><!--[-->比如：<!--]--></p><ul><!--[--><li><!--[-->2月28日 +1 → 3月1日（非闰年）<!--]--></li><li><!--[-->2月28日 +1 → 2月29日（闰年）<!--]--></li><li><!--[-->12月31日 +1 → 下一年 1月1日<!--]--></li><!--]--></ul><h1 id="算法1-3暴力枚举"><!--[-->算法1-3暴力枚举<!--]--></h1><h2 id="p2241统计方形"><a href="#p2241统计方形"><!--[-->P2241统计方形<!--]--></a></h2><p><!--[-->参考的大佬的题解：<a href="https://www.luogu.com.cn/problem/solution/P2241" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->https://www.luogu.com.cn/problem/solution/P2241<!--]--><!--]--></a><!--]--></p><p><!--[-->注意要开<strong><!--[-->long long<!--]--></strong>，因为最坏的情况是从1➕到5000 * 5000，超出了int<!--]--></p><p><!--[-->等差数列求和公式：<!--]--></p><p><!--[-->S=n*(n+1) / 2<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,m;
typedef long long ll;

ll zheng,chang;

int main()
{
    cin &gt;&gt; n &gt;&gt; m;             //对于正方形来说，子矩阵的个数是有原矩阵减去相同的数得到
    for(int i = 0; i &lt; n; i ++)//对于长方形来说，子矩形构成的矩阵的长宽是由原矩形长宽减去不同数而得
        for(int j = 0; j &lt; m;j++)//棋盘中的矩阵不是正方形就是长方形，
        {
            if(i == j) zheng += (n-i)*(m - i);
            else chang += (n-i)*(m-j);
        }
    cout &lt;&lt; zheng &lt;&lt; &quot; &quot; &lt;&lt; chang &lt;&lt; endl;
    return 0;
}
</pre><!----></figure><h2 id="p2089烤鸡"><a href="#p2089烤鸡"><!--[-->P2089烤鸡<!--]--></a></h2><p><!--[-->题目链接： <a href="https://www.luogu.com.cn/problem/P2089" rel="nofollow" target="_blank" class="z-link" data-v-b771bfcd><!--[--><!----><!--[-->https://www.luogu.com.cn/problem/P2089<!--]--><!--]--></a><!--]--></p><p><!--[-->一道比较简单的dfs，这里需要考虑的是最多有几种方案，因为题目说n最大5000，但是从题目意思可知，美味程度最大是30.数据量较小，如果非要说确定的话，3的10次方，最多开6w即可。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>
#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,ans; //n表示需要的美味程度
int a[10000][10],cmp[10];

void dfs(int id,int degree){//id表示接下来考虑的是哪种配料，degree表示目前的美味程度
    if(id &gt; 10 || degree &gt; n) return;
    
    if(id == 10 &amp;&amp; degree == n){
        for(int i = 0; i &lt; 10;i++) a[ans][i] = cmp[i];
        ans++;
    }
    
    for(int i = 1; i &lt;= 3; i ++){
        cmp[id] = i;
        dfs(id + 1,degree + i);//无需恢复现场，因为下次的值会覆盖
    }
}

int main()
{
    cin &gt;&gt; n;
    dfs(0,0);
    cout &lt;&lt; ans &lt;&lt; endl;
    if(ans){
        for(int i = 0; i &lt; ans ;i++)
        {
            for(int j = 0; j &lt; 10; j ++) cout &lt;&lt; a[i][j] &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
        }
    }
    return 0;
}

</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>36 行</span></button></figure><h2 id="p1618三连击"><a href="#p1618三连击"><!--[-->P1618三连击<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int a,b,c;
int used[10],m[10];//used用来标识数字是否用过，a用来存每一位上放的数字
bool ans = false;
int seg(int w){//w能取1、2、3
    int num = 0;
    for(int i = 3*w - 2;i &lt;= 3*w;i++){
        num *= 10;
        num += m[i]; //就是将对应的前三位，中三位，后三位取出来
    }
    return num;
}

//一共9个数
void dfs(int id){//id表示接下来考虑的是第几位
    if(id &gt; 10) return;
    if(id == 10){
        if(seg(1)*b == seg(2)*a &amp;&amp; seg(1)*c == seg(3)*a){
            ans = true;
            cout &lt;&lt; seg(1) &lt;&lt; &quot; &quot; &lt;&lt; seg(2) &lt;&lt; &quot; &quot; &lt;&lt; seg(3) &lt;&lt; endl;
            return;
        }
    }
    
    for(int i = 1; i &lt;= 9;i++){
        if(!used[i]){
            m[id] = i;
            used[i] = 1;
            dfs(id+1);
            used[i] = 0;
        }
    }
}

int main()
{
    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;
    dfs(1);
    if(!ans){
        cout &lt;&lt; &quot;No!!!&quot;;
    }
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>45 行</span></button></figure><h2 id="p1036选数"><a href="#p1036选数"><!--[-->P1036选数<!--]--></a></h2><p><!--[-->该题的关键是选出数的组合不能重复，即<strong><!--[-->位置不同也不行<!--]--></strong>。<!--]--></p><p><!--[-->如1 、2、3和2、1、3是同一种<!--]--></p><p><!--[-->因此要设置一个参数来控制选数的顺序，每次选的时候只从他后面选，即可。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 30;
int q[N],ans,k,n;

bool iszs(int x){
    if(x == 0 || x == 1) return false;
    if(x == 2) return true;
    
    for(int i = 2; i &lt; x;i++){
        if(x % i == 0) return false;
    }
    return true;
}

void dfs(int id,int sum,int order){
    if(id == k){
        if(iszs(sum)) ans++;
        return;
    }
    
    for(int i = order;i &lt; n; i ++)
        dfs(id+1, sum + q[i],i + 1);
}

int main()
{
    cin &gt;&gt; n &gt;&gt; k;
    for(int i = 0; i &lt; n;i++) cin &gt;&gt; q[i];
    dfs(0,0,0);
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>34 行</span></button></figure><h2 id="p1088火星人"><a href="#p1088火星人"><!--[-->P1088火星人<!--]--></a></h2><p><!--[-->该题的意思就是从给定的一个全排列，顺序往下m个，然后输出他。那么在写的时候按全排列写即可，第一次直接定位到输入的全排列即可<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 10010;
int n, m, ans, flag; //n表示总共几个数排列，m表示要加上的数，ans表示方案数
int a[N];
bool used[N];

void dfs(int u)//接下来考虑第几个数
{
    if(flag == 1) return ;
    if(u &gt; n)
    {
        ans++;
        if(ans == m + 1) 
        {
            for(int i = 1; i &lt;= n; i ++) cout &lt;&lt; a[i] &lt;&lt; &#039; &#039;;
            flag = 1;
        }
        return ;    
    }
    
    for(int i = 1; i &lt;= n; i ++)
    {
        if(ans == 0) i = a[u];//将输入的作为排列起点
        if(!used[i])
        {
            a[u] = i;
            used[i] = 1;
            dfs(u + 1);
            a[u] = 0;
            used[i] = 0;
            
        }
    }
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];
    
    dfs(1);
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>46 行</span></button></figure><h2 id="p3799小y拼木棒"><a href="#p3799小y拼木棒"><!--[-->P3799小Y拼木棒<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;
#define int long long
        
using namespace std;
const int mod = 1e9 + 7,N = 1e5 + 10;
int num[N];
int n,ans;
        
signed main()
{   
    cin &gt;&gt; n;
    int Min = INT_MAX,Max = INT_MIN;
    for(int i = 0; i &lt; n; i ++) {
        int a;
        cin &gt;&gt; a;
        num[a]++;
        Min = min(Min,a);
        Max = max(Max,a);
    }
    //先选两根相同的，再选出两根使这两根的长度之和与先前选出的相同
    for(int i = Min + 1; i &lt;= Max;i++){
        if(num[i] &gt;= 2){ 
            for(int j = Min; j &lt;= i / 2; j ++){
                if(j != i - j)
                    ans += num[i] * (num[i] - 1) *num[j] * num[i - j] / 2 % mod;//只有之前的两根相同，用公式cn2
                else if(num[j] &gt;= 2 &amp;&amp; 2*j == i)
                    ans += num[i] * (num[i] - 1) * num[j] * (num[j] - 1) / 4 % mod;//剩下的两根也想相同
            }
            ans %= mod;//if里只能保证每次加的不超过mod，但是加完之后ans可能超过，因此要mod
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>33 行</span></button></figure><h2 id="p1044栈"><a href="#p1044栈"><!--[-->P1044栈<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 20;
int a[2*N][N];
int n;

int dfs(int k,int num){//k表示当前是第几次操作，num表示当前栈内元素个数
    int t = 0;
    if(k == 2*n){
        if(num == 0) return 1;//是合法序列
        else return 0;//不是合法序列
    }
    if(a[k][num] != 0) return a[k][num];//如果之前计算过,直接返回  
    if(num &lt; n) t += dfs(k + 1,num + 1); //栈未满可以push
    if(num &gt; 0) t += dfs(k + 1,num - 1); //栈内有元素可pop
    a[k][num] += t;//记录当前状态的计算结果
    return t; //当前k,num状态下,有多少种合法序列#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 20;
int a[2*N][N];
int n;

int dfs(int k,int num){//k表示当前是第几次操作，num表示当前栈内元素个数
    int t = 0;
    if(k == 2*n){
        if(num == 0) return 1;//是合法序列
        else return 0;//不是合法序列
    }
    if(a[k][num] != 0) return a[k][num];//如果之前计算过,直接返回  
    if(num &lt; n) t += dfs(k + 1,num + 1); //栈未满可以push
    if(num &gt; 0) t += dfs(k + 1,num - 1); //栈内有元素可pop
    a[k][num] += t;//记录当前状态的计算结果
    return t; //当前k,num状态下,有多少种合法序列
}
int main()
{
    cin &gt;&gt; n;
    cout &lt;&lt; dfs(0,0);
    return 0;
}
}
int main()
{
    cin &gt;&gt; n;
    cout &lt;&lt; dfs(0,0);
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>49 行</span></button></figure><h1 id="写递归的要点"><!--[-->写递归的要点<!--]--></h1><p><!--[--><strong><!--[-->明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节，<!--]--></strong> 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。<!--]--></p><h1 id="算法1-4递推与递归"><!--[-->算法1-4递推与递归<!--]--></h1><h2 id="p1464记忆化搜索"><a href="#p1464记忆化搜索"><!--[-->P1464记忆化搜索<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
#define int long long

int d[25][25][25];

int w(int a,int b,int c){
    if(a &lt;= 0 || b &lt;= 0 || c &lt;= 0) return 1;
    if(a &gt; 20 || b &gt; 20 || c &gt; 20) return w(20,20,20);
    if(a &lt; b &amp;&amp; b &lt; c )
    {
        if(!d[a][b][c-1]) d[a][b][c-1] = w(a,b,c-1);
        if(!d[a][b-1][c-1]) d[a][b-1][c-1] = w(a,b-1,c-1);
        if(!d[a][b-1][c]) d[a][b-1][c] = w(a,b-1,c);
        d[a][b][c] = d[a][b][c-1] + d[a][b-1][c-1] -  d[a][b-1][c];
    }else{
        if(!d[a-1][b][c]) d[a-1][b][c] = w(a-1,b,c);
        if(!d[a-1][b-1][c]) d[a-1][b-1][c] = w(a-1,b-1,c);
        if(!d[a-1][b][c-1]) d[a-1][b][c-1] = w(a-1,b,c-1);
        if(!d[a-1][b-1][c-1]) d[a-1][b-1][c-1] = w(a-1,b-1,c-1);
        d[a][b][c] = d[a-1][b][c] + d[a-1][b-1][c] + d[a-1][b][c-1] - d[a-1][b-1][c-1];
    }   
    return d[a][b][c];
}

signed main()
{
    int a,b,c;
    while(scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c)){
        if(a == -1 &amp;&amp; b == -1 &amp;&amp; c == -1) break;
        int ans = w(a,b,c);
        printf(&quot;w(%lld, %lld, %lld) = %lld\n&quot;,a,b,c,ans);
    }
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>36 行</span></button></figure><h2 id="p1928-外星密码"><a href="#p1928-外星密码"><!--[-->P1928 外星密码<!--]--></a></h2><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include &lt;bits/stdc++.h&gt;

using namespace std;

string dg() { // 解压缩函数
    int k;//压缩的次数
    char ch;//输入的字符
    string s = &quot;&quot;, str = &quot;&quot;;//s是最终答案，str是被压缩的字串
    
    //cin &gt;&gt; ch 会跳过空格和换行符
    while (cin.get(ch)) { //用cin.get()读取字符,避免跳过空格和换行
        if (ch == &#039;[&#039;) {//如果找到了被压缩的字串
            cin &gt;&gt; k; // 读取压缩次数
            str = dg(); // 递归调用
            while (k--) {
                s += str;//把解压后的字串复制k次后添加到原来的字符串上
            }
        } else if (ch == &#039;]&#039;) {//如果找到了压缩的字串的末尾
            return s; // 结束这一层递归并返回已经解压的字符串
        } else {
            s += ch;//直接在最后添上这个字符。
        }
    }
    
    return s; // 确保函数有返回值
}

int main() {
    cout &lt;&lt; dg();
    return 0;
}
</pre><!----></figure><h2 id="p1255-数楼梯"><a href="#p1255-数楼梯"><!--[-->P1255 数楼梯<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n,len = 1,arr[5010][5010];//arr[k][i]第k阶台阶所对应的走法,len表示位数 

void highadd(int k)//第k阶台阶,高精度加法 
{
    for(int i = 1; i &lt;= len; i ++)
        arr[k][i] = arr[k-1][i] + arr[k-2][i];//第k阶的方法等于一次走一步+一次性走两步的 
        
    for(int i = 1; i &lt;= len; i ++)
    {
        if(arr[k][i] &gt;= 10)
        {
            arr[k][i+ 1] += arr[k][i] / 10;//进位
            arr[k][i] %= 10;
            if(arr[k][len + 1] != 0) len++;//如果最高位有进位，那么位数➕➕
        }
     } 
 } 

int main()
{
    cin &gt;&gt; n;
    arr[1][1] = 1, arr[2][1] = 2;//初始化
    
    for(int i = 3; i &lt;= n; i ++)//从3开始避免越界 
        highadd(i);
        
    for(int i = len; i &gt;= 1; i --) cout &lt;&lt; arr[n][i]; ////逆序输出  
    return 0;
    
 } 
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>33 行</span></button></figure><h2 id="p2437-蜜蜂路线"><a href="#p2437-蜜蜂路线"><!--[-->P2437 蜜蜂路线<!--]--></a></h2><p><!--[-->和数楼梯思路一样，只不过要上的阶数是n-m。<!--]--></p><h2 id="p1164-小a点菜"><a href="#p1164-小a点菜"><!--[-->P1164 小A点菜<!--]--></a></h2><p><!--[--><strong><!--[-->暴力dfs版本<!--]--></strong>(果然TLE了)<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;

int f[110];//存储菜的价格
int n,m,used[110],ans;

void dfs(int id,int num){//id表示当前考虑的是第几个菜品，num表示当前的菜钱
    if(id == n)
    {
        if(num == m) ans++;
        return;
    }
    
    dfs(id+1,num + f[id]);//直接dfs会超时
    dfs(id+1,num);
}

int main()
{
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; f[i];
    dfs(0,0);
    cout &lt;&lt; ans;
    return 0;
}
</pre><!----></figure><p><!--[--><strong><!--[-->动态规划正解<!--]--></strong><!--]--></p><p><!--[-->这是一道简单的动规题，定义f[i]<span>j</span>为用前i道菜用光j元钱的办法总数，其状态转移方程如下：<!--]--></p><p><!--[-->（1）if(j==第i道菜的价格)f[i]<span>j</span>=f[i-1]<span>j</span>+1;<!--]--></p><p><!--[-->（2）if(j&gt;第i道菜的价格) f[i]<span>j</span>=f[i-1]<span>j</span>+f[i-1]<span>j-第i道菜的价格</span>;<!--]--></p><p><!--[-->（3）if(j&lt;第i道菜的价格) f[i]<span>j</span>=f[i-1]<span>j</span>;<!--]--></p><p><!--[-->说的简单一些，这三个方程，<strong><!--[-->每一个都是在吃与不吃之间抉择<!--]--></strong>。若钱充足，办法总数就等于吃这道菜的办法数与不吃这道菜的办法数之和；若不充足，办法总数就只能承袭吃前i-1道菜的办法总数。依次递推，在最后，我们只要输出f[n]<span>m</span>的值即可。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int f[110][10010];//f[i][j]表示前i道菜(包括第i道),花费j元的方案数
int a[110];//存储菜的单价

int main()
{
    int n,m;
    cin &gt;&gt; n &gt;&gt; m;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];
    for(int i = 1; i &lt;= n; i ++)
        for(int j = 1; j &lt;= m; j ++){//每种的方案数等于前i-1种选与不选的方案数之和
            if(j &gt; a[i]) f[i][j] = f[i-1][j] + f[i-1][j - a[i]];
            else if(j == a[i]) f[i][j] = f[i-1][j] + 1;
            else f[i][j] = f[i-1][j];
        }
    cout &lt;&lt; f[n][m];
    return 0;
}
</pre><!----></figure><h2 id="p1990-覆盖墙壁"><a href="#p1990-覆盖墙壁"><!--[-->P1990 覆盖墙壁<!--]--></a></h2><p><!--[-->G<span>N</span>：铺满前 N 列墙，且第 N+1列有一个单元被覆盖的方案数，且不考虑第N+1列的格子是上还是下！！<!--]--></p><p><!--[-->F<span>2</span>=2,F<span>2</span> = F<span>1</span>+F<span>0</span>+2*G<span>0</span>, F<span>1</span> = 1, F<span>0</span> = 1，所以G<span>0</span> = 0，又因为G<span>1</span> = F<span>0</span> + G<span>0</span>,所以G<span>1</span> = 1. F<span>0</span> = 1即什么都不放也是一种方案。<!--]--></p><p><!--[-->F<span>N</span>表示<strong><!--[-->铺满<!--]--></strong>前N*2的面积的墙的方案数.<!--]--></p><p><!--[-->F<span>N</span>的转移方程就是：<!--]--></p><p><!--[--><strong><!--[-->F<span>N</span>=F<span>N-1</span>+F<span>N-2</span>+2*G<span>N-2</span><!--]--></strong>（别忘了前面讲过G<span>N-2</span>的情况有<strong><!--[-->两种<!--]--></strong>）<!--]--></p><p><!--[-->而G<span>N</span>的转移方程就是：<strong><!--[-->G<span>N</span>=F<span>N-1</span>+G<span>N-1</span><!--]--></strong>。<!--]--></p><p><!--[-->初始化：F<span>0</span>=1,G<span>0</span>=0;F<span>1</span>=G<span>1</span>=1;<!--]--></p><p><!--[--><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" alt="image-20250404091917380" data-nuxt-img srcset="https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404091917380.png 1x, https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404091917380.png 2x" src="https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404091917380.png"><!--]--></p><p><!--[-->但是，L形的瓷砖又怎么办呢？<!--]--></p><p><!--[--><del>（呵呵，刚开始想到这里的时候，我自己都蒙了。）</del><!--]--></p><p><!--[-->为了方便大家思考，我们先往简单的方向想。（<strong><!--[-->以下是重点！！！<!--]--></strong>）<!--]--></p><hr><p><!--[-->我们可以用一个数组G<span>N</span>来表示**铺满前(N+1)*2的面积的墙，但是第(N+1)列有一个瓷砖已经被铺过（注意，是已经被铺过！）**的方案数。<!--]--></p><p><!--[-->所以，L形瓷砖的问题就已经被“初步”解决了。<!--]--></p><p><!--[-->所以，下面这种情况的方案数就是G<span>N-2</span>（因为实际上第N列已经铺满了，所以这里要处理的是前N-1列墙，所以多减了1）（如下图所示）:<!--]--></p><p><!--[--><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" alt="image-20250404092007618" data-nuxt-img srcset="https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404092007618.png 1x, https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404092007618.png 2x" src="https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250404092007618.png"><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int mod = 10000, N = 1e6 + 10;
int f[N],g[N];

int main()
{
    int n;
    cin &gt;&gt; n;
    f[0] = 1;
    f[1] = g[1] = 1;
    for(int i = 2; i &lt;= n; i ++){
        f[i] = (f[i-1] + f[i-2] + 2*g[i-2]) % mod;
        g[i] = (g[i-1] + f[i-1]) % mod; 
    }
    cout &lt;&lt; f[n];
    return 0;
}
</pre><!----></figure><h2 id="p3612-secret-cow-code-s"><a href="#p3612-secret-cow-code-s"><!--[-->P3612 Secret cow code S<!--]--></a></h2><p><!--[-->先看样例<!--]--></p><p><!--[-->cOW*−&gt;<em><!--[-->cOW WcO<!--]--></em>−&gt;*cOWWcO OcOWWc<!--]--></p><p><!--[-->我们把这三个字符串编号为1,2,3<!--]--></p><p><!--[-->现在我们要求第8位，假如我们已经知道在3串，能否逆推出在第2串中的位置呢?如果能，似乎问题就迎刃而解了,因为2逆推到1也是一个相同的子问题。<!--]--></p><p><!--[-->题目的古怪要求复制要先复制最后一个字符，再复制前缀，我们姑且<strong><!--[-->先直接复制前缀<!--]--></strong>.<!--]--></p><p><!--[-->cOW−&gt;cOW  cOW*−&gt;*cOWcOW  cOWcOW<!--]--></p><p><!--[-->现在求3串的8位置，3串长L,逆推回2串即为8−<em><!--[-->L<!--]--></em>/2位置<!--]--></p><p><!--[-->但我们复制的时候是先复制最后一个字符,所以要<strong><!--[-->多减一<!--]--></strong>为8−1−<em><!--[-->L<!--]--></em>/2<!--]--></p><p><!--[-->特别的,如果求的n刚好是先复制原串的<strong><!--[-->最后一个位置<!--]--></strong>,特殊处理<!--]--></p><p><!--[-->因为如果是原串的最后一个位置，假设原串长为L，则复制后的串为2L，若位置x - L / 2 - 1 == 0 即是原串的最后一个位置，则将他赋值为i<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include &lt;bits/stdc++.h&gt;
using namespace std;
string s;
long long n,num,i;
int main()
{
    cin&gt;&gt;s&gt;&gt;n;
    num=s.length(); //求出原串的长度
    while(num&lt;n)//n表示要求字符的位置
    {
        i=num;
        while(n&gt;i)  i*=2;//求出当前刚好包括n位置的串长 
        i=i/2;//得到当前串的一半长 
        
        n-=(i+1); 
        if(n==0)    n=i;//即上一个串的最后一个位置
    }
    cout&lt;&lt;s[n-1];
    return 0;
}
</pre><!----></figure><h2 id="p1259-黑白棋子的移动"><a href="#p1259-黑白棋子的移动"><!--[-->P1259 黑白棋子的移动<!--]--></a></h2><p><!--[-->最左边的o*与空位交换 然后空位再和最右边连续**的最后**两个交换<!--]--></p><p><!--[-->但是注意当<strong><!--[-->o*与空位交换之后<!--]--></strong>，连续的白棋<strong><!--[-->只剩三个<!--]--></strong>的时候规律发生了变化，此时直接打表。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 210;
char a[N];
int n;
string db[4] = {&quot;ooo*o**--*&quot;, &quot;o--*o**oo*&quot;, &quot;o*o*o*--o*&quot;, &quot;--o*o*o*o*&quot;};//无规律的

void out()
{
    for(int i = 1; i &lt;= 2*n+2;i++) cout &lt;&lt; a[i];
    cout &lt;&lt; endl;
}

void move(int start,int endi)
{
    swap(a[start],a[endi]);
    swap(a[start+1],a[endi+1]);
    out();
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n;i++) a[i] = &#039;o&#039;;
    for(int i = n+1; i &lt;= 2*n;i++) a[i] = &#039;*&#039;;
    a[2*n + 1] = a[2*n + 2] = &#039;-&#039;;
    
    out();//输出起始序列
    int len = n;//需要移动的黑/白棋
    while(true)
    {
        move(len,2*len + 1);//空位和o*交换
        len--;
        if(len == 3) break;
        move(len + 1,2*len + 1);
    }
    string ss;
    for (int i = 0; i &lt; n - 4; i++)
        ss += &quot;o*&quot;;
    for (int i = 0; i &lt; 4; i++)
        cout &lt;&lt; db[i] &lt;&lt; ss &lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>44 行</span></button></figure><h2 id="p1010幂次方"><a href="#p1010幂次方"><!--[-->P1010幂次方<!--]--></a></h2><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n;

void recur(int x)//分解x使其表示为2和2(0)的组合
{
    for(int i = 14; i &gt;= 0;i--)
    {
        if(pow(2,i) &lt;= x)
        {
            if(i == 1) cout &lt;&lt; &quot;2&quot;;//2(1)不用再往后分解了且2^1输出为2,单独出来
            else if(i == 0) cout &lt;&lt; &quot;2(0)&quot;;//2(0)也不用再往后分解了,单独出来
            else{//指数不是这两种情况则还得分解
                cout &lt;&lt;&quot;2(&quot;;
                recur(i);
                cout &lt;&lt; &quot;)&quot;;
            }
            x -= pow(2,i);
            if(x != 0) cout &lt;&lt; &quot;+&quot;;//加号处理的最简单方法:若此x还没分解完,则后面还有项,所以输出一个+号
            
        }
    }
}

int main()
{
    cin &gt;&gt; n;
    recur(n);
    return 0;
}
</pre><!----></figure><h2 id="p1228-地毯填补问题"><a href="#p1228-地毯填补问题"><!--[-->P1228 地毯填补问题<!--]--></a></h2><p><!--[-->棋盘是如何划分的：<!--]--></p><ol><!--[--><li><!--[-->设当前棋盘的左上角坐标为 <code data-v-cdb8f38f><!--[-->(a, b)<!--]--></code>，边长为 <code data-v-cdb8f38f><!--[-->l<!--]--></code>。<!--]--></li><li><!--[-->该棋盘被划分成四个 <code data-v-cdb8f38f><!--[-->l/2 × l/2<!--]--></code> 的小棋盘：
<ul><!--[--><li><!--[-->左上角子棋盘范围：
<strong><!--[-->横坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[a, a + l/2 - 1]<!--]--></code><strong><!--[-->纵坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[b, b + l/2 - 1]<!--]--></code><!--]--></li><li><!--[-->右上角子棋盘范围： <strong><!--[-->横坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[a, a + l/2 - 1]<!--]--></code><strong><!--[-->纵坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[b + l/2, b + l - 1]<!--]--></code><!--]--></li><li><!--[-->左下角子棋盘范围： <strong><!--[-->横坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[a + l/2, a + l - 1]<!--]--></code><strong><!--[-->纵坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[b, b + l/2 - 1]<!--]--></code><!--]--></li><li><!--[-->右下角子棋盘范围： <strong><!--[-->横坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[a + l/2, a + l - 1]<!--]--></code><strong><!--[-->纵坐标：<!--]--></strong> <code data-v-cdb8f38f><!--[-->[b + l/2, b + l - 1]<!--]--></code><!--]--></li><!--]--></ul><!--]--></li><!--]--></ol><p><!--[-->void dfs(ll x, ll y, ll a,ll b, ll l)//<strong><!--[-->(x,y)是障碍点<!--]--></strong>,<strong><!--[-->(a,b)是当前棋盘的左上角坐标<!--]--></strong>,l是棋盘边长<!--]--></p><p><!--[-->初看这个问题，似乎无从下手，于是我们可以先考虑最简单的情况，既<strong><!--[-->n = 2<!--]--></strong>时<!--]--></p><p><!--[-->0 0 0 1 这时，<strong><!--[-->无论公主在哪个格子<!--]--></strong>，<strong><!--[-->我们都可以用一块毯子填满<!--]--></strong><!--]--></p><p><!--[-->继续考虑n = 4的情况<!--]--></p><p><!--[-->我们已经知道了解决2 * 2的格子中有一个障碍的情况如何解决，因此我们可以尝试构造这种情况<!--]--></p><p><!--[-->首先，显然可以将4 * 4的盘面划分成<strong><!--[-->4个2 * 2的小盘面<!--]--></strong>，其中<strong><!--[-->一块<!--]--></strong>已经<strong><!--[-->存在一个障碍<!--]--></strong>了<!--]--></p><p><!--[-->而我们只需在正中间的2 * 2方格中放入一块地毯，就可以使<strong><!--[-->所有<!--]--></strong>小盘面<strong><!--[-->都有一个障碍<!--]--></strong><!--]--></p><p><!--[-->于是，n = 4的情况就解决了<!--]--></p><p><!--[-->我们可以将n = 4时的解法可以推广到一般情况，既当n = 2 k时，我们均可以将问题划分为4个n = 2 k – 1的子问题，然后分治解决即可。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
typedef long long ll;
ll x,y; //x,y表示公主坐标

int k; //表示迷宫规格

void dfs(ll x, ll y, ll a,ll b, ll l)//(x,y)是障碍点,(a,b)是当前棋盘的左上角坐标,l是棋盘边长
{
    if(l == 1) return ;//棋盘的大小是1×1,无法再继续拆分
    if(x - a  + 1&lt;= l / 2&amp;&amp; y - b + 1&lt;= l / 2)//则在左上角
    {
        printf(&quot;%lld %lld 1\n&quot;,a + l/2,b + l/2);//则需在中心放置1号地毯,这里坐标是毯子的拐角
        dfs(x,y,a,b,l/2);//递归处理左上角
        dfs(a + l/2-1 , b+ l/2    , a         , b + l/2   ,l/2);//右上角
        dfs(a + l/2   , b+ l/2 - 1, a + l/2   , b         ,l/2);//左下角   
        dfs(a + l/2   , b+ l/2    , a + l/2   , b + l/2   ,l/2);//右下角
    }
    else if(x - a  + 1 &lt;= l / 2&amp;&amp; y - b + 1 &gt; l / 2)//在右上角
    {
        printf(&quot;%lld %lld 2\n&quot;,a + l/2,b + l/2 - 1);//则需在中心放置2号地毯
        dfs(a + l/2-1,b + l/2-1,a,b,l/2);//递归处理左上角
        dfs(x,y,a,b+l/2,l/2);//右上角
        dfs(a + l/2,b+ l/2 - 1, a + l/2, b,l/2);//左下角   
        dfs(a + l/2, b+ l/2, a + l/2, b + l/2,l/2);//右下角
    }
    else if(x - a  + 1 &gt; l / 2&amp;&amp; y - b + 1 &lt;= l / 2)//左下角
    {
        printf(&quot;%lld %lld 3\n&quot;,a + l/2 - 1,b + l/2);//则需在中心放置3号地毯
        dfs(a + l/2-1,b + l/2-1,a,b,l/2);//递归处理左上角
        dfs(a+l/2-1,b+l/2,a,b+l/2,l/2);//右上角
        dfs(x,y,a+l/2,b,l/2);//左下角  
        dfs(a + l/2, b+ l/2, a + l/2, b + l/2,l/2);//右下角
    }
    else
    {
        printf(&quot;%lld %lld 4\n&quot;,a + l/2 - 1,b + l/2-1);//则需在中心放置3号地毯
        dfs(a + l/2-1,b + l/2-1,a,b,l/2);//递归处理左上角
        dfs(a+l/2-1,b+l/2,a,b+l/2,l/2);//右上角
        dfs(a+l/2,b+l/2-1,a+l/2,b,l/2);//左下角    
        dfs(x,y, a + l/2, b + l/2,l/2);//右下角
    }
}

int main()
{
    cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;
    dfs(x,y,1,1,pow(2,k));
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>51 行</span></button></figure><h2 id="p1498-南蛮图腾"><a href="#p1498-南蛮图腾"><!--[-->P1498 南蛮图腾<!--]--></a></h2><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>for(int j=i;j&gt;0;j--)a[j]^=a[j-1];//修改数组
</pre><!----></figure><p><!--[--><strong><!--[-->动态生成分形图案的每一行状态<!--]--></strong>,它本质上是在模拟杨辉三角（Pascal&#39;s Triangle）的生成过程，但只关心每个位置的奇偶性（用异或运算实现）。<!--]--></p><p><!--[--><strong><!--[-->为什么倒序更新？<!--]--></strong><!--]--></p><p><!--[-->假设我们有一个数组 <code data-v-cdb8f38f><!--[-->a = [1, 1, 0, 1]<!--]--></code>，想要生成下一行：<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->正序更新<!--]--></strong>（从左到右）：会<strong><!--[-->覆盖前面的值<!--]--></strong>，导致后续计算错误。<!--]--></li><li><!--[--><strong><!--[-->倒序更新<!--]--></strong>（从右到左）：先处理高位，保留低位未修改的值，确保计算的正确性。<!--]--></li><!--]--></ul><p><!--[-->例如，生成杨辉三角第3行（索引从0开始）：<!--]--></p><ul><!--[--><li><!--[-->原数组：<code data-v-cdb8f38f><!--[-->[1, 2, 1]<!--]--></code>（但这里只关心奇偶性，实际存储的是 <code data-v-cdb8f38f><!--[-->[1, 0, 1]<!--]--></code>）<!--]--></li><li><!--[-->生成第4行时，需要从右向左更新，避免覆盖前一行数据。<!--]--></li><!--]--></ul><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;iostream&gt;
using namespace std;
int n,a[1030]={1};//初始化数组,第一个元素为1,其余为0

int main(){
    cin&gt;&gt;n;
    for(int i=0;i&lt;1&lt;&lt;n;i++){//共2的n次方行
        for(int j=1;j&lt;(1&lt;&lt;n)-i;j++)cout&lt;&lt;&quot; &quot;;//前导空格,1-2^n-1,1-2^n-2...
        
        for(int j=i;j&gt;0;j--)a[j]^=a[j-1];//修改数组
        if(!(i%2))for(int j=0;j&lt;=i;j++)cout&lt;&lt;(a[j]?&quot;/\\&quot;:&quot;  &quot;);//奇数行,2个空格,1个0等于2个空格
        else for(int j=0;j&lt;=i;j+=2)cout&lt;&lt;(a[j]?&quot;/__\\&quot;:&quot;    &quot;);//偶数行,4个空格
        cout&lt;&lt;endl;
    }
    return 0;
}
</pre><!----></figure><h1 id="算法1-5贪心"><!--[-->算法1-5贪心<!--]--></h1><p><!--[--><strong><!--[-->总结<!--]--></strong><!--]--></p><p><!--[-->贪心的题一般会进行<strong><!--[-->排序<!--]--></strong>，并且多用<strong><!--[-->结构体<!--]--></strong>。一般是最小最大问题<!--]--></p><h2 id="p1223-排队接水"><a href="#p1223-排队接水"><!--[-->P1223 排队接水<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n;
const int N = 1010;
struct node{
    double t;
    int id;
    bool operator&lt;(const node&amp;W)const{
        return t &lt; W.t;
    }
}a[N];

int wait[N];//wait[i]表示第i人的等待时间

int main()
{
    cin &gt;&gt; n;
    double ans = 0,time = 0;//time表示等待时间
    for(int i = 1; i &lt;= n; i ++){
        cin &gt;&gt; a[i].t;
        a[i].id = i;
    }
    sort(a+1,a+1+n);
    for(int i = 1;i &lt;= n; i ++) {
        cout &lt;&lt; a[i].id &lt;&lt; &quot; &quot;;
        time += a[i-1].t;
        wait[i] = time;//第i人的等待时间
        ans += wait[i];
    }
    cout &lt;&lt; endl;
    printf(&quot;%.2f&quot;,ans*1.0 / n);
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>34 行</span></button></figure><h2 id="p1803-凌乱的yyy-线段覆盖"><a href="#p1803-凌乱的yyy-线段覆盖"><!--[-->P1803 凌乱的yyy / 线段覆盖<!--]--></a></h2><p><!--[-->这道题<strong><!--[-->贪心的思路<!--]--></strong>是每次选择<strong><!--[-->结束时间最早<!--]--></strong>的，这样能为后面留下更多的时间参赛。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 1e6 + 10;

struct node{
    int start,endi;
    bool operator&lt;(const node&amp;W)const{
        return endi &lt; W.endi;
    }
}a[N];

int n;

int main()
{
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n;i ++) cin &gt;&gt; a[i].start &gt;&gt; a[i].endi;
    sort(a,a+n);
    int pre = a[0].endi;//第一个结束时间最短,一定会选上
    int ans = 1;//记录方案数
    
    for(int i = 1; i &lt; n; i ++)
    {
        if(a[i].start &gt;= pre)
        {
            ans++;
            pre = a[i].endi;
        }
    }
    
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>34 行</span></button></figure><h2 id="p1090合并果子"><a href="#p1090合并果子"><!--[-->P1090合并果子<!--]--></a></h2><blockquote><!--[--><p><!--[-->复杂度是 O(n^2)超时<!--]--></p><!--]--></blockquote><p><!--[-->sort复杂度是O(nlogn)<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int n;//果子的种类数
typedef long long ll;
ll ans;


int main()
{
    cin &gt;&gt; n;
    vector&lt;ll&gt; a(n);
    for(int i = 0; i &lt; n;i++) cin &gt;&gt; a[i];
    ll tmp = 0;
    while(a.size() &gt; 1){
        sort(a.begin(),a.end());//集合排序使用迭代器，复杂度是O(nlogn)
        ll tmp = a[0] + a[1];
        a.erase(a.begin());
        a.erase(a.begin());
        ans += tmp;
        a.push_back(tmp);
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><!----></figure><p><!--[--><strong><!--[-->O(n)做法<!--]--></strong><!--]--></p><p><!--[-->🍔 先说说：什么是堆？<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->堆<!--]--></strong>（Heap）是一种特殊的<strong><!--[-->完全二叉树<!--]--></strong>，在编程里常用来做<strong><!--[-->优先级排序<!--]--></strong>。<!--]--></li><li><!--[-->有两种堆：
<ul><!--[--><li><!--[--><strong><!--[-->最大堆<!--]--></strong>：顶端是最大的元素（默认的 <code data-v-cdb8f38f><!--[-->priority_queue<!--]--></code>）<!--]--></li><li><!--[--><strong><!--[-->最小堆<!--]--></strong>：顶端是最小的元素（我们需要的！）<!--]--></li><!--]--></ul><!--]--></li><!--]--></ul><p><!--[-->🧰 c++ 默认的 <code data-v-cdb8f38f><!--[-->priority_queue<!--]--></code> 是最大堆<!--]--></p><p><!--[-->🧲 想要最小堆怎么办？<!--]--></p><p><!--[-->我们用这个写法：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;
</pre><!----></figure><p><!--[-->解释一下：<!--]--></p><ul><!--[--><li><!--[--><code data-v-cdb8f38f><!--[-->int<!--]--></code>：存放的类型<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->vector&lt;int&gt;<!--]--></code>：底层容器<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->greater&lt;int&gt;<!--]--></code>：比较函数，告诉它“小的优先”，也就是最小堆！<!--]--></li><!--]--></ul><p><!--[-->🪄 你可以记住这个<strong><!--[-->最小堆<!--]--></strong>模板：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>priority_queue&lt;类型, vector&lt;类型&gt;, greater&lt;类型&gt;&gt; 变量名;
</pre><!----></figure><p><!--[--><strong><!--[-->📝 总结一下<!--]--></strong><!--]--></p><div class="md-table" data-v-c54062c4><div class="operations" data-v-c54062c4><button class="button" data-v-c54062c4 data-v-32e6a543><div class="button-main" data-v-32e6a543><!----><!--[--><span class="iconify i-ph:arrow-u-down-left-bold" aria-hidden="true" style="" data-v-c54062c4></span><span class="tooltip" data-v-c54062c4>自动换行</span><!--]--></div><!----></button></div><table class="scroll scrollcheck-x" data-v-c54062c4><!--[--><thead><!--[--><tr><!--[--><th><!--[-->操作<!--]--></th><th><!--[-->意义<!--]--></th><th><!--[-->举例<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->push(x)<!--]--></code><!--]--></td><td><!--[-->把 <code data-v-cdb8f38f><!--[-->x<!--]--></code> 放进堆里<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->pq.push(5);<!--]--></code><!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->pop()<!--]--></code><!--]--></td><td><!--[-->删除堆顶元素（最小值）<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->pq.pop();<!--]--></code><!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->top()<!--]--></code><!--]--></td><td><!--[-->查看堆顶元素（最小值）<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->cout &lt;&lt; pq.top();<!--]--></code><!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table></div><p><!--[--><strong><!--[-->仅堆顶可读<!--]--></strong><!--]--></p><p><!--[--><strong><!--[-->贪心<!--]--></strong>思路：每次选择<strong><!--[-->最小<!--]--></strong>的两堆<strong><!--[-->进行合并<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include &lt;bits/stdc++.h&gt;
using namespace std;

typedef long long ll;

int main() {
    int n;
    cin &gt;&gt; n;
    priority_queue&lt;ll, vector&lt;ll&gt;, greater&lt;ll&gt;&gt; pq; // 小根堆
    for (int i = 0; i &lt; n; i++) {
        ll x;
        cin &gt;&gt; x;
        pq.push(x);
    }

    ll ans = 0;
    while (pq.size() &gt; 1) {
        ll a = pq.top(); pq.pop();
        ll b = pq.top(); pq.pop();
        ll sum = a + b;
        ans += sum;
        pq.push(sum);
    }

    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}

</pre><!----></figure><h2 id="p3817-小a的糖果"><a href="#p3817-小a的糖果"><!--[-->P3817 小A的糖果<!--]--></a></h2><p><!--[-->如果<strong><!--[-->相邻两个盒子糖果的数量大于 x<!--]--></strong>，就吃<strong><!--[-->右边<!--]--></strong>盒子的<strong><!--[-->糖<!--]--></strong>，否则不进行任何操作。<!--]--></p><p><!--[-->为什么要<strong><!--[-->吃右边盒子的糖<!--]--></strong>：这是因为如果我们吃掉左边盒子里的糖，就只会减少这一轮相邻两个盒子糖果的数量；如果我们吃掉右边盒子里的糖，那么这次操作还可以减少<strong><!--[-->下一轮相邻两个盒子糖果的数量<!--]--></strong>，符合贪心的逻辑。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
typedef long long ll;
const int N = 1e5 + 10;
ll a[N];

int main()
{
    int n,x;
    cin &gt;&gt; n &gt;&gt; x;
    for(int i = 1; i &lt;= n;i++) cin &gt;&gt; a[i];
    ll ans = 0;
    for(int i = 1; i &lt;= n;i++) //正好利用a[0] = 0
    {
        if(a[i-1] + a[i] &gt; x)//如果超了，则吃掉右边多余的糖果
        {
            ans += a[i-1] + a[i] - x;
            a[i] = x - a[i-1];
        }
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><!----></figure><h2 id="p1106-删数问题"><a href="#p1106-删数问题"><!--[-->P1106 删数问题<!--]--></a></h2><p><!--[-->sort函数的用法<!--]--></p><p><!--[-->默认是从小到大排序，如果要从大到小排序，则可写成如下格式：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>sort(a,a+len,greater&lt;int&gt;());
</pre><!----></figure><p><!--[-->重点是原左右次序<!--]--></p><p><!--[-->🧠 我们先说 <strong><!--[-->string 的 erase 用法<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>string str = &quot;abcdef&quot;;
str.erase(pos, len);  // 从 pos的索引位置开始，删除 len 个字符
</pre><!----></figure><p><!--[-->✅ 示例 3：只给一个参数，删除从<strong><!--[-->这个位置到末尾<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>string str = &quot;abcdef&quot;;
str.erase(3); // 删除从索引3开始（含）之后的所有字符
cout &lt;&lt; str;  // 输出 abc
</pre><!----></figure><p><!--[-->🧠 vector 的 <code data-v-cdb8f38f><!--[-->erase<!--]--></code> 用法也很类似<!--]--></p><p><!--[-->这里只给一个参数，只能删除给定位置索引的元素，不会删后面的<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>vector&lt;int&gt; v = {1, 2, 3, 4, 5};
v.erase(v.begin() + 2); // 删除索引为 2 的元素（也就是 3）
</pre><!----></figure><p><!--[-->你也可以删除一个范围：(<strong><!--[-->含头不含尾<!--]--></strong>)<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>v.erase(v.begin() + 1, v.begin() + 4); // 删除 2~4（含头不含尾），结果是 {1, 5}
</pre><!----></figure><p><!--[-->贪心的思想是每次<strong><!--[-->删除<!--]--></strong>数字中的<strong><!--[-->极大值<!--]--></strong>！<!--]--></p><p><!--[--><strong><!--[-->❓ 你想让一个数变小，怎么做？<!--]--></strong><!--]--></p><p><!--[-->从左到右，先比较高位！<!--]--></p><ul><!--[--><li><!--[-->最高位大 → 整体大<!--]--></li><li><!--[-->所以你想尽早删掉一个<strong><!--[-->大数<!--]--></strong><!--]--></li><li><!--[-->如果你删的是<strong><!--[-->左边<!--]--></strong>的“高位的<strong><!--[-->大数<!--]--></strong>”，整体数就更小<!--]--></li><!--]--></ul><p><!--[-->所以：
<strong><!--[-->从左往右找到第一个比后面大的数，删掉它，最有“贡献”<!--]--></strong>！<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;
using namespace std;
int main(){
    string n;
    int s,i;
    cin&gt;&gt;n&gt;&gt;s;
    while(s){
        for(i=0;n[i]&lt;=n[i+1] &amp;&amp; i + 1 &lt; n.size();)//找极大值
            i++;
        n.erase(i,1);//删除函数,就是从第i个位置连续删1个。如果不清楚删除函数，可以百度。
        s--;
    }
    while(n[0]==&#039;0&#039;&amp;&amp;n.size()&gt;1){//处理前导零，注意如果长度是1就不能再删了。
        n.erase(0,1);
    }
    cout&lt;&lt;n;
    return 0;
}
</pre><!----></figure><p><!--[--><strong><!--[-->解法二：<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int a[260];
bool flag;//用来标识是否全为0

int main()
{
    string n;
    int k;
    cin &gt;&gt; n &gt;&gt; k;
    
    for(int i = 1; i &lt;= n.size();i++) a[i] = n[i-1] - &#039;0&#039;;
    int aim = n.size() - k,now = 0,tmp = 1,minp = 0;//tmp表示当前序列的起点
    while(now &lt; aim)
    {
        minp = tmp;
        for(int i = tmp;i &lt;= k + tmp;i++) if(a[minp] &gt; a[i]) minp = i;//到k+tmp之间有k个数足够删除
        if(a[minp]) flag = true;//不为0的话
        if(flag) cout &lt;&lt; a[minp]; //首位特判，首位非0后面则输出
        k -= minp - tmp;//表示删除了几个数
        tmp = minp + 1;//下次从选了的数后面开始
        now++;//当前选了的数加1
    }
    
    if(!flag) cout &lt;&lt; 0;//如果一直是0的话
    
    return 0;
}
</pre><!----></figure><h2 id="p1478-陶陶摘苹果"><a href="#p1478-陶陶摘苹果"><!--[-->P1478 陶陶摘苹果<!--]--></a></h2><p><!--[-->贪心的思路是先取花费力气少的，留下更多的力气去拿后面的。<!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
struct node{
    int x,y;//分别是高度和力气
    bool operator&lt;(const node&amp;W)const{
        return y &lt; W.y;
    }
}arr[5010];

int main()
{
    int n,s;
    cin &gt;&gt; n &gt;&gt; s;
    int a,b;
    cin &gt;&gt; a &gt;&gt; b;//椅子高度和手伸直长度
    
    if(n == 0){cout &lt;&lt; 0; return  0;}
    
    for(int i = 0; i &lt; n; i ++) cin &gt;&gt; arr[i].x &gt;&gt; arr[i].y;
    
    sort(arr,arr+n);
    int i = 0,sum = a + b,ans = 0;
    
    while(true)
    {
        if(arr[i].x &lt;= sum &amp;&amp; s &gt;= arr[i].y){
            ans++;
            s -= arr[i].y;
        }
        else if(s &lt; arr[i].y || s &lt; 0) break;
        i++;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>36 行</span></button></figure><h2 id="p5019-铺设道路"><a href="#p5019-铺设道路"><!--[-->P5019 铺设道路<!--]--></a></h2><p><!--[--><strong><!--[-->贪心的核心思想：<!--]--></strong><!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->如果 <code data-v-cdb8f38f><!--[-->a[i]<!--]--></code> 比 <code data-v-cdb8f38f><!--[-->a[i-1]<!--]--></code> 大<!--]--></strong>：那么我们知道从 <code data-v-cdb8f38f><!--[-->a[i-1]<!--]--></code> 到 <code data-v-cdb8f38f><!--[-->a[i]<!--]--></code> 之间的差就是需要额外填充的部分，因此我们加上 <code data-v-cdb8f38f><!--[-->a[i] - a[i-1]<!--]--></code>。<!--]--></li><li><!--[--><strong><!--[-->如果 <code data-v-cdb8f38f><!--[-->a[i]<!--]--></code> 比 <code data-v-cdb8f38f><!--[-->a[i-1]<!--]--></code> 小<!--]--></strong>：这个时候，我们不需要额外填充，只要关注前一个坑即可，因为当前坑已经被前一个坑的操作填补掉了。<!--]--></li><!--]--></ul><p><!--[--><strong><!--[-->为什么贪心是对的：<!--]--></strong><!--]--></p><ul><!--[--><li><!--[-->如果 <code data-v-cdb8f38f><!--[-->a[i]<!--]--></code> 比 <code data-v-cdb8f38f><!--[-->a[i-1]<!--]--></code> 大，直接填充当前的差值 <code data-v-cdb8f38f><!--[-->a[i] - a[i-1]<!--]--></code>，这相当于我们处理一个新坑的深度。<!--]--></li><li><!--[-->如果 <code data-v-cdb8f38f><!--[-->a[i]<!--]--></code> 比 <code data-v-cdb8f38f><!--[-->a[i-1]<!--]--></code> 小，那么前一个坑已经处理过它并填充了这个部分，当前坑不需要额外的操作。<!--]--></li><!--]--></ul><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 1e5 + 10;
int a[N],ans;//ans表示答案

int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++){
        cin &gt;&gt; a[i];
        ans += max(a[i] - a[i-1],0);//当前坑需要填的深度
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><!----></figure><h2 id="p1208mixing-milk"><a href="#p1208mixing-milk"><!--[-->P1208Mixing Milk<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 2e6 + 10;

struct node{
    int p,num;
    bool operator&lt;(const node&amp;W)const{
        return p &lt; W.p;
    }
}a[N];

int main()
{
    int n,m;
    cin &gt;&gt;n &gt;&gt; m;
    for(int i = 0; i &lt; m;i ++) cin &gt;&gt; a[i].p &gt;&gt; a[i].num;
    int now = 0,ans = 0;
    int i = 0,need = n;
    sort(a,a+m);

    while(now != n)
    {
        int tmp = (a[i].num &gt;= need ? need:a[i].num);
//      cout &lt;&lt; &quot;tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;
        ans += tmp * a[i].p;
        now += tmp;
        need -= tmp;
        i++;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>33 行</span></button></figure><h2 id="p1094-纪念品分组"><a href="#p1094-纪念品分组"><!--[-->P1094 纪念品分组<!--]--></a></h2><p><!--[-->我们先将数据进行排序，然后维护两个变量 <em><!--[-->x<!--]--></em> 和 <em><!--[-->y<!--]--></em>，让 <em><!--[-->x<!--]--></em> 指向开头，让 <em><!--[-->y<!--]--></em> 指向结尾。<!--]--></p><p><!--[-->一直循环，过程中会出现两种情况。<!--]--></p><ol><!--[--><li><!--[-->如果当前两个变量所指的两个数之和小于或等于 <em><!--[-->w<!--]--></em>，说明可行，就把它们两个分为一组，同时将 <em><!--[-->x<!--]--></em> 加 1，将 <em><!--[-->y<!--]--></em> 减 1，并将答案加 1，这是第一种情况。<!--]--></li><li><!--[-->如果当前两个变量所指的两个数之和大于 <em><!--[-->w<!--]--></em>，说明不可行，只将 <em><!--[-->y<!--]--></em> 减 1，同时答案加 1 即可，这是第二种情况。<!--]--></li><!--]--></ol><p><!--[-->重复以上过程，直到 <em><!--[-->x<!--]--></em>&gt;<em><!--[-->y<!--]--></em> 时停止循环。<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 3e4 + 10;
int a[N],used[N];
int ans;

using namespace std;
int main()
{
    int w,n;
    cin &gt;&gt; w &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];
    
    sort(a+1,a+n+1);
    int i = 1, j = n;
    while(i &lt;= j)
    {
        if(a[i] + a[j] &gt; w) j--;
        else i++,j--;
        ans++;      
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><!----></figure><h2 id="p4995-跳跳"><a href="#p4995-跳跳"><!--[-->P4995 跳跳！<!--]--></a></h2><p><!--[-->记得开<strong><!--[-->long long<!--]--></strong>，因为hi最大可能为1e4，平方完1e8，继续加可能爆int<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 310;
int a[N];
typedef long long ll;

int main()
{
    int n;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i];
    
    sort(a,a+n+1);
//  for(int i = 0; i &lt;= n;i ++) cout &lt;&lt; a[i] &lt;&lt; &#039; &#039;;
    ll ans = 0,num = 0,i = 0,j = n;
    while(i &lt;= j){
        ans += pow(a[j] - a[i],2);//向右跳
        i++,j--;
    }
    i = 1, j = n;
    while(i &lt;= j)
    {
        ans += pow(a[j] - a[i],2);//向左跳
        i++,j--;
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    return 0;
}
</pre><!----></figure><p><!--[-->更<strong><!--[-->便捷<!--]--></strong>的写法：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;
using namespace std;
unsigned long long ans=0;
int h[330];
bool sum=0;
signed main()
{
    int n;
    cin&gt;&gt;n;
    for (int i=1;i&lt;=n;i++) cin &gt;&gt; h[i];
    sort(h+1,h+n+1);
    int j=0,hpast=0; //j表示当前取的石头位置，hpast是上一次跳的石头高度
    for (int i=1;i&lt;=n;i++)
    {
        j=n-j+sum;// 交替：n-j 是从另一边开始，+sum 是让左右交替
        sum=!sum;
        ans+=(h[j]-hpast)*(h[j]-hpast);
        hpast=h[j];
    }
    cout&lt;&lt;ans;
    return 0;
}
</pre><!----></figure><h2 id="p4447-分组"><a href="#p4447-分组"><!--[-->P4447 分组<!--]--></a></h2><p><!--[-->在 c++ 中，<code data-v-cdb8f38f><!--[-->map<!--]--></code> 是一个非常常用的 <strong><!--[-->关联容器<!--]--></strong>，定义在 <code data-v-cdb8f38f><!--[-->&lt;map&gt;<!--]--></code> 头文件中。它是 <strong><!--[-->STL（标准模板库）<!--]--></strong> 的一部分，提供了 <strong><!--[-->键值对（key-value）<!--]--></strong> 的数据结构<!--]--></p><p><!--[--><strong><!--[-->🌟 简要定义<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>std::map&lt;KeyType, ValueType&gt;
</pre><!----></figure><ul><!--[--><li><!--[--><code data-v-cdb8f38f><!--[-->KeyType<!--]--></code>：键的类型（必须支持 <code data-v-cdb8f38f><!--[-->&lt;<!--]--></code> 比较）<!--]--></li><li><!--[--><code data-v-cdb8f38f><!--[-->ValueType<!--]--></code>：值的类型<!--]--></li><!--]--></ul><p><!--[--><code data-v-cdb8f38f><!--[-->map<!--]--></code> 会 <strong><!--[-->自动按照 key 排序<!--]--></strong>，通常是按<strong><!--[-->升序<!--]--></strong>排列（默认使用 <code data-v-cdb8f38f><!--[-->&lt;<!--]--></code> 运算符）。<!--]--></p><p><!--[--><strong><!--[-->🔧 常用操作<!--]--></strong><!--]--></p><div class="md-table" data-v-c54062c4><div class="operations" data-v-c54062c4><button class="button" data-v-c54062c4 data-v-32e6a543><div class="button-main" data-v-32e6a543><!----><!--[--><span class="iconify i-ph:arrow-u-down-left-bold" aria-hidden="true" style="" data-v-c54062c4></span><span class="tooltip" data-v-c54062c4>自动换行</span><!--]--></div><!----></button></div><table class="scroll scrollcheck-x" data-v-c54062c4><!--[--><thead><!--[--><tr><!--[--><th><!--[-->操作<!--]--></th><th><!--[-->示例<!--]--></th><th><!--[-->说明<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[-->插入<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->m[&quot;key&quot;] = value;<!--]--></code> 或 <code data-v-cdb8f38f><!--[-->m.insert({key, value});<!--]--></code><!--]--></td><td><!--[-->插入或修改元素<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->查找<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->m.find(key)<!--]--></code><!--]--></td><td><!--[-->返回迭代器，指向元素；若不存在，返回 <code data-v-cdb8f38f><!--[-->m.end()<!--]--></code><!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->删除<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->m.erase(key);<!--]--></code><!--]--></td><td><!--[-->删除指定 key 的元素<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->判断是否存在<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->m.count(key)<!--]--></code><!--]--></td><td><!--[-->返回 0 或 1（map 不允许重复键）<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->大小<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->m.size()<!--]--></code><!--]--></td><td><!--[-->元素个数<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->清空<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->m.clear()<!--]--></code><!--]--></td><td><!--[-->删除所有元素<!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table></div><p><!--[--><strong><!--[-->✅ 正确写法回顾<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>std::map&lt;int, int&gt; m;
auto i = m.begin();
// 第一种写法（解引用 + 点）
(*i).second--;
// 第二种写法（推荐，简洁）
i-&gt;second--;
</pre><!----></figure><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;

map&lt;int,int&gt; m;

int main()
{
    int n, ans = INT_MAX;
    cin &gt;&gt; n;
    for(int i = 0; i &lt; n; i ++) {int t;cin &gt;&gt; t;m[t] ++;}
    
    while (!m.empty())
    {
        auto i = m.begin(), j = m.begin();  // 使用 auto推导迭代器类型
        i-&gt;second--;  // 已经画线，所以下面找递增是大于
        int t = 1;// 若 i, j 所对应的能力值是连续的，且i对应的那一列高度不高于j，则继续画线
        for (++j; j != m.end() &amp;&amp; j-&gt;first == i-&gt;first + 1 &amp;&amp; j-&gt;second &gt; i-&gt;second; i++, j++) {
            t++;
            j-&gt;second--;
        }
        i = m.begin();
        while (i != m.end() &amp;&amp; i-&gt;second == 0) m.erase(i++-&gt;first);  // 删除画完线高度为0的元素
        
        if (t &lt; ans) ans = t;  //动态记录画线过程中的最小值
    }
    cout &lt;&lt; ans &lt;&lt; endl;
    
    return 0;
}
</pre><!----></figure><h2 id="p1080-国王游戏"><a href="#p1080-国王游戏"><!--[-->P1080 国王游戏<!--]--></a></h2><p><!--[--><img onerror="this.setAttribute(&#39;data-error&#39;, 1)" alt="image-20250408144329517" data-nuxt-img srcset="https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250408144329517.png 1x, https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250408144329517.png 2x" src="https://cdn.jsdelivr.net/gh/yingzya/markdown_pic/img/image-20250408144329517.png"><!--]--></p><p><!--[-->**ans<span>1</span>是最高位,**高位在前,低位在后<!--]--></p><p><!--[-->**p<span>1</span>是最高位,**高位在前,低位在后<!--]--></p><p><!--[--><strong><!--[-->sum<span>1</span><!--]--></strong> <strong><!--[-->是最低位<!--]--></strong>，低位在前，高位在后<!--]--></p><p><!--[--><strong><!--[-->✅ 对比总结一下<!--]--></strong><!--]--></p><div class="md-table" data-v-c54062c4><div class="operations" data-v-c54062c4><button class="button" data-v-c54062c4 data-v-32e6a543><div class="button-main" data-v-32e6a543><!----><!--[--><span class="iconify i-ph:arrow-u-down-left-bold" aria-hidden="true" style="" data-v-c54062c4></span><span class="tooltip" data-v-c54062c4>自动换行</span><!--]--></div><!----></button></div><table class="scroll scrollcheck-x" data-v-c54062c4><!--[--><thead><!--[--><tr><!--[--><th><!--[-->数组<!--]--></th><th><!--[-->用途<!--]--></th><th><!--[-->低位<!--]--></th><th><!--[-->高位<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->sum<!--]--></code><!--]--></td><td><!--[-->当前正在参与计算的数（<em><!--[-->参与乘法和除法<!--]--></em>）<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->sum[1]<!--]--></code><!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->sum[m]<!--]--></code><!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->ans<!--]--></code><!--]--></td><td><!--[-->每次除法的结果<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->ans[ls]<!--]--></code><!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->ans[1]<!--]--></code><!--]--></td><!--]--></tr><tr><!--[--><td><!--[--><code data-v-cdb8f38f><!--[-->p<!--]--></code><!--]--></td><td><!--[-->最终记录的最大结果<!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->p[lp]<!--]--></code><!--]--></td><td><!--[--><code data-v-cdb8f38f><!--[-->p[1]<!--]--></code><!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table></div><p><!--[-->所以这份代码内部其实用了两种顺序：<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->计算时<!--]--></strong>（如乘法）用“低位在前”顺序（便于进位）<!--]--></li><li><!--[--><strong><!--[-->结果保存/比较/输出时<!--]--></strong>用“高位在前”顺序（符合人类习惯）<!--]--></li><!--]--></ul><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include &lt;bits/stdc++.h&gt;
using namespace std;

int n, a, b, m;             // m 表示 sum 的有效位最大下标
int p[1010], lp = 0;        // p 存当前最大值结果，高精度整数，lp 是最大下标
int sum[1010];              // sum 存当前乘积，高精度整数
int ans[1010], ls = 0;      // ans 存除法结果临时数组，ls 是最大下标
int res;                    // 除法中保存的余数

struct node {
    int a, b;
    bool operator&lt;(const node &amp;W) const {
        return a * b &lt; W.a * W.b;
    }
} arr[1010];

bool compare() {
    int i = 0, j = 0;
    while (i &lt;= lp &amp;&amp; p[i] == 0) i++;  // 去除 p 的前导 0
    while (j &lt;= ls &amp;&amp; ans[j] == 0) j++;  // 去除 ans 的前导 0
    
    int len1 = lp - i + 1;
    int len2 = ls - j + 1;
    if (len1 &gt; len2) return false;
    if (len1 &lt; len2) return true;
    
    while (i &lt;= lp &amp;&amp; j &lt;= ls) {
        if (p[i] &lt; ans[j]) return true;
        if (p[i] &gt; ans[j]) return false;
        i++;
        j++;
    }
    return false;
}

void cheng(int d) {
    for (int i = 0; i &lt;= m; i++) sum[i] *= arr[d].a;
    for (int i = 0; i &lt;= m; i++) {
        sum[i + 1] += sum[i] / 10000;
        sum[i] %= 10000;
    }
    if (sum[m + 1] != 0) m++;
}

void div(int d) {
    memset(ans, 0, sizeof(ans));
    ls = 0;
    while (m &gt;= 0 &amp;&amp; sum[m] == 0) m--;  // 去掉前导0
    res = 0;
    int flag = 0;
    for (int i = m; i &gt;= 0; i--) {
        res = res * 10000 + sum[i];
        ans[++ls] = res / arr[d].b;
        if (ans[ls] == 0 &amp;&amp; !flag) ls--;  // 不保留前导 0
        else flag = 1;
        res %= arr[d].b;
    }
}

int main() {
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
    for (int i = 0; i &lt; n; i++) cin &gt;&gt; arr[i].a &gt;&gt; arr[i].b;
    sort(arr, arr + n);
    
    m = 0;
    memset(sum, 0, sizeof(sum));
    sum[0] = a;
    
    for (int i = 0; i &lt; n; i++) {
        div(i);  // 先除
        if (compare()) {
            lp = ls;
            memcpy(p, ans, sizeof(ans));
        }
        cheng(i);  // 再乘
    }
    
    int i = 0;
    while (i &lt;= lp &amp;&amp; p[i] == 0) i++;  // 去前导0
    if (i &gt; lp) {  // 全是0
        printf(&quot;0\n&quot;);
        return 0;
    }
    
    printf(&quot;%d&quot;, p[i++]);
    for (; i &lt;= lp; i++) {
        printf(&quot;%04d&quot;, p[i]);  // 补足4位
    }
    printf(&quot;\n&quot;);
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>91 行</span></button></figure><h1 id="算法1-7搜索"><!--[-->算法1-7搜索<!--]--></h1><h2 id="p1135-奇怪的电梯"><a href="#p1135-奇怪的电梯"><!--[-->P1135 奇怪的电梯<!--]--></a></h2><p><!--[--><strong><!--[-->1. <code data-v-cdb8f38f><!--[-->memset(dist, 0x3f, sizeof(dist))<!--]--></code> 实际干了啥？<!--]--></strong><!--]--></p><ul><!--[--><li><!--[--><code data-v-cdb8f38f><!--[-->memset<!--]--></code> 会把内存中每个 <strong><!--[-->字节<!--]--></strong>（byte）都设成 <code data-v-cdb8f38f><!--[-->0x3f<!--]--></code>（也就是十进制的 <code data-v-cdb8f38f><!--[-->63<!--]--></code>）。<!--]--></li><li><!--[-->而一个 <code data-v-cdb8f38f><!--[-->int<!--]--></code> 在 c++ 中通常是 <strong><!--[-->4 个字节（32 位）<!--]--></strong>。<!--]--></li><!--]--></ul><p><!--[--><strong><!--[-->所以，每个 <code data-v-cdb8f38f><!--[-->int<!--]--></code> 被填成：<!--]--></strong><!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>0x3f3f3f3f
</pre><!----></figure><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 210;
int k[N],dist[N];
int n,a,b;


void dfs(int id,int step)//id表示当前在几楼,step表示到该楼的最小步数
{
    dist[id] = step;
    int nextid = id - k[id];
    if(nextid &gt;= 1 &amp;&amp; step + 1 &lt; dist[nextid]) dfs(nextid,step + 1);//下，注意剪枝
    
    nextid = id + k[id];
    if(nextid &lt;= n &amp;&amp; step + 1 &lt; dist[nextid]) dfs(nextid,step + 1);//上
    return;
}

int main()
{
    memset(dist,0x3f,sizeof(dist));
    cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; k[i];
    dfs(a,0);
    if(dist[b] == 0x3f3f3f3f) cout &lt;&lt; -1;
    else cout &lt;&lt; dist[b];
    return 0;
}
</pre><!----></figure><h2 id="p1219八皇后-checker-challenge"><a href="#p1219八皇后-checker-challenge"><!--[-->P1219八皇后 checker challenge<!--]--></a></h2><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int a[20][20];//棋盘
int ans;
int col[20],dg[40],udg[40];
int n;
int path[20];

void dfs(int id)//当前在考虑第几行
{
    if(id == n + 1)
    {
        ans++;
        if(ans &lt;= 3) {
            for(int i = 1; i &lt;= n;i++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;
            cout &lt;&lt; endl;
        }
    }
    
    for(int i = 1; i &lt;= n; i ++) //考虑id行i列
    {
        if(!col[i] &amp;&amp; !dg[id + i] &amp;&amp; !udg[i - id + n])
        {
            col[i] = dg[id + i] = udg[i - id + n] = 1;
            path[id] = i;
            dfs(id + 1);
            col[i] = dg[id + i] = udg[i - id + n] = 0;
        }
    }
}

int main()
{
    cin &gt;&gt; n;
    
    dfs(1);
    cout &lt;&lt; ans;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>40 行</span></button></figure><h2 id="p1443-马的遍历"><a href="#p1443-马的遍历"><!--[-->P1443 马的遍历<!--]--></a></h2><p><!--[-->✅ <strong><!--[-->宽度优先搜索（BFS）特别适合用来找“无权图”的最短路！<!--]--></strong><!--]--></p><p><!--[-->🧠 为什么？<!--]--></p><p><!--[-->因为 BFS 是<strong><!--[-->一层一层扩展的<!--]--></strong>，它保证了：<!--]--></p><blockquote><!--[--><p><!--[--><strong><!--[-->第一次到达某个点的时候，所走的步数就是最短的。<!--]--></strong><!--]--></p><!--]--></blockquote><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

# define PII pair&lt;int,int&gt;
using namespace std;

queue&lt;PII&gt; q;//queue是先进先出
int f[410][410];//存到某点的最短步数
bool vis[410][410];//保存是否走过

int dx[8] = {-2,-1,1,2, 2, 1,-1,-2};
int dy[8] = { 1, 2,2,1,-1,-2,-2,-1};
int n,m,x,y;

int main()
{
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;
    memset(f,-1,sizeof(f));
    memset(vis,false,sizeof(vis));
    
    f[x][y] = 0;
    vis[x][y] = true;
    q.push({x,y});
    
    while(!q.empty())
    {
        int xi = q.front().first,yi = q.front().second;
        q.pop();
        for(int i = 0; i &lt; 8; i ++){
            int u = xi + dx[i], v = yi + dy[i];
            if(u &lt; 1 || u &gt; n || v &lt; 1 || v &gt; m || vis[u][v]) continue;
            vis[u][v] = true;
            q.push({u,v});
            f[u][v] = f[xi][yi] + 1;
        }
    }
    for(int i = 1; i &lt;= n;i++){
        for(int j = 1; j &lt;= m; j ++) cout &lt;&lt; f[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
        
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>42 行</span></button></figure><p><!--[--><strong><!--[-->dfs<!--]--></strong>结果<strong><!--[-->超时<!--]--></strong><!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int path[410][410];//表示最短距离

int px[8] = {-2,-1,1,2, 2, 1,-1,-2};
int py[8] = { 1, 2,2,1,-1,-2,-2,-1};
int n,m,x,y;

bool iscan(int x,int y)
{
    if(x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) return false;
    return true;
}

void dfs(int xi,int yi,int step)//表示当前所在的位置,以及到该点用了几步
{
    path[xi][yi] = step;
    for(int i = 0; i &lt; 8;i++)
    {
        if(iscan(xi+px[i],yi+py[i]) &amp;&amp; step + 1 &lt; path[xi + px[i]][yi+py[i]]) 
            dfs(xi + px[i],yi+py[i],step + 1);
    }
    return ;
}

int main()
{
    memset(path,0x3f,sizeof(path));
    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;
    dfs(x,y,0);
    for(int i = 1; i &lt;= n; i ++)
    {
        for(int j = 1; j &lt;= m;j++) 
        {
            if(path[i][j] == 0x3f3f3f3f) cout &lt;&lt; -1 &lt;&lt; &quot; &quot;;
            else cout &lt;&lt; path[i][j] &lt;&lt; &quot; &quot;;
        }
        cout &lt;&lt; endl;
    }
        
    
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>44 行</span></button></figure><h2 id="p2895-meteor-shower-s"><a href="#p2895-meteor-shower-s"><!--[-->P2895 Meteor Shower S<!--]--></a></h2><p><!--[--><strong><!--[-->✅ 那为什么 BFS 要判断“有没有走过”呢？<!--]--></strong><!--]--></p><p><!--[-->因为——<!--]--></p><blockquote><!--[--><p><!--[--><strong><!--[-->BFS 是一层一层地找最短路的，如果一个点你已经访问过，说明你之前已经用更短的时间走到它了！现在再来一次，就是浪费时间，还可能是“更慢的路径”。<!--]--></strong><!--]--></p><!--]--></blockquote><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
#define PII pair&lt;int,int&gt;
int n;
int a[310][310];//记录陨石砸落时间
int vis[310][310];//记录是否走过
int x,y,t;//陨石坐标，砸落时间
int dist[310][310]; //记录到达某点的最短时间

int dx[5]={0,0,0,1,-1};//方便移动和处理陨石砸落
int dy[5]={0,1,-1,0,0};

int ch(int x){//判断路过该点时是否陨石已经砸落，如果是没有陨石，相当于n年后砸落
    if (x==-1) return 99999;
    else return x;
}

void sign(int i,int t)//标记陨石的下落时间
{
    if(x + dx[i] &gt;= 0 &amp;&amp; y + dy[i] &gt;= 0 &amp;&amp; (a[x + dx[i]][y + dy[i]] == -1 || a[x + dx[i]][y + dy[i]] &gt; t))
        a[x + dx[i]][y + dy[i]] = t;
}

int main()
{
    cin &gt;&gt; n;
    memset(a,-1,sizeof(a));//陨石砸落时间初始化
    for(int i = 1; i &lt;= n; i++){
        cin &gt;&gt; x &gt;&gt; y &gt;&gt; t;
        for(int i = 0; i &lt; 5; i ++) sign(i,t);
    }
    
    queue&lt;PII&gt; q;
    vis[0][0] = true;
    q.push({0,0});
    while(!q.empty())
    {
        int x = q.front().first,y = q.front().second;
        q.pop();
        int s = dist[x][y] + 1;//下一格子到达的时间等于当前格子加1
        if(a[x][y] == -1){
            cout &lt;&lt; s - 1;
            return 0;
        }
        for(int i = 1; i &lt;= 4; i ++)
        {
            int xi = x + dx[i],yi = y + dy[i];
            if(xi &gt;= 0 &amp;&amp; yi &gt;= 0 &amp;&amp; s &lt; ch(a[xi][yi]) &amp;&amp; vis[xi][yi] == 0)//在边界内
            //且下一时刻陨石没下楼且没被访问
            {
                q.push({xi,yi});
                vis[xi][yi] = 1;
                dist[xi][yi] = s;
            }
        }
    }
    cout &lt;&lt; -1 &lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>60 行</span></button></figure><h1 id="算法2-1前缀和差分与离散化"><!--[-->算法2-1前缀和、差分与离散化<!--]--></h1><h2 id="p8218-求区间和"><a href="#p8218-求区间和"><!--[-->P8218 求区间和<!--]--></a></h2><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
const int N = 1e5 + 10;
int a[N];

int main()
{
    int n,m;
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n; i ++) cin &gt;&gt; a[i],a[i] += a[i-1];//a[i]表示的是截止到i为止的和
    cin &gt;&gt; m;
    for(int i = 0; i &lt; m;i++)
    {
        int c,d;
        cin &gt;&gt; c &gt;&gt; d;
        cout &lt;&lt; a[d] - a[c-1] &lt;&lt; endl;
    }
    return 0;
}
</pre><!----></figure><h1 id="动态规划1"><!--[-->动态规划1<!--]--></h1><h2 id="p2196-挖地雷"><a href="#p2196-挖地雷"><!--[-->P2196 挖地雷<!--]--></a></h2><p><!--[--><strong><!--[-->暴力DFS写法<!--]--></strong><!--]--></p><figure class="z-codeblock collapsed collapsible" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>#include&lt;bits/stdc++.h&gt;

using namespace std;
int a[30][30];//表示地窖之间的连接情况,1表示有连接
int path[30],ans;//存放最终结果的路径数组,最终的地雷数
int tempath[30],temp;//中间变量
int used[30];//是否用过
int passby;//表示走过的地窖数
int pass_ans;//表示最终走过的地窖数

int n;//表示地窖数
int num[30];//表示地窖内的地雷数组

bool isconnect(int id)//判断是否还有路径
{
    for(int i = 1;i &lt;= n;i++)
        if(a[id][i] &amp;&amp; !used[i]) return true;
    return false;
}

void dfs(int id)//当前准备进入的地窖是id号地窖
{
    if(!isconnect(id)) //没连接返回
    {
        if(temp &gt; ans)//找到了更多地雷的方案
        {
            ans = temp;
            pass_ans = passby;
            for(int i = 1; i &lt;= passby;i++) path[i] = tempath[i];
        }
        return ;
    }
    
    for(int i = 1; i &lt;= n;i++)
    {
        if(a[id][i] &amp;&amp; !used[i])
        {
            used[i] = 1;//该地窖走过了
            passby++;//走过的地窖数➕➕
            tempath[passby] = i;
            temp += num[i];
            
            dfs(i);//去该地窖
            
            used[i] = 0;
            tempath[passby] = 0;
            passby--;
            temp -= num[i];
        }
    }
}

int main()
{
    cin &gt;&gt; n;
    for(int i = 1; i &lt;= n;i++) cin &gt;&gt; num[i];
    for(int i = 1; i &lt;= n - 1;i++)//共n-1行
    {
        int index = i + 1,t;
        for(int j = 1; j &lt;= n - i;j++) {cin &gt;&gt; t; a[i][index] = t;
            index++;
        }   
    }
        
    for(int i = 1; i &lt;= n;i++)//因为起点不一定是1,所以每个起点都遍历一下
    {
        used[i] = 1;
        passby = 0;
        tempath[++passby] = i;
        temp += num[i];
        dfs(i);
        temp -= num[i];
        used[i] = 0;
        
    }
    for(int i = 1; i &lt;= pass_ans;i++) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;
    cout &lt;&lt; endl &lt;&lt; ans&lt;&lt; endl;
    return 0;
}
</pre><button class="toggle-btn" aria-label="展开代码块" data-v-9035432b><span class="iconify i-ph:caret-double-up-bold toggle-icon is-collapsed" aria-hidden="true" style="" data-v-9035432b></span><span class="toggle-tip" data-v-9035432b>79 行</span></button></figure><h1 id="ac贪心"><!--[-->Ac贪心:<!--]--></h1><p><!--[--><code data-v-cdb8f38f><!--[-->memcpy<!--]--></code> 的正确用法是：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>void *memcpy(void *dest, const void *src, size_t n);
</pre><!----></figure><p><!--[-->也就是：<!--]--></p><figure class="z-codeblock" style="--collapsed-rows:16;" data-v-9035432b><figcaption data-v-9035432b><span data-v-9035432b></span><span class="language" data-v-9035432b>c++</span><div class="operations" data-v-9035432b><button data-v-9035432b>自动换行</button><button data-v-9035432b>复制</button></div></figcaption><pre class="language-c++ shiki scrollcheck-x" data-v-9035432b>memcpy(目标地址, 源地址, 拷贝的字节数);
</pre><!----></figure></article><div class="post-footer" data-v-cdb923bb><!----><section class="license" data-v-cdb923bb><div class="title text-creative" data-v-cdb923bb> 许可协议 </div><div class="content" data-v-cdb923bb><p data-v-cdb923bb> 本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans" rel="noopener noreferrer" target="_blank" class="z-link" data-v-cdb923bb data-v-b771bfcd><!--[--><span class="iconify i-ri:creative-commons-line domain-icon" aria-hidden="true" style="" data-v-b771bfcd></span><!--[-->署名-非商业性使用-相同方式共享 4.0 国际<!--]--><!--]--></a> 许可协议，转载请注明出处。 </p></div></section></div><!--[--><!----><div class="surround-post" dir="ltr" data-v-b609bb41><!--[--><a href="/2025/git" class="surround-link" data-v-b609bb41><!--[--><span class="iconify i-solar:rewind-back-bold-duotone rtl-flip" aria-hidden="true" style="" data-v-b609bb41></span><div class="surround-text" data-v-b609bb41><strong class="title text-tech" data-v-b609bb41>Git自动化部署</strong><time datetime="2025-07-31T19:42:40.000Z" data-v-b609bb41>7月31日</time></div><!--]--></a><!--]--><!--[--><a href="/2025/sky_takeaway" class="surround-link" align-end data-v-b609bb41><!--[--><span class="iconify i-solar:rewind-forward-bold-duotone rtl-flip" aria-hidden="true" style="" data-v-b609bb41></span><div class="surround-text" data-v-b609bb41><strong class="title text-tech" data-v-b609bb41>Java苍穹外卖</strong><time datetime="2025-03-18T21:24:59.000Z" data-v-b609bb41>3月18日</time></div><!--]--></a><!--]--></div><!--]--><section class="z-comment" data-v-98eb1275><h3 class="text-creative" data-v-98eb1275> 评论区 </h3><div id="twikoo" data-v-98eb1275><p data-v-98eb1275>评论加载中...</p></div></section><!--]--><footer class="z-footer" data-v-005c9c56><nav class="footer-nav" data-v-005c9c56><!--[--><div class="footer-nav-group" data-v-005c9c56><h3 data-v-005c9c56>探索</h3><menu data-v-005c9c56><!--[--><li data-v-005c9c56><a href="/atom.xml" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:rss-simple-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>Atom订阅</span><!--]--></a></li><li data-v-005c9c56><a href="https://www.travellings.cn/" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:subway-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>开往</span><!--]--></a></li><!--]--></menu></div><div class="footer-nav-group" data-v-005c9c56><h3 data-v-005c9c56>社交</h3><menu data-v-005c9c56><!--[--><li data-v-005c9c56><a href="https://github.com/yingzya" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:github-logo-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>yingzya</span><!--]--></a></li><li data-v-005c9c56><a href="https://jq.qq.com/?_wv=1027&amp;k=lQfNSeEd" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ri:qq-line" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>群: 169994096</span><!--]--></a></li><li data-v-005c9c56><a href="mailto:yzy11235@qq.com" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:envelope-simple-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>yzy11235@qq.com</span><!--]--></a></li><!--]--></menu></div><div class="footer-nav-group" data-v-005c9c56><h3 data-v-005c9c56>信息</h3><menu data-v-005c9c56><!--[--><li data-v-005c9c56><a href="https://github.com/L33Z22L11/blog-v3" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-simple-icons:nuxtdotjs" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>主题: Clarity 1.4.0</span><!--]--></a></li><li data-v-005c9c56><a href="https://blog.zhilu.site/theme" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:swatches-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>主题和组件文档</span><!--]--></a></li><li data-v-005c9c56><a href="https://beian.miit.gov.cn/" rel="noopener noreferrer" target="_blank" data-v-005c9c56><!--[--><span class="iconify i-ph:certificate-bold" aria-hidden="true" style="" data-v-005c9c56></span><span class="nav-text" data-v-005c9c56>晋ICP备2025064396号-2</span><!--]--></a></li><!--]--></menu></div><!--]--></nav><p data-v-005c9c56>© 2025 轻语</p></footer></main><!--[--><!----><aside id="z-aside" class="" data-v-377c1f75><!--[--><section class="widget" data-v-377c1f75 data-v-9ccca5b3 data-v-489d5b4f><hgroup class="widget-title text-creative" data-v-489d5b4f><!--[--><span class="title" data-v-9ccca5b3>文章目录</span><a href="#main-content" aria-label="返回开头" data-v-9ccca5b3><span class="iconify i-ph:arrow-circle-up-bold" aria-hidden="true" style="" data-v-9ccca5b3></span></a><a href="#twikoo" aria-label="评论区" data-v-9ccca5b3><span class="iconify i-ph:chat-circle-text-bold" aria-hidden="true" style="" data-v-9ccca5b3></span></a><!--]--></hgroup><div class="widget-body" data-v-489d5b4f><!----><!--[--><!----><span data-v-9ccca5b3></span><!--]--></div></section><!--]--></aside><!--]--></div><div id="z-panel" class="" data-v-a7de42e5><button id="toggle-sidebar" class="" aria-label="切换菜单" data-v-a7de42e5><span class="iconify i-ph:sidebar-duotone rtl-flip" aria-hidden="true" style="" data-v-a7de42e5></span></button><button id="toggle-aside" class="" aria-label="切换侧边栏" data-v-a7de42e5><span class="iconify i-ph:align-right-duotone rtl-flip" aria-hidden="true" style="" data-v-a7de42e5></span></button></div><!--[--><!--]--><!--]--></div><div id="teleports"></div><script type="application/ld+json" data-nuxt-schema-org="true" data-hid="schema-org-graph">{"@context":"https://schema.org","@graph":[{"@id":"https://blog.yangzy.top/#website","@type":"WebSite","inLanguage":"zh-CN","name":"字节追风者","url":"https://blog.yangzy.top/"},{"@id":"https://blog.yangzy.top/2025/lanqiao2025#webpage","@type":"WebPage","description":"汇总了2025蓝桥杯突击训练过程中的经典算法题解及代码示例，涵盖暴力枚举、递归与递推、贪心算法、搜索算法等多种算法类型","name":"2025蓝桥杯突击训练","url":"https://blog.yangzy.top/2025/lanqiao2025","isPartOf":{"@id":"https://blog.yangzy.top/#website"},"potentialAction":[{"@type":"ReadAction","target":["https://blog.yangzy.top/2025/lanqiao2025"]}]}]}</script><script type="application/json" data-nuxt-data="nuxt-app" data-ssr="true" id="__NUXT_DATA__" data-src="/2025/lanqiao2025/_payload.json?65e504e3-144a-4672-8899-6d7e0db34e11">[{"state":1,"once":16,"_errors":17,"serverRendered":5,"path":19,"pinia":20,"prerenderedAt":158},["Reactive",2],{"$scolor-mode":3,"$snuxt-seo-utils:routeRules":7,"$ssite-config":8},{"preference":4,"value":4,"unknown":5,"forced":6},"system",true,false,{"head":-1,"seoMeta":-1},{"_priority":9,"defaultLocale":12,"env":13,"name":14,"url":15},{"name":10,"env":11,"url":10,"defaultLocale":10},-3,-15,"zh-CN","production","字节追风者","https://blog.yangzy.top/",["Set"],["ShallowReactive",18],{"/2025/lanqiao2025":-1,"surround-/2025/lanqiao2025":-1},"/2025/lanqiao2025",{"layout":21,"search":29,"popover":32,"content":36,"shiki":157},{"open":22,"asideWidgets":25},["Ref",23],["Reactive",24],{"sidebar":6,"aside":6,"search":6},["Ref",26],["Reactive",27],[28],"toc",{"word":30},["EmptyRef",31],"\"\"",{"pops":33},["Ref",34],["Reactive",35],[],{"toc":37,"meta":154},["Ref",38],["Reactive",39],{"title":40,"searchDepth":41,"depth":41,"links":42},"",4,[43,46,49,52,55,58,61,64,67,70,73,76,79,82,85,88,91,94,97,100,103,106,109,112,115,118,121,124,127,130,133,136,139,142,145,148,151],{"id":44,"depth":45,"text":44},"个人的变量命名习惯",2,{"id":47,"depth":45,"text":48},"p2241统计方形","P2241统计方形",{"id":50,"depth":45,"text":51},"p2089烤鸡","P2089烤鸡",{"id":53,"depth":45,"text":54},"p1618三连击","P1618三连击",{"id":56,"depth":45,"text":57},"p1036选数","P1036选数",{"id":59,"depth":45,"text":60},"p1088火星人","P1088火星人",{"id":62,"depth":45,"text":63},"p3799小y拼木棒","P3799小Y拼木棒",{"id":65,"depth":45,"text":66},"p1044栈","P1044栈",{"id":68,"depth":45,"text":69},"p1464记忆化搜索","P1464记忆化搜索",{"id":71,"depth":45,"text":72},"p1928-外星密码","P1928 外星密码",{"id":74,"depth":45,"text":75},"p1255-数楼梯","P1255 数楼梯",{"id":77,"depth":45,"text":78},"p2437-蜜蜂路线","P2437 蜜蜂路线",{"id":80,"depth":45,"text":81},"p1164-小a点菜","P1164 小A点菜",{"id":83,"depth":45,"text":84},"p1990-覆盖墙壁","P1990 覆盖墙壁",{"id":86,"depth":45,"text":87},"p3612-secret-cow-code-s","P3612 Secret cow code S",{"id":89,"depth":45,"text":90},"p1259-黑白棋子的移动","P1259 黑白棋子的移动",{"id":92,"depth":45,"text":93},"p1010幂次方","P1010幂次方",{"id":95,"depth":45,"text":96},"p1228-地毯填补问题","P1228 地毯填补问题",{"id":98,"depth":45,"text":99},"p1498-南蛮图腾","P1498 南蛮图腾",{"id":101,"depth":45,"text":102},"p1223-排队接水","P1223 排队接水",{"id":104,"depth":45,"text":105},"p1803-凌乱的yyy-线段覆盖","P1803 凌乱的yyy / 线段覆盖",{"id":107,"depth":45,"text":108},"p1090合并果子","P1090合并果子",{"id":110,"depth":45,"text":111},"p3817-小a的糖果","P3817 小A的糖果",{"id":113,"depth":45,"text":114},"p1106-删数问题","P1106 删数问题",{"id":116,"depth":45,"text":117},"p1478-陶陶摘苹果","P1478 陶陶摘苹果",{"id":119,"depth":45,"text":120},"p5019-铺设道路","P5019 铺设道路",{"id":122,"depth":45,"text":123},"p1208mixing-milk","P1208Mixing Milk",{"id":125,"depth":45,"text":126},"p1094-纪念品分组","P1094 纪念品分组",{"id":128,"depth":45,"text":129},"p4995-跳跳","P4995 跳跳！",{"id":131,"depth":45,"text":132},"p4447-分组","P4447 分组",{"id":134,"depth":45,"text":135},"p1080-国王游戏","P1080 国王游戏",{"id":137,"depth":45,"text":138},"p1135-奇怪的电梯","P1135 奇怪的电梯",{"id":140,"depth":45,"text":141},"p1219八皇后-checker-challenge","P1219八皇后 checker challenge",{"id":143,"depth":45,"text":144},"p1443-马的遍历","P1443 马的遍历",{"id":146,"depth":45,"text":147},"p2895-meteor-shower-s","P2895 Meteor Shower S",{"id":149,"depth":45,"text":150},"p8218-求区间和","P8218 求区间和",{"id":152,"depth":45,"text":153},"p2196-挖地雷","P2196 挖地雷",["Ref",155],["Reactive",156],{},{},1758975050599]</script><script>window.__NUXT__={};window.__NUXT__.config={public:{buildTime:"2025-09-27T12:10:26.630Z",nodeVersion:"v22.19.0",platform:"linux",arch:"x64",ci:"GitHub Actions",content:{wsUrl:""},mdc:{components:{prose:true,map:{}},headings:{anchorLinks:{h1:false,h2:true,h3:true,h4:true,h5:false,h6:false}}},"seo-utils":{canonicalQueryWhitelist:["page","sort","filter","search","q","category","tag"],canonicalLowercase:true}},app:{baseURL:"/",buildId:"65e504e3-144a-4672-8899-6d7e0db34e11",buildAssetsDir:"/_nuxt/",cdnURL:""}}</script></body></html>