---
title: C++面向对象与YOLO目标检测
description: C++面向对象涵盖封装、继承、多态，支持运算符重载与隐藏；YOLO单阶段检测高效实时，擅长小目标识别，部署便捷。
date: 2025-09-07 18:48:51
updated: 2025-09-07 18:48:51
# image:
# type: story
categories: [复习]
tags: [C++, YOLO]
---

## C++面向对象

### 类 & 对象

定义一个类需要使用关键字 **class**，然后指定类的名称，并类的主体是包含在一对花括号中，主体包含类的成员变量和成员函数。

定义一个类，本质上是定义一个数据类型的蓝图，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。

类内有访问修饰符：关键字 **public** 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 **private** 或 **protected**。

### 封装

封装是 **数据隐藏** 的体现，限制外部直接访问对象的内部状态，只能通过接口操作。

使用访问修饰符：

- `public`：公开的，类外可访问。
- `private`：私有的，仅类内可访问（默认）。
- `protected`：受保护的，类内和子类可访问。

静态成员（**static**）

**静态成员变量**：属于类而不是某个对象，所有对象共享一份。

**静态成员函数**：不依赖具体对象调用，不能访问非静态成员。

### 继承

当创建一个类时，不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**

### 类的指针

不考虑继承，类指针与结构体指针类似

讲真正多态前必须先讲类指针 

- 实际程序中，大量使用类指针 

- 不考虑继承，类指针与结构体指针类似  

```c++
student *p; //新建一个student类指针
student aa; //新建aa对象
p = &aa; //p指针指向aa对象
p -> name; //这个就和aa.name一样，返回aa的name值
p -> study(); //这个相当于aa.study()，对aa执行成员函数
```

- 实际程序中使用更高级写法： 

```c++
student *p = new student(20, '张三'); 
delete p; //调用析构函数
```

把继承考虑进去，复杂一点：
类定义省略，且只考虑公有继承

```c++
student *p1;//新建一个student父类指针
postgraduate *p2;//新建一个postgraduate子类指针
student aa; // 新建父类对象 aa
postgraduate bb;// 新建子类对象 bb
p1 = &aa; // 父类指针指向父类对象，可以
p2 = &bb; // 子类指针指向子类对象，也可以
p1 = &bb; // 父类学生指针指向子类研究生对象，可以
p2 = &aa; // 子类研究生指针指向父类学生对象，这里报错
```

- 父类指针是可以指向子类成员
  - 因为研究生一定是学生的一种
  - 反过来则不行，学生可不一定都是研究生
  - 但 p1 -> research 会报错
  - 虽然父指针指向了 postgraduate，但不能调用 postgraduate 中的属性和方法，父类指针指向子类时，仍然只能用父类中的方法。

### 多态

**虚函数**：
在基类中声明一个函数为虚函数，使用关键字**virtual**。派生类可以重写（**override**）这个虚函数

**静态多态（编译时多态）**：函数重载、运算符重载。

**动态多态（运行时多态）**：通过虚函数实现。

```c++
class Animal {
public:
    virtual void speak() { cout << "Animal sound" << endl; }
};
class Dog : public Animal {
public:
    void speak() override { cout << "Woof!" << endl; }
};
```

**隐藏**：

在父类student和子类postgraduate中都定义一个函数study()，输入参数格式相同不同都可以。

### 重载运算符和重载函数

成员函数的重载：**不同函数**可以有**相同**的函数名，通过**不同**的**输入参数**来识别。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。

重载的**运算符**是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

**隐藏**和**覆盖**的**同名函数**的参数可以完全一样

```c++
class student//类定义，没写全，为了突出重点省略了构造函数和属性
{
public:
    void study (bool a) {cout<<" 好好学习";};
};

class postgraduate : public student//类定义，没写全，为了突出重点省略了构造函数和属性
{
public:
    void study (int b) {cout<<" 芯片设计";};
};

//下面是主函数
postgraduate bb;//子类对象
student aa;//父类对象

bb. study(2);  //研究生对象调用研究生的study方法，参数为int，打印出芯片设计
aa. study( true );    //学生对象调用学生的study方法，参数为bool，打印出好好学习
bb. study( true );    //这行出错，研究生对象，但参数为bool，本来应该重载父类的study方法，因为这时父类方法被隐藏了，系统找不到对应的方法，这就是隐藏和重载的区别
```

##  YOLO

YOLO（You Only Look Once）是 **单阶段目标检测算法**，它直接将目标检测看作一个 **回归问题**，一次前向传播即可同时预测 **类别 + 位置**，相比传统方法和两阶段方法有明显优势：

(1) **实时性强**

- YOLO 系列的设计目标就是 **实时目标检测**。
- 在 GPU 上，可以轻松达到 **几十甚至上百帧/秒**，非常适合实时车牌检测。

(2) **检测小目标能力强**

- 车牌往往是小目标。
- YOLOv5 以后引入 **多尺度特征融合（FPN + PAN）**，提升了对小目标的检测效果。
- YOLOv8/YOLOv10 在 backbone 和 head 上也针对小目标做了优化。

(3) **端到端，部署方便**

- YOLO 模型结构简洁，预测快，支持 **ONNX、TensorRT、NCNN** 等格式。
- 在嵌入式设备（如 Jetson Nano、海思芯片）上也能高效运行，非常适合车牌识别系统的实际部署。

(4) **精度和速度平衡**

- YOLO 在 mAP（准确率指标）和 FPS（速度指标）之间平衡得很好。
- 比如：YOLOv5s、YOLOv8n 在保持较高准确率的同时，体积小，速度快，适合前端设备。

(5) **社区生态好**

- YOLO 系列开源度高，代码成熟，社区资源丰富。
- 车牌检测的很多开源项目、论文都基于 YOLO 改进，复用性强。

| 方法                               | 优点                             | 缺点                             |
| ---------------------------------- | -------------------------------- | -------------------------------- |
| **传统方法 (Haar, HOG+SVM, MSER)** | 简单，不依赖大数据               | 对光照、角度、模糊敏感，准确率低 |
| **两阶段检测 (Faster R-CNN)**      | 准确率高                         | 推理速度慢，不适合实时场景       |
| **SSD**                            | 单阶段，速度快                   | 小目标检测效果不如 YOLO          |
| **YOLO**                           | 实时性好，小目标优化好，部署方便 | 对极端遮挡、超小目标仍有挑战     |

### CNN（卷积神经网络）

**CNN** 的全称是 **Convolutional Neural Network**，中文是**卷积神经网络**。它是一种深度学习模型，最常用于处理**图像和视频数据**。

“卷积”这个名字来源于它使用的数学运算——**卷积**。简单来说，CNN 通过一种叫做“滤波器”（filter）或“卷积核”（kernel）的小窗口在输入数据（比如一张图片）上滑动，来提取各种特征。

你可以把这个过程想象成：CNN 会先学习识别一些最简单的特征，比如边缘和曲线；然后它会把这些简单的特征组合起来，识别更复杂的特征，比如鼻子或眼睛；最后，它会把这些复杂特征组合起来，识别出完整的物体，比如一张脸。

**常见应用：**

- **图像分类：** 判断图片里有什么东西（比如猫、狗、汽车）。
- **物体检测：** 在图片中找到并识别出多个物体的位置。
- **人脸识别：** 识别特定的人脸。

### RNN（循环神经网络）

**RNN** 的全称是 **Recurrent Neural Network**，中文是**循环神经网络**。与 CNN 不同，RNN 专门用来处理**序列数据**，即数据的顺序很重要。

RNN 最核心的特点是它的“**记忆**”功能。它会一步步地处理输入序列，在处理每一步时，都会利用上一步的输出作为当前步的输入。这使得 RNN 能够捕获序列中的依赖关系和上下文信息。

一个简单的比喻就是我们阅读一句话。当我们读到“苹果”这个词时，我们能理解它的含义是因为我们记住了前面出现的词。RNN 的工作方式很类似，它利用内部状态（也就是它的“记忆”）来追踪序列中之前的信息。

**常见应用：**

- **自然语言处理 (NLP)：**
  - **机器翻译：** 把一种语言的文本翻译成另一种语言。
  - **文本生成：** 创作新的句子或段落。
- **语音识别：** 把口语转换成文字。
- **时间序列分析：** 根据过去的数据预测未来的数值（比如股票价格）。
